#!/usr/bin/env Rscript
# Individualized Trajectory-Based Analysis for Celiac Disease Viral Study
# This script implements trajectory analysis focusing on within-individual patterns
# rather than shared taxa across children
# Author: Generated by Claude
# Date: 2025-01-27

library(dplyr)
library(tidyr)
library(tibble)
library(vegan)  # for diversity calculations
library(ggplot2)
library(reshape2)
library(cluster)
library(factoextra)
library(bcp)  # for change point detection
library(mgcv)  # for GAM modeling

# ============================================================================
# PART 1: DATA PREPARATION AND METADATA EXTRACTION
# ============================================================================

# Read the contig abundance data
cat("Reading contig abundance data...\n")
contig_data <- read.csv("US.contig.abundance.table_0.75_prevFiltered_temporal_cleaned_CORRECT.csv", 
                       row.names = 1, stringsAsFactors = FALSE)

# Extract metadata from sample names
# Pattern: X01_GEMM_001_12M -> Patient: 001, Time: 12M
extract_metadata <- function(sample_names) {
  metadata <- data.frame(
    sample_id = sample_names,
    patient_id = gsub(".*GEMM_([0-9]+)_.*", "\\1", sample_names),
    time_months = as.numeric(gsub(".*_([0-9]+)M", "\\1", sample_names)),
    stringsAsFactors = FALSE
  )
  return(metadata)
}

metadata <- extract_metadata(colnames(contig_data))
cat("Extracted metadata for", nrow(metadata), "samples from", 
    length(unique(metadata$patient_id)), "patients\n")

# Add study day (assuming 30 days per month for calculations)
metadata$study_day <- metadata$time_months * 30

# Transpose data for easier analysis (samples as rows)
contig_data_t <- t(contig_data)
contig_data_df <- data.frame(contig_data_t, check.names = FALSE)
contig_data_df$sample_id <- rownames(contig_data_df)
contig_data_df <- merge(contig_data_df, metadata, by = "sample_id")

cat("Data prepared: ", nrow(contig_data_df), "samples x", ncol(contig_data)-1, "contigs\n")

# ============================================================================
# PART 2: WITHIN-INDIVIDUAL DIVERSITY METRICS CALCULATION
# ============================================================================

calculate_diversity_metrics <- function(abundance_matrix) {
  # Remove non-abundance columns for diversity calculations
  abundance_only <- abundance_matrix[, !colnames(abundance_matrix) %in% 
                                    c("sample_id", "patient_id", "time_months", "study_day")]
  
  diversity_metrics <- data.frame(
    sample_id = abundance_matrix$sample_id,
    patient_id = abundance_matrix$patient_id,
    time_months = abundance_matrix$time_months,
    study_day = abundance_matrix$study_day,
    
    # Alpha diversity metrics
    richness = apply(abundance_only, 1, function(x) sum(x > 0)),
    shannon = diversity(abundance_only, index = "shannon"),
    simpson = diversity(abundance_only, index = "simpson"),
    evenness = diversity(abundance_only, index = "shannon") / log(apply(abundance_only, 1, function(x) sum(x > 0))),
    
    # Total viral load
    total_abundance = rowSums(abundance_only),
    
    # Dominance (proportion of most abundant virus)
    dominance = apply(abundance_only, 1, function(x) max(x) / sum(x)),
    
    stringsAsFactors = FALSE
  )
  
  # Handle infinite/NaN values
  diversity_metrics$evenness[is.infinite(diversity_metrics$evenness) | is.nan(diversity_metrics$evenness)] <- 0
  
  return(diversity_metrics)
}

cat("Calculating diversity metrics for all samples...\n")
diversity_data <- calculate_diversity_metrics(contig_data_df)

# ============================================================================
# PART 3: INDIVIDUAL TRAJECTORY ANALYSIS
# ============================================================================

# Function to calculate trajectory slopes and trends for each individual
calculate_individual_trajectories <- function(diversity_data) {
  
  trajectory_results <- list()
  
  for(patient in unique(diversity_data$patient_id)) {
    patient_data <- diversity_data[diversity_data$patient_id == patient, ]
    patient_data <- patient_data[order(patient_data$time_months), ]
    
    if(nrow(patient_data) < 3) {
      cat("Skipping patient", patient, "- insufficient time points\n")
      next
    }
    
    # Calculate slopes using linear regression
    metrics <- c("richness", "shannon", "simpson", "evenness", "total_abundance", "dominance")
    slopes <- list()
    r_squared <- list()
    
    for(metric in metrics) {
      if(length(unique(patient_data[[metric]])) > 1) {
        lm_model <- lm(patient_data[[metric]] ~ patient_data$time_months)
        slopes[[metric]] <- coef(lm_model)[2]
        r_squared[[metric]] <- summary(lm_model)$r.squared
      } else {
        slopes[[metric]] <- 0
        r_squared[[metric]] <- 0
      }
    }
    
    # Calculate rate of change metrics
    turnover_rate <- 0
    if(nrow(patient_data) > 1) {
      # Simple turnover: average change between consecutive time points
      changes <- diff(patient_data$richness) / diff(patient_data$time_months)
      turnover_rate <- mean(abs(changes), na.rm = TRUE)
    }
    
    # Calculate coefficient of variation (stability metric)
    cv_metrics <- list()
    for(metric in metrics) {
      cv_metrics[[paste0("cv_", metric)]] <- sd(patient_data[[metric]], na.rm = TRUE) / 
                                           mean(patient_data[[metric]], na.rm = TRUE)
    }
    
    # Store results
    trajectory_results[[patient]] <- list(
      patient_id = patient,
      n_timepoints = nrow(patient_data),
      time_span = max(patient_data$time_months) - min(patient_data$time_months),
      slopes = slopes,
      r_squared = r_squared,
      turnover_rate = turnover_rate,
      cv_metrics = cv_metrics,
      trajectory_data = patient_data
    )
  }
  
  return(trajectory_results)
}

cat("Calculating individual trajectories...\n")
individual_trajectories <- calculate_individual_trajectories(diversity_data)

# Convert trajectory results to dataframe for analysis
trajectory_summary <- do.call(rbind, lapply(individual_trajectories, function(x) {
  data.frame(
    patient_id = x$patient_id,
    n_timepoints = x$n_timepoints,
    time_span = x$time_span,
    slope_richness = x$slopes$richness,
    slope_shannon = x$slopes$shannon,
    slope_simpson = x$slopes$simpson,
    slope_evenness = x$slopes$evenness,
    slope_total_abundance = x$slopes$total_abundance,
    slope_dominance = x$slopes$dominance,
    r2_richness = x$r_squared$richness,
    r2_shannon = x$r_squared$shannon,
    r2_simpson = x$r_squared$simpson,
    r2_evenness = x$r_squared$evenness,
    r2_total_abundance = x$r_squared$total_abundance,
    r2_dominance = x$r_squared$dominance,
    turnover_rate = x$turnover_rate,
    cv_richness = x$cv_metrics$cv_richness,
    cv_shannon = x$cv_metrics$cv_shannon,
    cv_simpson = x$cv_metrics$cv_simpson,
    cv_evenness = x$cv_metrics$cv_evenness,
    cv_total_abundance = x$cv_metrics$cv_total_abundance,
    cv_dominance = x$cv_metrics$cv_dominance,
    stringsAsFactors = FALSE
  )
}))

# ============================================================================
# PART 4: ECOSYSTEM STABILITY AND PERTURBATION ANALYSIS
# ============================================================================

# Function to detect change points in individual trajectories
detect_change_points <- function(individual_trajectories) {
  
  change_point_results <- list()
  
  for(patient in names(individual_trajectories)) {
    patient_data <- individual_trajectories[[patient]]$trajectory_data
    
    if(nrow(patient_data) < 5) {
      next  # Need sufficient points for change point detection
    }
    
    # Detect change points in Shannon diversity
    if(length(unique(patient_data$shannon)) > 2) {
      tryCatch({
        bcp_result <- bcp(patient_data$shannon, mcmc = 1000, burnin = 100)
        change_probs <- bcp_result$prob.mean
        
        # Identify significant change points (probability > 0.5)
        change_points <- which(change_probs > 0.5)
        
        change_point_results[[patient]] <- list(
          patient_id = patient,
          change_points = change_points,
          change_probabilities = change_probs,
          n_changes = length(change_points),
          max_change_prob = max(change_probs)
        )
      }, error = function(e) {
        cat("Change point detection failed for patient", patient, "\n")
      })
    }
  }
  
  return(change_point_results)
}

cat("Detecting ecosystem change points...\n")
change_points <- detect_change_points(individual_trajectories)

# ============================================================================
# PART 5: FUNCTIONAL TRAJECTORY CLUSTERING
# ============================================================================

# Cluster individuals based on trajectory patterns
cluster_trajectory_patterns <- function(trajectory_summary) {
  
  # Select trajectory features for clustering
  clustering_features <- trajectory_summary[, c("slope_richness", "slope_shannon", 
                                               "slope_simpson", "slope_evenness",
                                               "slope_total_abundance", "slope_dominance",
                                               "turnover_rate", "cv_richness", 
                                               "cv_shannon", "cv_simpson")]
  
  # Remove rows with any NA values
  clustering_features <- clustering_features[complete.cases(clustering_features), ]
  
  if(nrow(clustering_features) < 3) {
    cat("Insufficient complete cases for clustering\n")
    return(NULL)
  }
  
  # Scale features
  clustering_features_scaled <- scale(clustering_features)
  
  # Determine optimal number of clusters
  # Use silhouette method
  silhouette_scores <- c()
  for(k in 2:min(8, nrow(clustering_features_scaled)-1)) {
    km_result <- kmeans(clustering_features_scaled, centers = k, nstart = 25)
    sil_score <- mean(silhouette(km_result$cluster, dist(clustering_features_scaled))[, 3])
    silhouette_scores <- c(silhouette_scores, sil_score)
  }
  
  optimal_k <- which.max(silhouette_scores) + 1
  cat("Optimal number of clusters:", optimal_k, "\n")
  
  # Perform final clustering
  final_clustering <- kmeans(clustering_features_scaled, centers = optimal_k, nstart = 25)
  
  # Add cluster assignments to trajectory summary
  cluster_results <- trajectory_summary[complete.cases(clustering_features), ]
  cluster_results$trajectory_cluster <- final_clustering$cluster
  
  return(list(
    cluster_assignments = cluster_results,
    cluster_centers = final_clustering$centers,
    silhouette_scores = silhouette_scores,
    optimal_k = optimal_k
  ))
}

cat("Clustering trajectory patterns...\n")
trajectory_clusters <- cluster_trajectory_patterns(trajectory_summary)

# ============================================================================
# PART 6: CROSS-INDIVIDUAL PATTERN RECOGNITION
# ============================================================================

# Function to identify common trajectory shapes
identify_trajectory_shapes <- function(individual_trajectories) {
  
  shape_patterns <- list()
  
  # Define trajectory shape categories based on slopes and R-squared
  for(patient in names(individual_trajectories)) {
    traj <- individual_trajectories[[patient]]
    
    # Categorize based on dominant diversity trend
    shannon_slope <- traj$slopes$shannon
    shannon_r2 <- traj$r_squared$shannon
    
    if(shannon_r2 > 0.5) {  # Strong linear trend
      if(shannon_slope > 0.1) {
        shape <- "increasing"
      } else if(shannon_slope < -0.1) {
        shape <- "decreasing"
      } else {
        shape <- "stable"
      }
    } else {
      shape <- "fluctuating"
    }
    
    # Add stability classification
    cv_shannon <- traj$cv_metrics$cv_shannon
    if(is.finite(cv_shannon)) {
      if(cv_shannon < 0.2) {
        stability <- "stable"
      } else if(cv_shannon < 0.5) {
        stability <- "moderate"
      } else {
        stability <- "unstable"
      }
    } else {
      stability <- "unknown"
    }
    
    shape_patterns[[patient]] <- list(
      patient_id = patient,
      trajectory_shape = shape,
      stability_pattern = stability,
      dominant_slope = shannon_slope,
      trend_strength = shannon_r2
    )
  }
  
  return(shape_patterns)
}

cat("Identifying trajectory shape patterns...\n")
trajectory_shapes <- identify_trajectory_shapes(individual_trajectories)

# Convert to dataframe
shape_summary <- do.call(rbind, lapply(trajectory_shapes, function(x) {
  data.frame(
    patient_id = x$patient_id,
    trajectory_shape = x$trajectory_shape,
    stability_pattern = x$stability_pattern,
    dominant_slope = x$dominant_slope,
    trend_strength = x$trend_strength,
    stringsAsFactors = FALSE
  )
}))

# ============================================================================
# PART 7: SAVE RESULTS AND CREATE SUMMARY REPORTS
# ============================================================================

# Save all results
cat("Saving analysis results...\n")

# 1. Individual diversity trajectories
write.csv(diversity_data, "individual_diversity_trajectories.csv", row.names = FALSE)

# 2. Trajectory summary statistics
write.csv(trajectory_summary, "trajectory_slope_analysis.csv", row.names = FALSE)

# 3. Trajectory shape patterns
write.csv(shape_summary, "trajectory_shape_patterns.csv", row.names = FALSE)

# 4. Clustering results
if(!is.null(trajectory_clusters)) {
  write.csv(trajectory_clusters$cluster_assignments, "trajectory_clusters.csv", row.names = FALSE)
}

# 5. Change point analysis (if any detected)
if(length(change_points) > 0) {
  change_point_summary <- do.call(rbind, lapply(change_points, function(x) {
    data.frame(
      patient_id = x$patient_id,
      n_changes = x$n_changes,
      max_change_prob = x$max_change_prob,
      stringsAsFactors = FALSE
    )
  }))
  write.csv(change_point_summary, "change_point_analysis.csv", row.names = FALSE)
}

# ============================================================================
# PART 8: GENERATE SUMMARY STATISTICS AND INSIGHTS
# ============================================================================

cat("\n=== INDIVIDUALIZED TRAJECTORY ANALYSIS SUMMARY ===\n")
cat("Total patients analyzed:", length(unique(diversity_data$patient_id)), "\n")
cat("Total samples:", nrow(diversity_data), "\n")
cat("Average time span per patient:", round(mean(trajectory_summary$time_span, na.rm = TRUE), 1), "months\n")
cat("Average timepoints per patient:", round(mean(trajectory_summary$n_timepoints, na.rm = TRUE), 1), "\n\n")

# Trajectory shape distribution
cat("=== TRAJECTORY SHAPE PATTERNS ===\n")
shape_dist <- table(shape_summary$trajectory_shape)
print(shape_dist)
cat("\n")

# Stability pattern distribution
cat("=== STABILITY PATTERNS ===\n")
stability_dist <- table(shape_summary$stability_pattern)
print(stability_dist)
cat("\n")

# Slope statistics
cat("=== DIVERSITY TRAJECTORY SLOPES ===\n")
cat("Shannon diversity slopes:\n")
print(summary(trajectory_summary$slope_shannon))
cat("Richness slopes:\n")
print(summary(trajectory_summary$slope_richness))
cat("Total abundance slopes:\n")
print(summary(trajectory_summary$slope_total_abundance))
cat("\n")

# Clustering results
if(!is.null(trajectory_clusters)) {
  cat("=== TRAJECTORY CLUSTERING ===\n")
  cat("Optimal number of clusters:", trajectory_clusters$optimal_k, "\n")
  cluster_dist <- table(trajectory_clusters$cluster_assignments$trajectory_cluster)
  cat("Cluster sizes:\n")
  print(cluster_dist)
  cat("\n")
}

# Change point summary
if(length(change_points) > 0) {
  cat("=== ECOSYSTEM CHANGE POINTS ===\n")
  cat("Patients with detected change points:", length(change_points), "\n")
  avg_changes <- mean(sapply(change_points, function(x) x$n_changes))
  cat("Average change points per patient:", round(avg_changes, 2), "\n\n")
}

cat("Analysis completed successfully!\n")
cat("Check the generated CSV files for detailed results.\n")

# ============================================================================
# PART 9: OPTIONAL VISUALIZATION FUNCTIONS
# ============================================================================

# Function to create individual trajectory plots (uncomment to use)
# create_trajectory_plots <- function(diversity_data, output_dir = "trajectory_plots") {
#   dir.create(output_dir, showWarnings = FALSE)
#   
#   for(patient in unique(diversity_data$patient_id)) {
#     patient_data <- diversity_data[diversity_data$patient_id == patient, ]
#     patient_data <- patient_data[order(patient_data$time_months), ]
#     
#     if(nrow(patient_data) < 2) next
#     
#     p <- ggplot(patient_data, aes(x = time_months)) +
#       geom_line(aes(y = shannon, color = "Shannon"), size = 1) +
#       geom_line(aes(y = richness/max(richness) * max(shannon), color = "Richness (scaled)"), size = 1) +
#       geom_point(aes(y = shannon), size = 2) +
#       scale_y_continuous(name = "Shannon Diversity") +
#       scale_x_continuous(name = "Time (months)") +
#       ggtitle(paste("Patient", patient, "- Viral Diversity Trajectory")) +
#       theme_minimal() +
#       theme(legend.position = "bottom")
#     
#     ggsave(file.path(output_dir, paste0("patient_", patient, "_trajectory.png")), 
#            plot = p, width = 8, height = 6, dpi = 300)
#   }
# }

# Uncomment the line below to generate trajectory plots
# create_trajectory_plots(diversity_data)