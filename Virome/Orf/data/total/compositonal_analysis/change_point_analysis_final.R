#!/usr/bin/env Rscript
# Change Point Analysis: Identifying Turning Points in Viral Diversity Trajectories
# CELIAC vs CONTROL divergence timing analysis (Final Version)
# Author: Generated by Claude
# Date: 2025-07-18

# Load required libraries
library(dplyr)
library(ggplot2)
library(gridExtra)

# Set working directory
setwd("/Users/leranwang/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data/total/compositonal_analysis")

cat("=== CHANGE POINT ANALYSIS: VIRAL DIVERSITY TRAJECTORIES ===\n")
cat("Starting change point analysis at:", format(Sys.time()), "\n\n")

# ============================================================================
# PART 1: LOAD DATA AND PREPARE FOR ANALYSIS
# ============================================================================

cat("1. Loading diversity data...\n")

# Load the diversity data generated from the limma analysis
diversity_data_full <- read.csv("diversity_data_full.csv")

# Create time bins for better change point detection
diversity_data_full$time_bin <- cut(diversity_data_full$onset_timeline_numeric, 
                                   breaks = seq(-72, 0, by = 6), 
                                   include.lowest = TRUE, 
                                   labels = seq(-69, -3, by = 6))

# Convert to numeric for analysis
diversity_data_full$time_bin_numeric <- as.numeric(as.character(diversity_data_full$time_bin))

cat("Data loaded:", nrow(diversity_data_full), "samples\n")
cat("Time range:", range(diversity_data_full$onset_timeline_numeric), "\n")
cat("Groups:", table(diversity_data_full$Dx.Status), "\n\n")

# ============================================================================
# PART 2: PREPARE AGGREGATED TIME SERIES DATA
# ============================================================================

cat("2. Preparing time series data...\n")

# Create aggregated time series for each group
time_series_data <- diversity_data_full %>%
  group_by(Dx.Status, time_bin_numeric) %>%
  summarise(
    n_samples = n(),
    mean_richness = mean(richness, na.rm = TRUE),
    se_richness = sd(richness, na.rm = TRUE) / sqrt(n()),
    mean_shannon = mean(shannon, na.rm = TRUE),
    se_shannon = sd(shannon, na.rm = TRUE) / sqrt(n()),
    mean_simpson = mean(simpson, na.rm = TRUE),
    se_simpson = sd(simpson, na.rm = TRUE) / sqrt(n()),
    mean_evenness = mean(evenness, na.rm = TRUE),
    se_evenness = sd(evenness, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  filter(!is.na(time_bin_numeric), n_samples >= 2) %>%
  arrange(Dx.Status, time_bin_numeric)

cat("Time series created with", nrow(time_series_data), "time-group combinations\n")

# ============================================================================
# PART 3: DIVERGENCE ANALYSIS BETWEEN GROUPS
# ============================================================================

cat("\n3. Analyzing divergence between groups...\n")

# Calculate divergence metrics
metrics <- c("richness", "shannon", "simpson", "evenness")

# Initialize empty list to collect divergence data
divergence_list <- list()

for(metric in metrics) {
  # Get data for both groups
  celiac_data <- time_series_data[time_series_data$Dx.Status == "CELIAC", ]
  control_data <- time_series_data[time_series_data$Dx.Status == "CONTROL", ]
  
  # Find common time points
  common_times <- intersect(celiac_data$time_bin_numeric, control_data$time_bin_numeric)
  
  if(length(common_times) >= 3) {
    # Calculate divergence at each time point
    for(time_point in common_times) {
      celiac_value <- celiac_data[celiac_data$time_bin_numeric == time_point, paste0("mean_", metric)]
      control_value <- control_data[control_data$time_bin_numeric == time_point, paste0("mean_", metric)]
      
      if(length(celiac_value) > 0 && length(control_value) > 0) {
        divergence <- abs(celiac_value - control_value)
        divergence_list[[length(divergence_list) + 1]] <- data.frame(
          time_point = time_point, 
          divergence = as.numeric(divergence), 
          metric = metric,
          stringsAsFactors = FALSE
        )
      }
    }
  }
}

# Combine all divergence data
all_divergence <- do.call(rbind, divergence_list)

# Find maximum divergence points
max_divergence_points <- all_divergence %>%
  group_by(metric) %>%
  filter(divergence == max(divergence, na.rm = TRUE)) %>%
  select(metric, time_point, divergence)

cat("Maximum divergence points:\n")
print(max_divergence_points)

# ============================================================================
# PART 4: SIMPLE CHANGE POINT DETECTION
# ============================================================================

cat("\n4. Detecting change points using slope changes...\n")

# Function to detect major slope changes
detect_slope_changes <- function(data, metric, group) {
  group_data <- data[data$Dx.Status == group, ]
  group_data <- group_data[order(group_data$time_bin_numeric), ]
  
  if(nrow(group_data) < 6) {
    return(data.frame(time_point = NA, slope_before = NA, slope_after = NA))
  }
  
  values <- group_data[[paste0("mean_", metric)]]
  time_points <- group_data$time_bin_numeric
  
  slope_changes <- data.frame()
  
  # Calculate slope changes at each potential change point
  for(i in 3:(length(values) - 2)) {
    # Before change point
    before_x <- time_points[1:i]
    before_y <- values[1:i]
    
    # After change point
    after_x <- time_points[i:length(time_points)]
    after_y <- values[i:length(values)]
    
    # Calculate slopes
    if(length(before_x) >= 3 && length(after_x) >= 3) {
      before_slope <- lm(before_y ~ before_x)$coefficients[2]
      after_slope <- lm(after_y ~ after_x)$coefficients[2]
      
      if(!is.na(before_slope) && !is.na(after_slope)) {
        slope_changes <- rbind(slope_changes, 
                              data.frame(time_point = time_points[i],
                                       slope_before = before_slope,
                                       slope_after = after_slope,
                                       slope_change = abs(after_slope - before_slope)))
      }
    }
  }
  
  return(slope_changes)
}

# Apply slope change detection to all metrics and groups
change_point_results <- list()

for(metric in metrics) {
  for(group in c("CELIAC", "CONTROL")) {
    cat("Analyzing slope changes for", metric, "in", group, "group...\n")
    
    slope_changes <- detect_slope_changes(time_series_data, metric, group)
    
    if(nrow(slope_changes) > 0 && !is.na(slope_changes$time_point[1])) {
      # Find the maximum slope change
      max_change_idx <- which.max(slope_changes$slope_change)
      
      change_point_results[[paste(metric, group, sep = "_")]] <- list(
        time_point = slope_changes$time_point[max_change_idx],
        slope_before = slope_changes$slope_before[max_change_idx],
        slope_after = slope_changes$slope_after[max_change_idx],
        slope_change = slope_changes$slope_change[max_change_idx]
      )
    }
  }
}

# ============================================================================
# PART 5: VISUALIZATION OF CHANGE POINTS
# ============================================================================

cat("\n5. Creating change point visualizations...\n")

# Plot 1: Time series with change points
create_change_point_plot <- function(metric) {
  # Get time series data for the metric
  plot_data <- time_series_data %>%
    select(Dx.Status, time_bin_numeric, 
           mean_val = paste0("mean_", metric),
           se_val = paste0("se_", metric)) %>%
    filter(!is.na(mean_val))
  
  p <- ggplot(plot_data, aes(x = time_bin_numeric, y = mean_val, color = Dx.Status)) +
    geom_point(size = 2, alpha = 0.7) +
    geom_line(size = 1) +
    geom_errorbar(aes(ymin = mean_val - se_val, ymax = mean_val + se_val), 
                  width = 1, alpha = 0.7) +
    scale_color_manual(values = c("CONTROL" = "blue", "CELIAC" = "red")) +
    theme_minimal() +
    labs(title = paste("Change Point Analysis:", toupper(metric)),
         subtitle = "Viral diversity trajectories with detected change points",
         x = "Time to Onset (months)", 
         y = paste(toupper(metric), "Diversity"),
         color = "Disease Status") +
    theme(legend.position = "bottom")
  
  # Add change points
  for(group in c("CELIAC", "CONTROL")) {
    result_key <- paste(metric, group, sep = "_")
    if(result_key %in% names(change_point_results)) {
      cpt <- change_point_results[[result_key]]$time_point
      if(!is.na(cpt)) {
        color <- ifelse(group == "CELIAC", "red", "blue")
        p <- p + geom_vline(xintercept = cpt, color = color, 
                           linetype = "dashed", alpha = 0.8, size = 1.2) +
          annotate("text", x = cpt, y = Inf, 
                   label = paste(group, "CP:", round(cpt, 1)), 
                   vjust = if(group == "CELIAC") 1.2 else 2.5, 
                   hjust = 0.5, color = color, size = 3)
      }
    }
  }
  
  # Add divergence maximum
  max_div <- max_divergence_points[max_divergence_points$metric == metric, ]
  if(nrow(max_div) > 0) {
    p <- p + geom_vline(xintercept = max_div$time_point, color = "black", 
                       linetype = "dotted", size = 1.5, alpha = 0.8) +
      annotate("text", x = max_div$time_point, y = Inf, 
               label = paste("Max Div:", round(max_div$time_point, 1)), 
               vjust = 4, hjust = 0.5, color = "black", size = 3, fontface = "bold")
  }
  
  return(p)
}

# Create plots for all metrics
plots <- list()
for(metric in metrics) {
  plots[[metric]] <- create_change_point_plot(metric)
}

# Save individual plots
for(metric in metrics) {
  png(paste0("change_point_", metric, ".png"), width = 1200, height = 800, res = 150)
  print(plots[[metric]])
  dev.off()
}

# Create combined plot
png("change_point_analysis_combined.png", width = 1600, height = 1200, res = 150)
grid.arrange(plots[["richness"]], plots[["shannon"]], 
             plots[["simpson"]], plots[["evenness"]], 
             ncol = 2, nrow = 2)
dev.off()

# Plot 2: Divergence analysis
png("group_divergence_analysis.png", width = 1200, height = 800, res = 150)
ggplot(all_divergence, aes(x = time_point, y = divergence, color = metric)) +
  geom_point(size = 3, alpha = 0.7) +
  geom_line(size = 1.2) +
  geom_smooth(method = "loess", se = TRUE, alpha = 0.3) +
  scale_color_manual(values = c("richness" = "red", "shannon" = "blue", 
                               "simpson" = "green", "evenness" = "purple")) +
  theme_minimal() +
  labs(title = "Group Divergence Analysis Over Time",
       subtitle = "Absolute differences between CELIAC and CONTROL groups",
       x = "Time to Onset (months)",
       y = "Absolute Difference (|CELIAC - CONTROL|)",
       color = "Diversity Metric") +
  theme(legend.position = "bottom",
        plot.title = element_text(size = 14, face = "bold"),
        plot.subtitle = element_text(size = 12)) +
  geom_vline(data = max_divergence_points, aes(xintercept = time_point, color = metric),
             linetype = "dashed", alpha = 0.8, size = 1)
dev.off()

# ============================================================================
# PART 6: SUMMARIZE RESULTS
# ============================================================================

cat("\n6. Summarizing change point results...\n")

# Create summary table
summary_results <- data.frame(
  metric = character(),
  group = character(),
  change_point = numeric(),
  slope_before = numeric(),
  slope_after = numeric(),
  slope_change = numeric(),
  stringsAsFactors = FALSE
)

for(result_key in names(change_point_results)) {
  parts <- strsplit(result_key, "_")[[1]]
  metric <- parts[1]
  group <- parts[2]
  
  result <- change_point_results[[result_key]]
  
  summary_results <- rbind(summary_results, 
                          data.frame(
                            metric = metric,
                            group = group,
                            change_point = result$time_point,
                            slope_before = result$slope_before,
                            slope_after = result$slope_after,
                            slope_change = result$slope_change,
                            stringsAsFactors = FALSE
                          ))
}

# Save summary results
write.csv(summary_results, "change_point_summary.csv", row.names = FALSE)

# Add divergence results to summary
divergence_summary <- max_divergence_points %>%
  rename(max_divergence_time = time_point)

write.csv(divergence_summary, "divergence_summary.csv", row.names = FALSE)

# Calculate average change points by group
group_averages <- summary_results %>%
  group_by(group) %>%
  summarise(
    n_metrics = n(),
    mean_change_point = mean(change_point, na.rm = TRUE),
    median_change_point = median(change_point, na.rm = TRUE),
    sd_change_point = sd(change_point, na.rm = TRUE),
    .groups = "drop"
  )

write.csv(group_averages, "group_change_point_averages.csv", row.names = FALSE)

cat("\nChange point analysis completed successfully!\n")
cat("Generated files:\n")
cat("- change_point_summary.csv: All detected change points\n")
cat("- divergence_summary.csv: Maximum divergence points between groups\n")
cat("- group_change_point_averages.csv: Average change points by group\n")
cat("- change_point_*.png: Individual metric change point plots\n")
cat("- change_point_analysis_combined.png: Combined change point visualization\n")
cat("- group_divergence_analysis.png: Divergence analysis plot\n")

# Print key findings
cat("\n=== KEY FINDINGS ===\n")
cat("Change points detected:\n")
print(summary_results)

cat("\nGroup average change points:\n")
print(group_averages)

cat("\nMaximum divergence points between groups:\n")
print(divergence_summary)

# Calculate critical time windows
cat("\n=== CRITICAL TIME WINDOWS ===\n")
if(nrow(summary_results) > 0) {
  overall_mean <- mean(summary_results$change_point, na.rm = TRUE)
  overall_sd <- sd(summary_results$change_point, na.rm = TRUE)
  
  cat("Overall mean change point:", round(overall_mean, 1), "months\n")
  cat("Standard deviation:", round(overall_sd, 1), "months\n")
  cat("Critical window (mean ± 1SD):", round(overall_mean - overall_sd, 1), "to", round(overall_mean + overall_sd, 1), "months\n")
}

if(nrow(divergence_summary) > 0) {
  div_mean <- mean(divergence_summary$max_divergence_time, na.rm = TRUE)
  cat("Mean maximum divergence time:", round(div_mean, 1), "months\n")
}

cat("\nAnalysis completed at:", format(Sys.time()), "\n")