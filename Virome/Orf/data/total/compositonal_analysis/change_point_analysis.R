#!/usr/bin/env Rscript
# Change Point Analysis: Identifying Turning Points in Viral Diversity Trajectories
# CELIAC vs CONTROL divergence timing analysis
# Author: Generated by Claude
# Date: 2025-07-18

# Load required libraries
library(dplyr)
library(ggplot2)
library(gridExtra)

# Install and load missing packages if needed
required_packages <- c("changepoint", "bcp", "segmented", "mgcv")
for(pkg in required_packages) {
  if (!requireNamespace(pkg, quietly = TRUE)) {
    cat("Installing package:", pkg, "\n")
    install.packages(pkg, repos = "https://cran.r-project.org")
  }
  library(pkg, character.only = TRUE)
}

# Set working directory
setwd("/Users/leranwang/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data/total/compositonal_analysis")

cat("=== CHANGE POINT ANALYSIS: VIRAL DIVERSITY TRAJECTORIES ===\n")
cat("Starting change point analysis at:", format(Sys.time()), "\n\n")

# ============================================================================
# PART 1: LOAD DATA AND PREPARE FOR ANALYSIS
# ============================================================================

cat("1. Loading diversity data...\n")

# Load the diversity data generated from the limma analysis
diversity_data_full <- read.csv("diversity_data_full.csv")

# Create time bins for better change point detection
diversity_data_full$time_bin <- cut(diversity_data_full$onset_timeline_numeric, 
                                   breaks = seq(-72, 0, by = 6), 
                                   include.lowest = TRUE, 
                                   labels = seq(-69, -3, by = 6))

# Convert to numeric for analysis
diversity_data_full$time_bin_numeric <- as.numeric(as.character(diversity_data_full$time_bin))

cat("Data loaded:", nrow(diversity_data_full), "samples\n")
cat("Time range:", range(diversity_data_full$onset_timeline_numeric), "\n")
cat("Groups:", table(diversity_data_full$Dx.Status), "\n\n")

# ============================================================================
# PART 2: PREPARE AGGREGATED TIME SERIES DATA
# ============================================================================

cat("2. Preparing time series data...\n")

# Create aggregated time series for each group
time_series_data <- diversity_data_full %>%
  group_by(Dx.Status, time_bin_numeric) %>%
  summarise(
    n_samples = n(),
    mean_richness = mean(richness, na.rm = TRUE),
    se_richness = sd(richness, na.rm = TRUE) / sqrt(n()),
    mean_shannon = mean(shannon, na.rm = TRUE),
    se_shannon = sd(shannon, na.rm = TRUE) / sqrt(n()),
    mean_simpson = mean(simpson, na.rm = TRUE),
    se_simpson = sd(simpson, na.rm = TRUE) / sqrt(n()),
    mean_evenness = mean(evenness, na.rm = TRUE),
    se_evenness = sd(evenness, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  filter(!is.na(time_bin_numeric), n_samples >= 2) %>%
  arrange(Dx.Status, time_bin_numeric)

cat("Time series created with", nrow(time_series_data), "time-group combinations\n")

# ============================================================================
# PART 3: CHANGE POINT DETECTION METHODS
# ============================================================================

cat("\n3. Applying change point detection methods...\n")

# Method 1: PELT (Pruned Exact Linear Time) change point detection
perform_pelt_analysis <- function(data, metric, group) {
  group_data <- data[data$Dx.Status == group, ]
  group_data <- group_data[order(group_data$time_bin_numeric), ]
  
  if(nrow(group_data) < 10) {
    return(list(changepoints = NA, method = "PELT", group = group, metric = metric))
  }
  
  values <- group_data[[paste0("mean_", metric)]]
  
  tryCatch({
    cpt_result <- cpt.mean(values, method = "PELT", minseglen = 2)
    cpts <- cpts(cpt_result)
    
    # Convert to actual time points
    if(length(cpts) > 0) {
      time_cpts <- group_data$time_bin_numeric[cpts]
      return(list(changepoints = time_cpts, method = "PELT", group = group, metric = metric))
    } else {
      return(list(changepoints = NA, method = "PELT", group = group, metric = metric))
    }
  }, error = function(e) {
    return(list(changepoints = NA, method = "PELT", group = group, metric = metric))
  })
}

# Method 2: Bayesian Change Point (BCP) analysis
perform_bcp_analysis <- function(data, metric, group) {
  group_data <- data[data$Dx.Status == group, ]
  group_data <- group_data[order(group_data$time_bin_numeric), ]
  
  if(nrow(group_data) < 10) {
    return(list(changepoints = NA, prob = NA, method = "BCP", group = group, metric = metric))
  }
  
  values <- group_data[[paste0("mean_", metric)]]
  
  tryCatch({
    bcp_result <- bcp(values, mcmc = 1000, burnin = 100)
    prob_threshold <- 0.5
    
    # Find points with high probability of being change points
    high_prob_points <- which(bcp_result$prob.mean > prob_threshold)
    
    if(length(high_prob_points) > 0) {
      time_cpts <- group_data$time_bin_numeric[high_prob_points]
      return(list(changepoints = time_cpts, 
                 prob = bcp_result$prob.mean[high_prob_points], 
                 method = "BCP", group = group, metric = metric))
    } else {
      return(list(changepoints = NA, prob = NA, method = "BCP", group = group, metric = metric))
    }
  }, error = function(e) {
    return(list(changepoints = NA, prob = NA, method = "BCP", group = group, metric = metric))
  })
}

# Method 3: Segmented regression
perform_segmented_analysis <- function(data, metric, group) {
  group_data <- data[data$Dx.Status == group, ]
  group_data <- group_data[order(group_data$time_bin_numeric), ]
  
  if(nrow(group_data) < 10) {
    return(list(changepoints = NA, method = "Segmented", group = group, metric = metric))
  }
  
  values <- group_data[[paste0("mean_", metric)]]
  time_points <- group_data$time_bin_numeric
  
  tryCatch({
    # Initial linear model
    lm_model <- lm(values ~ time_points)
    
    # Attempt segmented regression
    seg_model <- segmented(lm_model, seg.Z = ~ time_points, npsi = 1)
    
    # Extract breakpoint
    breakpoint <- seg_model$psi[1, "Est."]
    
    return(list(changepoints = breakpoint, method = "Segmented", group = group, metric = metric))
  }, error = function(e) {
    return(list(changepoints = NA, method = "Segmented", group = group, metric = metric))
  })
}

# Method 4: GAM-based change point detection
perform_gam_analysis <- function(data, metric, group) {
  group_data <- data[data$Dx.Status == group, ]
  group_data <- group_data[order(group_data$time_bin_numeric), ]
  
  if(nrow(group_data) < 10) {
    return(list(changepoints = NA, method = "GAM", group = group, metric = metric))
  }
  
  values <- group_data[[paste0("mean_", metric)]]
  time_points <- group_data$time_bin_numeric
  
  tryCatch({
    # Fit GAM with smooth term
    gam_model <- gam(values ~ s(time_points, k = 5))
    
    # Calculate derivatives to find inflection points
    derivatives <- predict(gam_model, type = "response", se.fit = TRUE)
    
    # Find maximum change in derivative (simple approach)
    diff_values <- diff(derivatives$fit)
    max_change_idx <- which.max(abs(diff_values))
    
    if(length(max_change_idx) > 0) {
      changepoint <- time_points[max_change_idx]
      return(list(changepoints = changepoint, method = "GAM", group = group, metric = metric))
    } else {
      return(list(changepoints = NA, method = "GAM", group = group, metric = metric))
    }
  }, error = function(e) {
    return(list(changepoints = NA, method = "GAM", group = group, metric = metric))
  })
}

# Apply all methods to all metrics and groups
metrics <- c("richness", "shannon", "simpson", "evenness")
groups <- c("CELIAC", "CONTROL")

change_point_results <- list()

for(metric in metrics) {
  for(group in groups) {
    cat("Analyzing", metric, "for", group, "group...\n")
    
    # Apply all methods
    pelt_result <- perform_pelt_analysis(time_series_data, metric, group)
    bcp_result <- perform_bcp_analysis(time_series_data, metric, group)
    seg_result <- perform_segmented_analysis(time_series_data, metric, group)
    gam_result <- perform_gam_analysis(time_series_data, metric, group)
    
    change_point_results[[paste(metric, group, "PELT", sep = "_")]] <- pelt_result
    change_point_results[[paste(metric, group, "BCP", sep = "_")]] <- bcp_result
    change_point_results[[paste(metric, group, "Segmented", sep = "_")]] <- seg_result
    change_point_results[[paste(metric, group, "GAM", sep = "_")]] <- gam_result
  }
}

# ============================================================================
# PART 4: DIVERGENCE ANALYSIS BETWEEN GROUPS
# ============================================================================

cat("\n4. Analyzing divergence between groups...\n")

# Calculate divergence metrics
calculate_divergence <- function(data, metric) {
  # Get data for both groups
  celiac_data <- data[data$Dx.Status == "CELIAC", ]
  control_data <- data[data$Dx.Status == "CONTROL", ]
  
  # Find common time points
  common_times <- intersect(celiac_data$time_bin_numeric, control_data$time_bin_numeric)
  
  if(length(common_times) < 5) {
    return(data.frame(time_point = NA, divergence = NA, metric = metric))
  }
  
  # Calculate divergence at each time point
  divergence_data <- data.frame()
  
  for(time_point in common_times) {
    celiac_value <- celiac_data[celiac_data$time_bin_numeric == time_point, paste0("mean_", metric)]
    control_value <- control_data[control_data$time_bin_numeric == time_point, paste0("mean_", metric)]
    
    if(length(celiac_value) > 0 && length(control_value) > 0) {
      divergence <- abs(celiac_value - control_value)
      divergence_data <- rbind(divergence_data, 
                              data.frame(time_point = time_point, 
                                       divergence = divergence, 
                                       metric = metric))
    }
  }
  
  return(divergence_data)
}

# Calculate divergence for all metrics
divergence_results <- list()
for(metric in metrics) {
  divergence_results[[metric]] <- calculate_divergence(time_series_data, metric)
}

# Combine divergence results
all_divergence <- do.call(rbind, divergence_results)

# Find maximum divergence points
max_divergence_points <- all_divergence %>%
  group_by(metric) %>%
  filter(divergence == max(divergence, na.rm = TRUE)) %>%
  select(metric, time_point, divergence)

cat("Maximum divergence points:\n")
print(max_divergence_points)

# ============================================================================
# PART 5: VISUALIZATION OF CHANGE POINTS
# ============================================================================

cat("\n5. Creating change point visualizations...\n")

# Plot 1: Time series with change points
create_change_point_plot <- function(metric) {
  # Get time series data for the metric
  plot_data <- time_series_data %>%
    select(Dx.Status, time_bin_numeric, 
           mean_val = paste0("mean_", metric),
           se_val = paste0("se_", metric)) %>%
    filter(!is.na(mean_val))
  
  p <- ggplot(plot_data, aes(x = time_bin_numeric, y = mean_val, color = Dx.Status)) +
    geom_point(size = 2, alpha = 0.7) +
    geom_line(size = 1) +
    geom_errorbar(aes(ymin = mean_val - se_val, ymax = mean_val + se_val), 
                  width = 1, alpha = 0.7) +
    scale_color_manual(values = c("CONTROL" = "blue", "CELIAC" = "red")) +
    theme_minimal() +
    labs(title = paste("Change Point Analysis:", toupper(metric)),
         subtitle = "Viral diversity trajectories with detected change points",
         x = "Time to Onset (months)", 
         y = paste(toupper(metric), "Diversity"),
         color = "Disease Status") +
    theme(legend.position = "bottom")
  
  # Add change points
  for(group in groups) {
    for(method in c("PELT", "BCP", "Segmented", "GAM")) {
      result_key <- paste(metric, group, method, sep = "_")
      if(result_key %in% names(change_point_results)) {
        cpts <- change_point_results[[result_key]]$changepoints
        if(length(cpts) > 0 && !is.na(cpts[1])) {
          color <- ifelse(group == "CELIAC", "red", "blue")
          linetype <- case_when(
            method == "PELT" ~ "solid",
            method == "BCP" ~ "dashed",
            method == "Segmented" ~ "dotted",
            method == "GAM" ~ "dotdash"
          )
          
          p <- p + geom_vline(xintercept = cpts, color = color, 
                             linetype = linetype, alpha = 0.7, size = 0.8)
        }
      }
    }
  }
  
  # Add divergence maximum
  max_div <- max_divergence_points[max_divergence_points$metric == metric, ]
  if(nrow(max_div) > 0) {
    p <- p + geom_vline(xintercept = max_div$time_point, color = "black", 
                       linetype = "longdash", size = 1.2, alpha = 0.8) +
      annotate("text", x = max_div$time_point, y = Inf, 
               label = paste("Max Divergence:", round(max_div$time_point, 1)), 
               vjust = 1.1, hjust = 0.5, color = "black", size = 3)
  }
  
  return(p)
}

# Create plots for all metrics
plots <- list()
for(metric in metrics) {
  plots[[metric]] <- create_change_point_plot(metric)
}

# Save individual plots
for(metric in metrics) {
  png(paste0("change_point_", metric, ".png"), width = 1200, height = 800, res = 150)
  print(plots[[metric]])
  dev.off()
}

# Create combined plot
png("change_point_analysis_combined.png", width = 1600, height = 1200, res = 150)
grid.arrange(plots[["richness"]], plots[["shannon"]], 
             plots[["simpson"]], plots[["evenness"]], 
             ncol = 2, nrow = 2)
dev.off()

# Plot 2: Divergence analysis
png("group_divergence_analysis.png", width = 1200, height = 800, res = 150)
ggplot(all_divergence, aes(x = time_point, y = divergence, color = metric)) +
  geom_point(size = 2, alpha = 0.7) +
  geom_line(size = 1) +
  geom_smooth(method = "loess", se = TRUE, alpha = 0.3) +
  scale_color_manual(values = c("richness" = "red", "shannon" = "blue", 
                               "simpson" = "green", "evenness" = "purple")) +
  theme_minimal() +
  labs(title = "Group Divergence Analysis",
       subtitle = "Absolute differences between CELIAC and CONTROL groups over time",
       x = "Time to Onset (months)",
       y = "Absolute Difference (|CELIAC - CONTROL|)",
       color = "Diversity Metric") +
  theme(legend.position = "bottom")
dev.off()

# ============================================================================
# PART 6: SUMMARIZE RESULTS
# ============================================================================

cat("\n6. Summarizing change point results...\n")

# Create summary table
summary_results <- data.frame()

for(metric in metrics) {
  for(group in groups) {
    for(method in c("PELT", "BCP", "Segmented", "GAM")) {
      result_key <- paste(metric, group, method, sep = "_")
      if(result_key %in% names(change_point_results)) {
        result <- change_point_results[[result_key]]
        cpts <- result$changepoints
        
        if(length(cpts) > 0 && !is.na(cpts[1])) {
          for(i in 1:length(cpts)) {
            summary_results <- rbind(summary_results, 
                                   data.frame(
                                     metric = metric,
                                     group = group,
                                     method = method,
                                     change_point = cpts[i],
                                     change_point_rank = i
                                   ))
          }
        }
      }
    }
  }
}

# Save summary results
write.csv(summary_results, "change_point_summary.csv", row.names = FALSE)

# Calculate consensus change points (median across methods)
consensus_results <- summary_results %>%
  group_by(metric, group) %>%
  summarise(
    n_methods = n(),
    median_change_point = median(change_point, na.rm = TRUE),
    mean_change_point = mean(change_point, na.rm = TRUE),
    sd_change_point = sd(change_point, na.rm = TRUE),
    min_change_point = min(change_point, na.rm = TRUE),
    max_change_point = max(change_point, na.rm = TRUE),
    .groups = "drop"
  )

write.csv(consensus_results, "consensus_change_points.csv", row.names = FALSE)

# Add divergence results to summary
divergence_summary <- max_divergence_points %>%
  rename(max_divergence_time = time_point)

write.csv(divergence_summary, "divergence_summary.csv", row.names = FALSE)

cat("\nChange point analysis completed successfully!\n")
cat("Generated files:\n")
cat("- change_point_summary.csv: All detected change points by method\n")
cat("- consensus_change_points.csv: Consensus change points across methods\n")
cat("- divergence_summary.csv: Maximum divergence points between groups\n")
cat("- change_point_*.png: Individual metric change point plots\n")
cat("- change_point_analysis_combined.png: Combined change point visualization\n")
cat("- group_divergence_analysis.png: Divergence analysis plot\n")

# Print key findings
cat("\n=== KEY FINDINGS ===\n")
cat("Consensus change points (median across methods):\n")
print(consensus_results)

cat("\nMaximum divergence points between groups:\n")
print(divergence_summary)

cat("\nAnalysis completed at:", format(Sys.time()), "\n")