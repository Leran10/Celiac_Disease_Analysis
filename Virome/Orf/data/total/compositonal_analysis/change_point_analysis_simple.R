#!/usr/bin/env Rscript
# Change Point Analysis: Identifying Turning Points in Viral Diversity Trajectories
# CELIAC vs CONTROL divergence timing analysis (Simplified Version)
# Author: Generated by Claude
# Date: 2025-07-18

# Load required libraries
library(dplyr)
library(ggplot2)
library(gridExtra)

# Try to load changepoint package, skip if not available
changepoint_available <- requireNamespace("changepoint", quietly = TRUE)
if(changepoint_available) {
  library(changepoint)
}

# Set working directory
setwd("/Users/leranwang/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data/total/compositonal_analysis")

cat("=== CHANGE POINT ANALYSIS: VIRAL DIVERSITY TRAJECTORIES ===\n")
cat("Starting change point analysis at:", format(Sys.time()), "\n\n")

# ============================================================================
# PART 1: LOAD DATA AND PREPARE FOR ANALYSIS
# ============================================================================

cat("1. Loading diversity data...\n")

# Load the diversity data generated from the limma analysis
diversity_data_full <- read.csv("diversity_data_full.csv")

# Create time bins for better change point detection
diversity_data_full$time_bin <- cut(diversity_data_full$onset_timeline_numeric, 
                                   breaks = seq(-72, 0, by = 6), 
                                   include.lowest = TRUE, 
                                   labels = seq(-69, -3, by = 6))

# Convert to numeric for analysis
diversity_data_full$time_bin_numeric <- as.numeric(as.character(diversity_data_full$time_bin))

cat("Data loaded:", nrow(diversity_data_full), "samples\n")
cat("Time range:", range(diversity_data_full$onset_timeline_numeric), "\n")
cat("Groups:", table(diversity_data_full$Dx.Status), "\n\n")

# ============================================================================
# PART 2: PREPARE AGGREGATED TIME SERIES DATA
# ============================================================================

cat("2. Preparing time series data...\n")

# Create aggregated time series for each group
time_series_data <- diversity_data_full %>%
  group_by(Dx.Status, time_bin_numeric) %>%
  summarise(
    n_samples = n(),
    mean_richness = mean(richness, na.rm = TRUE),
    se_richness = sd(richness, na.rm = TRUE) / sqrt(n()),
    mean_shannon = mean(shannon, na.rm = TRUE),
    se_shannon = sd(shannon, na.rm = TRUE) / sqrt(n()),
    mean_simpson = mean(simpson, na.rm = TRUE),
    se_simpson = sd(simpson, na.rm = TRUE) / sqrt(n()),
    mean_evenness = mean(evenness, na.rm = TRUE),
    se_evenness = sd(evenness, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  ) %>%
  filter(!is.na(time_bin_numeric), n_samples >= 2) %>%
  arrange(Dx.Status, time_bin_numeric)

cat("Time series created with", nrow(time_series_data), "time-group combinations\n")

# ============================================================================
# PART 3: SIMPLE CHANGE POINT DETECTION METHODS
# ============================================================================

cat("\n3. Applying change point detection methods...\n")

# Method 1: Moving window variance change point detection
detect_variance_change_points <- function(data, metric, group, window_size = 3) {
  group_data <- data[data$Dx.Status == group, ]
  group_data <- group_data[order(group_data$time_bin_numeric), ]
  
  if(nrow(group_data) < window_size * 2) {
    return(data.frame(time_point = NA, variance_ratio = NA))
  }
  
  values <- group_data[[paste0("mean_", metric)]]
  time_points <- group_data$time_bin_numeric
  
  variance_ratios <- c()
  change_points <- c()
  
  for(i in (window_size + 1):(length(values) - window_size)) {
    before_var <- var(values[(i - window_size):i])
    after_var <- var(values[i:(i + window_size)])
    
    if(before_var > 0 && after_var > 0) {
      variance_ratio <- after_var / before_var
      variance_ratios <- c(variance_ratios, variance_ratio)
      change_points <- c(change_points, time_points[i])
    }
  }
  
  if(length(variance_ratios) > 0) {
    return(data.frame(time_point = change_points, variance_ratio = variance_ratios))
  } else {
    return(data.frame(time_point = NA, variance_ratio = NA))
  }
}

# Method 2: Slope change detection
detect_slope_change_points <- function(data, metric, group, window_size = 3) {
  group_data <- data[data$Dx.Status == group, ]
  group_data <- group_data[order(group_data$time_bin_numeric), ]
  
  if(nrow(group_data) < window_size * 2) {
    return(data.frame(time_point = NA, slope_change = NA))
  }
  
  values <- group_data[[paste0("mean_", metric)]]
  time_points <- group_data$time_bin_numeric
  
  slope_changes <- c()
  change_points <- c()
  
  for(i in (window_size + 1):(length(values) - window_size)) {
    # Calculate slope before and after
    before_x <- time_points[(i - window_size):i]
    before_y <- values[(i - window_size):i]
    after_x <- time_points[i:(i + window_size)]
    after_y <- values[i:(i + window_size)]
    
    if(length(before_x) > 1 && length(after_x) > 1) {
      before_slope <- lm(before_y ~ before_x)$coefficients[2]
      after_slope <- lm(after_y ~ after_x)$coefficients[2]
      
      if(!is.na(before_slope) && !is.na(after_slope)) {
        slope_change <- abs(after_slope - before_slope)
        slope_changes <- c(slope_changes, slope_change)
        change_points <- c(change_points, time_points[i])
      }
    }
  }
  
  if(length(slope_changes) > 0) {
    return(data.frame(time_point = change_points, slope_change = slope_changes))
  } else {
    return(data.frame(time_point = NA, slope_change = NA))
  }
}

# Method 3: CUSUM (Cumulative Sum) change point detection
detect_cusum_change_points <- function(data, metric, group) {
  group_data <- data[data$Dx.Status == group, ]
  group_data <- group_data[order(group_data$time_bin_numeric), ]
  
  if(nrow(group_data) < 6) {
    return(data.frame(time_point = NA, cusum_stat = NA))
  }
  
  values <- group_data[[paste0("mean_", metric)]]
  time_points <- group_data$time_bin_numeric
  
  n <- length(values)
  overall_mean <- mean(values)
  
  cusum_stats <- c()
  change_points <- c()
  
  for(i in 2:(n-1)) {
    # Calculate CUSUM statistic
    before_mean <- mean(values[1:i])
    after_mean <- mean(values[(i+1):n])
    
    # Simple CUSUM statistic
    cusum_stat <- abs(before_mean - after_mean) * sqrt(i * (n - i) / n)
    
    cusum_stats <- c(cusum_stats, cusum_stat)
    change_points <- c(change_points, time_points[i])
  }
  
  if(length(cusum_stats) > 0) {
    return(data.frame(time_point = change_points, cusum_stat = cusum_stats))
  } else {
    return(data.frame(time_point = NA, cusum_stat = NA))
  }
}

# Method 4: Maximum likelihood change point detection (if changepoint package available)
detect_ml_change_points <- function(data, metric, group) {
  if(!changepoint_available) {
    return(data.frame(time_point = NA, method = "ML_not_available"))
  }
  
  group_data <- data[data$Dx.Status == group, ]
  group_data <- group_data[order(group_data$time_bin_numeric), ]
  
  if(nrow(group_data) < 10) {
    return(data.frame(time_point = NA, method = "ML_insufficient_data"))
  }
  
  values <- group_data[[paste0("mean_", metric)]]
  
  tryCatch({
    cpt_result <- cpt.mean(values, method = "PELT", minseglen = 2)
    cpts <- cpts(cpt_result)
    
    if(length(cpts) > 0) {
      time_cpts <- group_data$time_bin_numeric[cpts]
      return(data.frame(time_point = time_cpts, method = "ML_PELT"))
    } else {
      return(data.frame(time_point = NA, method = "ML_no_change"))
    }
  }, error = function(e) {
    return(data.frame(time_point = NA, method = "ML_error"))
  })
}

# Apply all methods
metrics <- c("richness", "shannon", "simpson", "evenness")
groups <- c("CELIAC", "CONTROL")

change_point_results <- list()

for(metric in metrics) {
  for(group in groups) {
    cat("Analyzing", metric, "for", group, "group...\n")
    
    # Variance change points
    var_result <- detect_variance_change_points(time_series_data, metric, group)
    if(!is.na(var_result$time_point[1])) {
      # Find maximum variance change
      max_var_idx <- which.max(var_result$variance_ratio)
      change_point_results[[paste(metric, group, "Variance", sep = "_")]] <- 
        list(time_point = var_result$time_point[max_var_idx], 
             statistic = var_result$variance_ratio[max_var_idx],
             method = "Variance")
    }
    
    # Slope change points
    slope_result <- detect_slope_change_points(time_series_data, metric, group)
    if(!is.na(slope_result$time_point[1])) {
      # Find maximum slope change
      max_slope_idx <- which.max(slope_result$slope_change)
      change_point_results[[paste(metric, group, "Slope", sep = "_")]] <- 
        list(time_point = slope_result$time_point[max_slope_idx], 
             statistic = slope_result$slope_change[max_slope_idx],
             method = "Slope")
    }
    
    # CUSUM change points
    cusum_result <- detect_cusum_change_points(time_series_data, metric, group)
    if(!is.na(cusum_result$time_point[1])) {
      # Find maximum CUSUM statistic
      max_cusum_idx <- which.max(cusum_result$cusum_stat)
      change_point_results[[paste(metric, group, "CUSUM", sep = "_")]] <- 
        list(time_point = cusum_result$time_point[max_cusum_idx], 
             statistic = cusum_result$cusum_stat[max_cusum_idx],
             method = "CUSUM")
    }
    
    # ML change points (if available)
    ml_result <- detect_ml_change_points(time_series_data, metric, group)
    if(!is.na(ml_result$time_point[1])) {
      change_point_results[[paste(metric, group, "ML", sep = "_")]] <- 
        list(time_point = ml_result$time_point[1], 
             statistic = NA,
             method = "ML")
    }
  }
}

# ============================================================================
# PART 4: DIVERGENCE ANALYSIS BETWEEN GROUPS
# ============================================================================

cat("\n4. Analyzing divergence between groups...\n")

# Calculate divergence metrics
calculate_divergence <- function(data, metric) {
  # Get data for both groups
  celiac_data <- data[data$Dx.Status == "CELIAC", ]
  control_data <- data[data$Dx.Status == "CONTROL", ]
  
  # Find common time points
  common_times <- intersect(celiac_data$time_bin_numeric, control_data$time_bin_numeric)
  
  if(length(common_times) < 3) {
    return(data.frame(time_point = NA, divergence = NA, metric = metric))
  }
  
  # Calculate divergence at each time point
  divergence_data <- data.frame()
  
  for(time_point in common_times) {
    celiac_value <- celiac_data[celiac_data$time_bin_numeric == time_point, paste0("mean_", metric)]
    control_value <- control_data[control_data$time_bin_numeric == time_point, paste0("mean_", metric)]
    
    if(length(celiac_value) > 0 && length(control_value) > 0) {
      divergence <- abs(celiac_value - control_value)
      divergence_data <- rbind(divergence_data, 
                              data.frame(time_point = time_point, 
                                       divergence = divergence, 
                                       metric = metric))
    }
  }
  
  return(divergence_data)
}

# Calculate divergence for all metrics
divergence_results <- list()
for(metric in metrics) {
  divergence_results[[metric]] <- calculate_divergence(time_series_data, metric)
}

# Combine divergence results
all_divergence <- do.call(rbind, divergence_results)
rownames(all_divergence) <- NULL

# Find maximum divergence points
max_divergence_points <- all_divergence %>%
  group_by(metric) %>%
  filter(divergence == max(divergence, na.rm = TRUE)) %>%
  select(metric, time_point, divergence)

cat("Maximum divergence points:\n")
print(max_divergence_points)

# ============================================================================
# PART 5: VISUALIZATION OF CHANGE POINTS
# ============================================================================

cat("\n5. Creating change point visualizations...\n")

# Plot 1: Time series with change points
create_change_point_plot <- function(metric) {
  # Get time series data for the metric
  plot_data <- time_series_data %>%
    select(Dx.Status, time_bin_numeric, 
           mean_val = paste0("mean_", metric),
           se_val = paste0("se_", metric)) %>%
    filter(!is.na(mean_val))
  
  p <- ggplot(plot_data, aes(x = time_bin_numeric, y = mean_val, color = Dx.Status)) +
    geom_point(size = 2, alpha = 0.7) +
    geom_line(size = 1) +
    geom_errorbar(aes(ymin = mean_val - se_val, ymax = mean_val + se_val), 
                  width = 1, alpha = 0.7) +
    scale_color_manual(values = c("CONTROL" = "blue", "CELIAC" = "red")) +
    theme_minimal() +
    labs(title = paste("Change Point Analysis:", toupper(metric)),
         subtitle = "Viral diversity trajectories with detected change points",
         x = "Time to Onset (months)", 
         y = paste(toupper(metric), "Diversity"),
         color = "Disease Status") +
    theme(legend.position = "bottom")
  
  # Add change points
  methods <- c("Variance", "Slope", "CUSUM", "ML")
  linetypes <- c("solid", "dashed", "dotted", "dotdash")
  
  for(i in 1:length(methods)) {
    method <- methods[i]
    linetype <- linetypes[i]
    
    for(group in groups) {
      result_key <- paste(metric, group, method, sep = "_")
      if(result_key %in% names(change_point_results)) {
        cpt <- change_point_results[[result_key]]$time_point
        if(!is.na(cpt)) {
          color <- ifelse(group == "CELIAC", "red", "blue")
          p <- p + geom_vline(xintercept = cpt, color = color, 
                             linetype = linetype, alpha = 0.7, size = 0.8)
        }
      }
    }
  }
  
  # Add divergence maximum
  max_div <- max_divergence_points[max_divergence_points$metric == metric, ]
  if(nrow(max_div) > 0) {
    p <- p + geom_vline(xintercept = max_div$time_point, color = "black", 
                       linetype = "longdash", size = 1.2, alpha = 0.8) +
      annotate("text", x = max_div$time_point, y = Inf, 
               label = paste("Max Divergence:", round(max_div$time_point, 1)), 
               vjust = 1.1, hjust = 0.5, color = "black", size = 3)
  }
  
  return(p)
}

# Create plots for all metrics
plots <- list()
for(metric in metrics) {
  plots[[metric]] <- create_change_point_plot(metric)
}

# Save individual plots
for(metric in metrics) {
  png(paste0("change_point_", metric, ".png"), width = 1200, height = 800, res = 150)
  print(plots[[metric]])
  dev.off()
}

# Create combined plot
png("change_point_analysis_combined.png", width = 1600, height = 1200, res = 150)
grid.arrange(plots[["richness"]], plots[["shannon"]], 
             plots[["simpson"]], plots[["evenness"]], 
             ncol = 2, nrow = 2)
dev.off()

# Plot 2: Divergence analysis
png("group_divergence_analysis.png", width = 1200, height = 800, res = 150)
ggplot(all_divergence, aes(x = time_point, y = divergence, color = metric)) +
  geom_point(size = 2, alpha = 0.7) +
  geom_line(size = 1) +
  geom_smooth(method = "loess", se = TRUE, alpha = 0.3) +
  scale_color_manual(values = c("richness" = "red", "shannon" = "blue", 
                               "simpson" = "green", "evenness" = "purple")) +
  theme_minimal() +
  labs(title = "Group Divergence Analysis",
       subtitle = "Absolute differences between CELIAC and CONTROL groups over time",
       x = "Time to Onset (months)",
       y = "Absolute Difference (|CELIAC - CONTROL|)",
       color = "Diversity Metric") +
  theme(legend.position = "bottom")
dev.off()

# ============================================================================
# PART 6: SUMMARIZE RESULTS
# ============================================================================

cat("\n6. Summarizing change point results...\n")

# Create summary table
summary_results <- data.frame()

for(result_key in names(change_point_results)) {
  parts <- strsplit(result_key, "_")[[1]]
  metric <- parts[1]
  group <- parts[2]
  method <- parts[3]
  
  result <- change_point_results[[result_key]]
  
  summary_results <- rbind(summary_results, 
                          data.frame(
                            metric = metric,
                            group = group,
                            method = method,
                            change_point = result$time_point,
                            statistic = if(is.null(result$statistic)) NA else result$statistic
                          ))
}

# Save summary results
write.csv(summary_results, "change_point_summary.csv", row.names = FALSE)

# Calculate consensus change points (median across methods)
consensus_results <- summary_results %>%
  group_by(metric, group) %>%
  summarise(
    n_methods = n(),
    median_change_point = median(change_point, na.rm = TRUE),
    mean_change_point = mean(change_point, na.rm = TRUE),
    sd_change_point = sd(change_point, na.rm = TRUE),
    min_change_point = min(change_point, na.rm = TRUE),
    max_change_point = max(change_point, na.rm = TRUE),
    .groups = "drop"
  ) %>%
  filter(!is.na(median_change_point))

write.csv(consensus_results, "consensus_change_points.csv", row.names = FALSE)

# Add divergence results to summary
divergence_summary <- max_divergence_points %>%
  rename(max_divergence_time = time_point)

write.csv(divergence_summary, "divergence_summary.csv", row.names = FALSE)

cat("\nChange point analysis completed successfully!\n")
cat("Generated files:\n")
cat("- change_point_summary.csv: All detected change points by method\n")
cat("- consensus_change_points.csv: Consensus change points across methods\n")
cat("- divergence_summary.csv: Maximum divergence points between groups\n")
cat("- change_point_*.png: Individual metric change point plots\n")
cat("- change_point_analysis_combined.png: Combined change point visualization\n")
cat("- group_divergence_analysis.png: Divergence analysis plot\n")

# Print key findings
cat("\n=== KEY FINDINGS ===\n")
cat("Consensus change points (median across methods):\n")
print(consensus_results)

cat("\nMaximum divergence points between groups:\n")
print(divergence_summary)

cat("\nAnalysis completed at:", format(Sys.time()), "\n")