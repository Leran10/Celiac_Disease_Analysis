#!/usr/bin/env Rscript
# Enhanced Pattern-Based Clustering for All Significant ORFs
# Removes Plot 14 and enhances Plot 18 with trend-based clustering
# Author: Generated by Claude
# Date: 2025-07-18

library(dplyr)
library(ggplot2)
library(pheatmap)
library(RColorBrewer)

# Set working directory
setwd("/Users/leranwang/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data/total/compositonal_analysis")

cat("=== ENHANCED PATTERN-BASED CLUSTERING ===\n")
cat("Starting analysis at:", format(Sys.time()), "\n\n")

# ============================================================================
# PART 1: LOAD EXISTING DATA
# ============================================================================

cat("1. Loading existing temporal data...\n")

# Load the comprehensive temporal matrix from previous analysis
if(!file.exists("all_significant_orfs_temporal_matrix.csv")) {
  stop("Please run all_significant_orfs_heatmap.R first to generate the temporal matrix")
}

temporal_matrix <- read.csv("all_significant_orfs_temporal_matrix.csv", row.names = 1)
cat("Loaded temporal matrix:", dim(temporal_matrix), "\n")

# Apply log2 transformation for better visualization
temporal_log <- temporal_matrix
temporal_log[is.na(temporal_log)] <- 0
temporal_log <- sign(temporal_log) * log2(abs(temporal_log) + 1)

cat("Applied log2 transformation\n")
cat("Scale range:", round(min(temporal_log, na.rm = TRUE), 2), "to", round(max(temporal_log, na.rm = TRUE), 2), "\n")

# ============================================================================
# PART 2: ADVANCED PATTERN-BASED CLUSTERING
# ============================================================================

cat("\n2. Performing advanced pattern-based clustering...\n")

# Function to extract temporal trend features for each ORF
extract_temporal_features <- function(temporal_data) {
  
  time_points <- as.numeric(gsub("T", "", colnames(temporal_data)))
  
  features_list <- list()
  
  for(i in 1:nrow(temporal_data)) {
    orf_id <- rownames(temporal_data)[i]
    orf_values <- as.numeric(temporal_data[i, ])
    
    # Remove NAs for trend calculation
    valid_indices <- !is.na(orf_values)
    if(sum(valid_indices) < 3) {
      next  # Skip ORFs with too few data points
    }
    
    valid_times <- time_points[valid_indices]
    valid_values <- orf_values[valid_indices]
    
    # Calculate trend features
    tryCatch({
      # Linear trend
      linear_model <- lm(valid_values ~ valid_times)
      slope <- coef(linear_model)[2]
      
      # Overall pattern characteristics
      mean_value <- mean(valid_values, na.rm = TRUE)
      variance <- var(valid_values, na.rm = TRUE)
      range_val <- max(valid_values, na.rm = TRUE) - min(valid_values, na.rm = TRUE)
      
      # Early vs late pattern (first half vs second half)
      n_points <- length(valid_values)
      mid_point <- ceiling(n_points / 2)
      early_mean <- mean(valid_values[1:mid_point], na.rm = TRUE)
      late_mean <- mean(valid_values[(mid_point+1):n_points], na.rm = TRUE)
      early_late_diff <- late_mean - early_mean
      
      # Peak timing (when does maximum absolute value occur?)
      abs_values <- abs(valid_values)
      peak_time_index <- which.max(abs_values)
      peak_time <- valid_times[peak_time_index]
      peak_value <- valid_values[peak_time_index]
      
      # Monotonicity (how consistent is the trend?)
      differences <- diff(valid_values)
      prop_same_direction <- max(sum(differences > 0), sum(differences < 0)) / length(differences)
      
      # Pattern type classification
      pattern_type <- "stable"
      if(abs(slope) > 0.1) {
        if(slope > 0) pattern_type <- "increasing"
        else pattern_type <- "decreasing"
      }
      if(variance > 2 && prop_same_direction < 0.7) {
        pattern_type <- "biphasic"
      }
      
      features_list[[orf_id]] <- data.frame(
        orf_id = orf_id,
        slope = slope,
        mean_value = mean_value,
        variance = variance,
        range_val = range_val,
        early_late_diff = early_late_diff,
        peak_time = peak_time,
        peak_value = peak_value,
        monotonicity = prop_same_direction,
        pattern_type = pattern_type,
        stringsAsFactors = FALSE
      )
      
    }, error = function(e) {
      # Skip problematic ORFs
      NULL
    })
  }
  
  # Combine all features
  if(length(features_list) > 0) {
    features_df <- do.call(rbind, features_list)
    return(features_df)
  } else {
    return(NULL)
  }
}

# Extract features for clustering
cat("Extracting temporal trend features...\n")
temporal_features <- extract_temporal_features(temporal_log)

if(is.null(temporal_features)) {
  stop("Failed to extract temporal features")
}

cat("Extracted features for", nrow(temporal_features), "ORFs\n")

# Prepare clustering data (standardize features)
clustering_data <- temporal_features[, c("slope", "variance", "range_val", "early_late_diff", 
                                        "peak_time", "monotonicity")]
rownames(clustering_data) <- temporal_features$orf_id

# Standardize features for clustering
clustering_data_scaled <- scale(clustering_data)

# Remove any rows with NAs
valid_rows <- complete.cases(clustering_data_scaled)
clustering_data_final <- clustering_data_scaled[valid_rows, ]
temporal_features_final <- temporal_features[valid_rows, ]

cat("Final clustering data:", dim(clustering_data_final), "\n")

# ============================================================================
# PART 3: PATTERN-BASED CLUSTERING
# ============================================================================

cat("\n3. Performing pattern-based clustering...\n")

# Determine optimal number of clusters using elbow method
wss <- sapply(1:15, function(k) {
  kmeans(clustering_data_final, k, nstart = 10, iter.max = 100)$tot.withinss
})

# Find elbow point (simple method)
optimal_k <- which.min(diff(diff(wss))) + 1
optimal_k <- max(5, min(optimal_k, 12))  # Keep between 5-12 clusters

cat("Optimal number of clusters:", optimal_k, "\n")

# Perform k-means clustering
set.seed(42)  # For reproducibility
kmeans_result <- kmeans(clustering_data_final, centers = optimal_k, nstart = 25, iter.max = 100)

# Assign cluster labels
temporal_features_final$cluster <- kmeans_result$cluster

# ============================================================================
# PART 4: GENERATE ENHANCED HEATMAP WITH PATTERN CLUSTERING
# ============================================================================

cat("\n4. Generating enhanced pattern-clustered heatmap...\n")

# Get the temporal data for ORFs that have clustering assignments
clustered_orfs <- temporal_features_final$orf_id
clustered_temporal_data <- temporal_log[clustered_orfs, , drop = FALSE]

# Order by cluster for better visualization
cluster_order <- order(temporal_features_final$cluster)
ordered_orfs <- clustered_orfs[cluster_order]
ordered_temporal_data <- clustered_temporal_data[ordered_orfs, , drop = FALSE]
ordered_clusters <- temporal_features_final$cluster[cluster_order]

# Create cluster annotation
cluster_colors <- RColorBrewer::brewer.pal(min(optimal_k, 11), "Set3")
if(optimal_k > 11) {
  cluster_colors <- rainbow(optimal_k)
}

# Make sure factor levels match color names
cluster_levels <- sort(unique(ordered_clusters))
annotation_row <- data.frame(
  Pattern_Cluster = factor(ordered_clusters, levels = cluster_levels),
  row.names = ordered_orfs
)

annotation_colors <- list(
  Pattern_Cluster = setNames(cluster_colors[1:length(cluster_levels)], cluster_levels)
)

# Generate the enhanced heatmap
png("enhanced_pattern_clustered_heatmap.png", width = 1600, height = 2200, res = 150)

color_palette <- colorRampPalette(c("#2166AC", "#4393C3", "#92C5DE", "#D1E5F0", 
                                   "white", 
                                   "#FDBF6F", "#FF7F00", "#E31A1C", "#B2182B"))(100)

max_abs_val <- max(abs(ordered_temporal_data), na.rm = TRUE)
break_range <- min(max_abs_val, 4)
breaks <- seq(-break_range, break_range, length.out = 101)

pheatmap(
  ordered_temporal_data,
  cluster_rows = FALSE,  # Already ordered by pattern clusters
  cluster_cols = FALSE,
  scale = "none",
  color = color_palette,
  main = paste("Pattern-Clustered Temporal Analysis:", nrow(ordered_temporal_data), "Significant ORFs\n",
               "(", optimal_k, "pattern clusters, ordered by temporal trends)"),
  fontsize = 8,
  fontsize_row = 0,  # No row names due to size
  fontsize_col = 12,
  show_rownames = FALSE,
  breaks = breaks,
  na_col = "grey90",
  annotation_row = annotation_row,
  annotation_colors = annotation_colors,
  annotation_legend = TRUE,
  border_color = NA
)

dev.off()

cat("Generated enhanced pattern-clustered heatmap\n")

# ============================================================================
# PART 5: CLUSTER CHARACTERIZATION AND SUMMARY
# ============================================================================

cat("\n5. Characterizing pattern clusters...\n")

# Calculate cluster centroids and characteristics
cluster_summary <- temporal_features_final %>%
  group_by(cluster) %>%
  summarise(
    n_orfs = n(),
    mean_slope = mean(slope, na.rm = TRUE),
    mean_variance = mean(variance, na.rm = TRUE),
    mean_early_late_diff = mean(early_late_diff, na.rm = TRUE),
    mean_peak_time = mean(peak_time, na.rm = TRUE),
    dominant_pattern = names(sort(table(pattern_type), decreasing = TRUE))[1],
    .groups = "drop"
  )

cat("\nCluster characteristics:\n")
print(cluster_summary)

# Generate cluster summary heatmap
cluster_centroids <- matrix(NA, nrow = optimal_k, ncol = ncol(temporal_log))
rownames(cluster_centroids) <- paste0("Pattern_", 1:optimal_k)
colnames(cluster_centroids) <- colnames(temporal_log)

for(i in 1:optimal_k) {
  cluster_orfs <- temporal_features_final$orf_id[temporal_features_final$cluster == i]
  if(length(cluster_orfs) > 1) {
    cluster_centroids[i, ] <- colMeans(ordered_temporal_data[cluster_orfs, , drop = FALSE], na.rm = TRUE)
  } else {
    cluster_centroids[i, ] <- ordered_temporal_data[cluster_orfs, ]
  }
}

# Plot cluster centroids
png("pattern_cluster_centroids.png", width = 1200, height = 800, res = 150)

pheatmap(
  cluster_centroids,
  cluster_rows = FALSE,
  cluster_cols = FALSE,
  scale = "none",
  color = color_palette,
  main = paste("Pattern Cluster Centroids:", optimal_k, "Major Temporal Patterns\n(Centroids show representative pattern for each cluster)"),
  fontsize = 12,
  fontsize_row = 12,
  fontsize_col = 14,
  show_rownames = TRUE,
  breaks = breaks,
  na_col = "grey90"
)

dev.off()

# ============================================================================
# PART 6: SAVE RESULTS
# ============================================================================

cat("\n6. Saving enhanced clustering results...\n")

# Save cluster assignments
write.csv(temporal_features_final, "pattern_cluster_assignments.csv", row.names = FALSE)

# Save cluster summary
write.csv(cluster_summary, "pattern_cluster_summary.csv", row.names = FALSE)

# Save cluster centroids
write.csv(cluster_centroids, "pattern_cluster_centroids.csv")

# Save ordered temporal data
write.csv(ordered_temporal_data, "pattern_ordered_temporal_data.csv")

cat("\nEnhanced pattern-based clustering completed successfully!\n")
cat("Generated files:\n")
cat("- enhanced_pattern_clustered_heatmap.png: Pattern-clustered heatmap of all", nrow(ordered_temporal_data), "ORFs\n")
cat("- pattern_cluster_centroids.png: Visualization of", optimal_k, "major pattern types\n")
cat("- pattern_cluster_assignments.csv: Cluster assignments and features for each ORF\n")
cat("- pattern_cluster_summary.csv: Summary characteristics of each cluster\n")
cat("- pattern_cluster_centroids.csv: Centroid patterns for each cluster\n")
cat("- pattern_ordered_temporal_data.csv: Temporal data ordered by pattern clusters\n")

cat("\nCluster summary:\n")
for(i in 1:nrow(cluster_summary)) {
  cat("Pattern", i, ":", cluster_summary$n_orfs[i], "ORFs -", cluster_summary$dominant_pattern[i], 
      "trend (slope =", round(cluster_summary$mean_slope[i], 3), ")\n")
}

cat("\nAnalysis completed at:", format(Sys.time()), "\n")