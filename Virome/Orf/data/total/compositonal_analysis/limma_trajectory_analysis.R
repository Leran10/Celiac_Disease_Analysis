#!/usr/bin/env Rscript
# Limma Trajectory Analysis: CELIAC vs CONTROL Compositional Differences
# Focus on Dx.Status × onset_timeline_numeric interactions for derived ecological metrics
# Author: Generated by Claude
# Date: 2025-01-27

# Load required libraries
library(limma)
library(dplyr)
library(tidyr)
library(vegan)
library(ggplot2)
library(pheatmap)
library(RColorBrewer)

# Install and load ggrepel if not available
if (!requireNamespace("ggrepel", quietly = TRUE)) {
  install.packages("ggrepel")
}
library(ggrepel)

# Set working directory
setwd("/Users/leranwang/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data/total/compositonal_analysis")

# No need to create output directories - save in current directory

cat("=== LIMMA TRAJECTORY ANALYSIS: CELIAC vs CONTROL ===\n")
cat("Starting analysis at:", format(Sys.time()), "\n\n")

# ============================================================================
# PART 1: DATA LOADING AND PREPARATION
# ============================================================================

cat("1. Loading and preparing data...\n")

# Read data
orf_data <- read.csv("/Users/leranwang/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data/total/orf.abundance.table_0.75_prevFiltered_temporal_cleaned_noX.csv", row.names = 1)
metadata <- read.csv("/Users/leranwang/Handley Lab Dropbox/16S/Celiac/metadata/Updated_Metadata_with_Onset_Timeline.csv", row.names = 1)

# Clean ORF sample names (remove X prefix if present)
orf_samples <- colnames(orf_data)
orf_samples_clean <- gsub("^X", "", orf_samples)
colnames(orf_data) <- orf_samples_clean

# Match samples
common_samples <- intersect(orf_samples_clean, rownames(metadata))
orf_data_matched <- orf_data[, common_samples]
metadata_matched <- metadata[common_samples, ]

cat("Data dimensions:\n")
cat("  ORFs:", nrow(orf_data_matched), "\n")
cat("  Samples:", ncol(orf_data_matched), "\n")
cat("  Patients:", length(unique(metadata_matched$patientID)), "\n")

# Prepare metadata for limma
metadata_clean <- metadata_matched %>%
  select(patientID, Dx.Status, onset_timeline_numeric, Country, Sex, 
         Age.at.Gluten.Introduction..months., HLA.Category, 
         feeding_first_year, Delivery.Mode) %>%
  mutate(
    Dx.Status = factor(Dx.Status, levels = c("CONTROL", "CELIAC")),
    Country = factor(Country),
    Sex = factor(Sex),
    HLA.Category = factor(HLA.Category),
    feeding_first_year = factor(feeding_first_year),
    Delivery.Mode = factor(Delivery.Mode),
    patientID = factor(patientID)
  )

cat("Sample distribution:\n")
print(table(metadata_clean$Dx.Status))
cat("Country distribution:\n")
print(table(metadata_clean$Country))
cat("Onset timeline range:", range(metadata_clean$onset_timeline_numeric, na.rm = TRUE), "\n\n")

# ============================================================================
# PART 2: CALCULATE DERIVED ECOLOGICAL METRICS
# ============================================================================

cat("2. Calculating derived ecological metrics...\n")

# Transpose data for ecological calculations (samples as rows)
orf_data_t <- t(orf_data_matched)

# Calculate diversity metrics for each sample
calculate_diversity_metrics <- function(abundance_matrix) {
  
  # Ensure all values are numeric and non-negative
  abundance_matrix[abundance_matrix < 0] <- 0
  abundance_matrix[is.na(abundance_matrix)] <- 0
  
  diversity_metrics <- data.frame(
    sample_id = rownames(abundance_matrix),
    
    # Alpha diversity metrics
    richness = apply(abundance_matrix, 1, function(x) sum(x > 0)),
    shannon = diversity(abundance_matrix, index = "shannon"),
    simpson = diversity(abundance_matrix, index = "simpson"),
    evenness = diversity(abundance_matrix, index = "shannon") / log(apply(abundance_matrix, 1, function(x) sum(x > 0))),
    
    # Total viral load
    total_abundance = rowSums(abundance_matrix),
    
    # Dominance metrics
    dominance = apply(abundance_matrix, 1, function(x) {
      total <- sum(x)
      if(total > 0) max(x) / total else 0
    }),
    
    # Viral load variability
    viral_load_cv = apply(abundance_matrix, 1, function(x) {
      non_zero <- x[x > 0]
      if(length(non_zero) > 1) sd(non_zero) / mean(non_zero) else 0
    }),
    
    stringsAsFactors = FALSE
  )
  
  # Handle infinite/NaN values
  diversity_metrics$evenness[is.infinite(diversity_metrics$evenness) | is.nan(diversity_metrics$evenness)] <- 0
  diversity_metrics$viral_load_cv[is.infinite(diversity_metrics$viral_load_cv) | is.nan(diversity_metrics$viral_load_cv)] <- 0
  
  return(diversity_metrics)
}

# Calculate diversity metrics
diversity_data <- calculate_diversity_metrics(orf_data_t)

# Add metadata to diversity data
diversity_data_full <- merge(diversity_data, metadata_clean, by.x = "sample_id", by.y = 0)

cat("Diversity metrics calculated for", nrow(diversity_data), "samples\n")
cat("Diversity summary:\n")
print(summary(diversity_data[, c("richness", "shannon", "simpson", "evenness", "total_abundance")]))

# ============================================================================
# PART 3: CALCULATE SLOPE METRICS (INDIVIDUAL TRAJECTORIES)
# ============================================================================

cat("\n3. Calculating individual slope metrics...\n")

# Calculate slopes for each patient
calculate_slopes <- function(diversity_data_full) {
  
  slope_results <- data.frame()
  
  for(patient in unique(diversity_data_full$patientID)) {
    patient_data <- diversity_data_full[diversity_data_full$patientID == patient, ]
    patient_data <- patient_data[order(patient_data$onset_timeline_numeric), ]
    
    if(nrow(patient_data) < 3) {
      cat("  Skipping patient", patient, "- insufficient timepoints (", nrow(patient_data), ")\n")
      next
    }
    
    # Calculate slopes for each diversity metric
    metrics <- c("richness", "shannon", "simpson", "evenness", "total_abundance", "dominance", "viral_load_cv")
    slopes <- list()
    
    for(metric in metrics) {
      if(length(unique(patient_data[[metric]])) > 1) {
        tryCatch({
          lm_model <- lm(patient_data[[metric]] ~ patient_data$onset_timeline_numeric)
          slopes[[paste0("slope_", metric)]] <- coef(lm_model)[2]
        }, error = function(e) {
          slopes[[paste0("slope_", metric)]] <- 0
        })
      } else {
        slopes[[paste0("slope_", metric)]] <- 0
      }
    }
    
    # Get patient characteristics
    patient_info <- patient_data[1, ]
    slope_row <- cbind(patient_info[, c("patientID", "Dx.Status", "Country", "Sex", 
                                       "Age.at.Gluten.Introduction..months.", "HLA.Category", 
                                       "feeding_first_year", "Delivery.Mode")], 
                      as.data.frame(slopes))
    
    slope_results <- rbind(slope_results, slope_row)
  }
  
  return(slope_results)
}

slope_data <- calculate_slopes(diversity_data_full)
cat("Slope metrics calculated for", nrow(slope_data), "patients\n")

# ============================================================================
# PART 4: CALCULATE STABILITY METRICS (WITHIN-INDIVIDUAL VARIABILITY)
# ============================================================================

cat("\n4. Calculating stability metrics...\n")

# Calculate stability metrics for each patient
calculate_stability <- function(diversity_data_full) {
  
  stability_results <- data.frame()
  
  for(patient in unique(diversity_data_full$patientID)) {
    patient_data <- diversity_data_full[diversity_data_full$patientID == patient, ]
    
    if(nrow(patient_data) < 3) {
      next
    }
    
    # Calculate stability metrics (coefficient of variation for each diversity metric)
    metrics <- c("richness", "shannon", "simpson", "evenness", "total_abundance", "dominance")
    stability <- list()
    
    for(metric in metrics) {
      mean_val <- mean(patient_data[[metric]], na.rm = TRUE)
      sd_val <- sd(patient_data[[metric]], na.rm = TRUE)
      stability[[paste0("stability_", metric)]] <- if(mean_val > 0) 1 / (sd_val / mean_val) else 0
    }
    
    # Get patient characteristics
    patient_info <- patient_data[1, ]
    stability_row <- cbind(patient_info[, c("patientID", "Dx.Status", "Country", "Sex", 
                                           "Age.at.Gluten.Introduction..months.", "HLA.Category", 
                                           "feeding_first_year", "Delivery.Mode")], 
                          as.data.frame(stability))
    
    stability_results <- rbind(stability_results, stability_row)
  }
  
  return(stability_results)
}

stability_data <- calculate_stability(diversity_data_full)
cat("Stability metrics calculated for", nrow(stability_data), "patients\n")

# ============================================================================
# PART 5: CALCULATE TURNOVER METRICS (COMMUNITY COMPOSITION CHANGES)
# ============================================================================

cat("\n5. Calculating turnover metrics...\n")

# Calculate turnover metrics for each patient
calculate_turnover <- function(orf_data_matched, metadata_clean) {
  
  turnover_results <- data.frame()
  
  for(patient in unique(metadata_clean$patientID)) {
    patient_samples <- rownames(metadata_clean)[metadata_clean$patientID == patient]
    patient_samples <- patient_samples[patient_samples %in% colnames(orf_data_matched)]
    
    if(length(patient_samples) < 3) {
      next
    }
    
    # Order samples by onset timeline
    patient_meta <- metadata_clean[patient_samples, ]
    patient_meta <- patient_meta[order(patient_meta$onset_timeline_numeric), ]
    ordered_samples <- rownames(patient_meta)
    
    # Calculate turnover between consecutive timepoints
    turnovers <- c()
    for(i in 2:length(ordered_samples)) {
      sample1 <- orf_data_matched[, ordered_samples[i-1]]
      sample2 <- orf_data_matched[, ordered_samples[i]]
      
      # Calculate Bray-Curtis dissimilarity
      bc_dist <- vegdist(rbind(sample1, sample2), method = "bray")[1]
      turnovers <- c(turnovers, bc_dist)
    }
    
    # Calculate mean turnover rate
    mean_turnover <- mean(turnovers, na.rm = TRUE)
    
    # Get patient characteristics
    patient_info <- patient_meta[1, ]
    turnover_row <- data.frame(
      patientID = patient_info$patientID,
      Dx.Status = patient_info$Dx.Status,
      Country = patient_info$Country,
      Sex = patient_info$Sex,
      Age.at.Gluten.Introduction..months. = patient_info$Age.at.Gluten.Introduction..months.,
      HLA.Category = patient_info$HLA.Category,
      feeding_first_year = patient_info$feeding_first_year,
      Delivery.Mode = patient_info$Delivery.Mode,
      turnover_rate = mean_turnover
    )
    
    turnover_results <- rbind(turnover_results, turnover_row)
  }
  
  return(turnover_results)
}

turnover_data <- calculate_turnover(orf_data_matched, metadata_clean)
cat("Turnover metrics calculated for", nrow(turnover_data), "patients\n")

# ============================================================================
# PART 6: APPLY LIMMA MODEL TO DIVERSITY METRICS
# ============================================================================

cat("\n6. Applying limma model to diversity metrics...\n")

# Apply limma to diversity metrics
apply_limma_to_diversity <- function(diversity_data_full) {
  
  # Prepare design matrix
  design <- model.matrix(~ Dx.Status * onset_timeline_numeric + Country + Sex + 
                        Age.at.Gluten.Introduction..months. + HLA.Category + 
                        feeding_first_year + Delivery.Mode, 
                        data = diversity_data_full)
  
  # Prepare response matrix (diversity metrics)
  diversity_metrics <- c("richness", "shannon", "simpson", "evenness", "total_abundance", "dominance", "viral_load_cv")
  response_matrix <- t(diversity_data_full[, diversity_metrics])
  
  # Create correlation matrix for blocking by patient
  patient_factor <- factor(diversity_data_full$patientID)
  correlation <- duplicateCorrelation(response_matrix, design, block = patient_factor)
  
  # Fit limma model
  fit <- lmFit(response_matrix, design, block = patient_factor, correlation = correlation$consensus)
  fit <- eBayes(fit)
  
  # Extract results for interaction term
  interaction_coef <- grep("Dx.StatusCELIAC:onset_timeline_numeric", colnames(design), value = TRUE)
  
  results <- topTable(fit, coef = interaction_coef, number = Inf, sort.by = "P")
  results$metric <- rownames(results)
  
  return(list(fit = fit, results = results, design = design))
}

diversity_limma <- apply_limma_to_diversity(diversity_data_full)

cat("Limma analysis completed for diversity metrics\n")
cat("Interaction results:\n")
print(diversity_limma$results)

# ============================================================================
# PART 7: APPLY LIMMA MODEL TO SLOPE METRICS
# ============================================================================

cat("\n7. Applying limma model to slope metrics...\n")

# Apply limma to slope metrics (one value per patient)
apply_limma_to_slopes <- function(slope_data) {
  
  # Prepare design matrix
  design <- model.matrix(~ Dx.Status + Country + Sex + 
                        Age.at.Gluten.Introduction..months. + HLA.Category + 
                        feeding_first_year + Delivery.Mode, 
                        data = slope_data)
  
  # Prepare response matrix (slope metrics)
  slope_metrics <- grep("^slope_", colnames(slope_data), value = TRUE)
  response_matrix <- t(slope_data[, slope_metrics])
  
  # Fit limma model
  fit <- lmFit(response_matrix, design)
  fit <- eBayes(fit)
  
  # Extract results for Dx.Status effect
  results <- topTable(fit, coef = "Dx.StatusCELIAC", number = Inf, sort.by = "P")
  results$metric <- rownames(results)
  
  return(list(fit = fit, results = results, design = design))
}

slope_limma <- apply_limma_to_slopes(slope_data)

cat("Limma analysis completed for slope metrics\n")
cat("Dx.Status results:\n")
print(slope_limma$results)

# ============================================================================
# PART 8: APPLY LIMMA MODEL TO STABILITY METRICS
# ============================================================================

cat("\n8. Applying limma model to stability metrics...\n")

# Apply limma to stability metrics
apply_limma_to_stability <- function(stability_data) {
  
  # Prepare design matrix
  design <- model.matrix(~ Dx.Status + Country + Sex + 
                        Age.at.Gluten.Introduction..months. + HLA.Category + 
                        feeding_first_year + Delivery.Mode, 
                        data = stability_data)
  
  # Prepare response matrix (stability metrics)
  stability_metrics <- grep("^stability_", colnames(stability_data), value = TRUE)
  response_matrix <- t(stability_data[, stability_metrics])
  
  # Fit limma model
  fit <- lmFit(response_matrix, design)
  fit <- eBayes(fit)
  
  # Extract results for Dx.Status effect
  results <- topTable(fit, coef = "Dx.StatusCELIAC", number = Inf, sort.by = "P")
  results$metric <- rownames(results)
  
  return(list(fit = fit, results = results, design = design))
}

stability_limma <- apply_limma_to_stability(stability_data)

cat("Limma analysis completed for stability metrics\n")
cat("Dx.Status results:\n")
print(stability_limma$results)

# ============================================================================
# PART 9: APPLY LIMMA MODEL TO TURNOVER METRICS
# ============================================================================

cat("\n9. Applying limma model to turnover metrics...\n")

# Apply limma to turnover metrics
apply_limma_to_turnover <- function(turnover_data) {
  
  # Prepare design matrix
  design <- model.matrix(~ Dx.Status + Country + Sex + 
                        Age.at.Gluten.Introduction..months. + HLA.Category + 
                        feeding_first_year + Delivery.Mode, 
                        data = turnover_data)
  
  # Prepare response matrix (turnover metrics)
  response_matrix <- matrix(turnover_data$turnover_rate, nrow = 1)
  rownames(response_matrix) <- "turnover_rate"
  
  # Fit limma model
  fit <- lmFit(response_matrix, design)
  fit <- eBayes(fit)
  
  # Extract results for Dx.Status effect
  results <- topTable(fit, coef = "Dx.StatusCELIAC", number = Inf, sort.by = "P")
  results$metric <- rownames(results)
  
  return(list(fit = fit, results = results, design = design))
}

turnover_limma <- apply_limma_to_turnover(turnover_data)

cat("Limma analysis completed for turnover metrics\n")
cat("Dx.Status results:\n")
print(turnover_limma$results)

# ============================================================================
# PART 10: SAVE RESULTS
# ============================================================================

cat("\n10. Saving results...\n")

# Save diversity trajectory results
write.csv(diversity_limma$results, "diversity_trajectory_results.csv", row.names = FALSE)
write.csv(diversity_data_full, "diversity_data_full.csv", row.names = FALSE)

# Save slope analysis results
write.csv(slope_limma$results, "slope_analysis_results.csv", row.names = FALSE)
write.csv(slope_data, "slope_data.csv", row.names = FALSE)

# Save stability analysis results
write.csv(stability_limma$results, "stability_analysis_results.csv", row.names = FALSE)
write.csv(stability_data, "stability_data.csv", row.names = FALSE)

# Save turnover analysis results
write.csv(turnover_limma$results, "turnover_analysis_results.csv", row.names = FALSE)
write.csv(turnover_data, "turnover_data.csv", row.names = FALSE)

# Save comprehensive summary
summary_results <- rbind(
  data.frame(analysis = "Diversity_Trajectory", diversity_limma$results),
  data.frame(analysis = "Slope_Analysis", slope_limma$results),
  data.frame(analysis = "Stability_Analysis", stability_limma$results),
  data.frame(analysis = "Turnover_Analysis", turnover_limma$results)
)

write.csv(summary_results, "comprehensive_results_summary.csv", row.names = FALSE)

# ============================================================================
# PART 11: GENERATE COMPREHENSIVE PLOTS
# ============================================================================

cat("\n11. Generating comprehensive plots...\n")

# Plot 1: Diversity trajectory heatmap
cat("Creating diversity trajectory heatmap...\n")
png("diversity_trajectory_heatmap.png", width = 1200, height = 800, res = 150)
pheatmap(
  diversity_limma$results[, c("logFC", "AveExpr", "t", "P.Value", "adj.P.Val")],
  cluster_rows = TRUE,
  cluster_cols = FALSE,
  scale = "column",
  color = colorRampPalette(c("blue", "white", "red"))(50),
  main = "Diversity Trajectory Analysis Results\n(Dx.Status × onset_timeline_numeric)",
  fontsize = 10,
  cellwidth = 80,
  cellheight = 20
)
dev.off()

# Plot 2: Slope analysis results
cat("Creating slope analysis plots...\n")
slope_results_clean <- slope_limma$results
slope_results_clean$metric_clean <- gsub("^slope_", "", slope_results_clean$metric)
slope_results_clean$significant <- slope_results_clean$adj.P.Val < 0.05

png("slope_analysis_results.png", width = 1200, height = 800, res = 150)
p1 <- ggplot(slope_results_clean, aes(x = reorder(metric_clean, -logFC), y = logFC, 
                                     fill = significant)) +
  geom_bar(stat = "identity", alpha = 0.7) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  scale_fill_manual(values = c("FALSE" = "gray", "TRUE" = "red")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Slope Analysis: CELIAC vs CONTROL",
       subtitle = "Positive = CELIAC higher slope",
       x = "Diversity Metric", y = "Log Fold Change",
       fill = "Significant\n(adj.p < 0.05)")
print(p1)
dev.off()

# Plot 3: Volcano plot for slope analysis
cat("Creating volcano plot...\n")
png("slope_volcano_plot.png", width = 1000, height = 800, res = 150)
p2 <- ggplot(slope_results_clean, aes(x = logFC, y = -log10(P.Value), 
                                     color = significant, label = metric_clean)) +
  geom_point(size = 3, alpha = 0.7) +
  geom_vline(xintercept = 0, linetype = "dashed", color = "gray") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "gray") +
  scale_color_manual(values = c("FALSE" = "gray", "TRUE" = "red")) +
  theme_minimal() +
  labs(title = "Volcano Plot: Slope Analysis",
       subtitle = "CELIAC vs CONTROL trajectory slopes",
       x = "Log Fold Change", y = "-log10(P-value)",
       color = "Significant\n(p < 0.05)")
if(any(slope_results_clean$significant)) {
  p2 <- p2 + ggrepel::geom_text_repel(
    data = slope_results_clean[slope_results_clean$significant, ],
    size = 3, max.overlaps = 10
  )
}
print(p2)
dev.off()

# Plot 4: Diversity trajectories by group
cat("Creating diversity trajectories by group...\n")
diversity_summary <- diversity_data_full %>%
  group_by(Dx.Status, onset_timeline_numeric) %>%
  summarise(
    mean_richness = mean(richness, na.rm = TRUE),
    se_richness = sd(richness, na.rm = TRUE) / sqrt(n()),
    mean_shannon = mean(shannon, na.rm = TRUE),
    se_shannon = sd(shannon, na.rm = TRUE) / sqrt(n()),
    .groups = "drop"
  )

png("diversity_trajectories_by_group.png", width = 1200, height = 800, res = 150)
p3 <- ggplot(diversity_summary, aes(x = onset_timeline_numeric, color = Dx.Status, fill = Dx.Status)) +
  geom_point(aes(y = mean_shannon), size = 2) +
  geom_line(aes(y = mean_shannon), size = 1) +
  geom_ribbon(aes(ymin = mean_shannon - se_shannon, ymax = mean_shannon + se_shannon), 
              alpha = 0.2, color = NA) +
  scale_color_manual(values = c("CONTROL" = "blue", "CELIAC" = "red")) +
  scale_fill_manual(values = c("CONTROL" = "blue", "CELIAC" = "red")) +
  theme_minimal() +
  labs(title = "Shannon Diversity Trajectories by Disease Status",
       subtitle = "Mean ± SE trajectories over time to onset",
       x = "Time to Onset (months)", y = "Shannon Diversity",
       color = "Disease Status", fill = "Disease Status")
print(p3)
dev.off()

# Plot 5: Individual patient trajectories (subset)
cat("Creating individual patient trajectories...\n")
top_patients <- diversity_data_full %>%
  group_by(patientID) %>%
  summarise(n_timepoints = n(), .groups = "drop") %>%
  arrange(desc(n_timepoints)) %>%
  head(12) %>%
  pull(patientID)

diversity_subset <- diversity_data_full %>%
  filter(patientID %in% top_patients)

png("individual_patient_trajectories.png", width = 1400, height = 1000, res = 150)
p4 <- ggplot(diversity_subset, aes(x = onset_timeline_numeric, y = shannon, color = Dx.Status)) +
  geom_point(alpha = 0.7) +
  geom_line(alpha = 0.7) +
  facet_wrap(~ patientID, scales = "free_y", ncol = 4) +
  scale_color_manual(values = c("CONTROL" = "blue", "CELIAC" = "red")) +
  theme_minimal() +
  theme(strip.text = element_text(size = 8)) +
  labs(title = "Individual Patient Shannon Diversity Trajectories",
       subtitle = "Top 12 patients by number of timepoints",
       x = "Time to Onset (months)", y = "Shannon Diversity",
       color = "Disease Status")
print(p4)
dev.off()

# Plot 6: Stability analysis results
cat("Creating stability analysis plots...\n")
stability_results_clean <- stability_limma$results
stability_results_clean$metric_clean <- gsub("^stability_", "", stability_results_clean$metric)
stability_results_clean$significant <- stability_results_clean$adj.P.Val < 0.05

png("stability_analysis_results.png", width = 1200, height = 800, res = 150)
p5 <- ggplot(stability_results_clean, aes(x = reorder(metric_clean, -logFC), y = logFC, 
                                         fill = significant)) +
  geom_bar(stat = "identity", alpha = 0.7) +
  geom_hline(yintercept = 0, linetype = "dashed", color = "red") +
  scale_fill_manual(values = c("FALSE" = "gray", "TRUE" = "red")) +
  theme_minimal() +
  theme(axis.text.x = element_text(angle = 45, hjust = 1)) +
  labs(title = "Stability Analysis: CELIAC vs CONTROL",
       subtitle = "Negative = CELIAC less stable (higher variability)",
       x = "Diversity Metric", y = "Log Fold Change",
       fill = "Significant\n(adj.p < 0.05)")
print(p5)
dev.off()

# Plot 7: Correlation heatmap of all metrics
cat("Creating correlation heatmap...\n")
# Prepare data for correlation analysis
slope_metrics <- slope_data %>%
  select(patientID, starts_with("slope_")) %>%
  na.omit()

stability_metrics <- stability_data %>%
  select(patientID, starts_with("stability_")) %>%
  na.omit()

turnover_metrics <- turnover_data %>%
  select(patientID, turnover_rate) %>%
  na.omit()

# Merge all metrics
all_metrics <- slope_metrics %>%
  full_join(stability_metrics, by = "patientID") %>%
  full_join(turnover_metrics, by = "patientID") %>%
  select(-patientID) %>%
  na.omit()

if(ncol(all_metrics) > 1) {
  cor_matrix <- cor(all_metrics, use = "complete.obs")
  
  png("trajectory_metrics_correlation.png", width = 1200, height = 1000, res = 150)
  pheatmap(
    cor_matrix,
    cluster_rows = TRUE,
    cluster_cols = TRUE,
    scale = "none",
    color = colorRampPalette(c("blue", "white", "red"))(50),
    main = "Correlation Matrix of Trajectory Metrics",
    fontsize = 8,
    cellwidth = 25,
    cellheight = 25,
    display_numbers = TRUE,
    number_format = "%.2f"
  )
  dev.off()
}

# Plot 8: Summary statistics plot
cat("Creating summary statistics plot...\n")
png("analysis_summary_statistics.png", width = 1400, height = 1000, res = 150)
par(mfrow = c(2, 2))

# Sample distribution
barplot(table(metadata_clean$Dx.Status), 
        main = "Sample Distribution", 
        col = c("blue", "red"),
        ylab = "Number of Samples")

# Country distribution
barplot(table(metadata_clean$Country), 
        main = "Country Distribution", 
        col = rainbow(length(unique(metadata_clean$Country))),
        ylab = "Number of Samples")

# Timeline distribution
hist(metadata_clean$onset_timeline_numeric, 
     main = "Timeline Distribution", 
     xlab = "Months to Onset",
     col = "lightblue",
     breaks = 20)

# Diversity distribution
boxplot(richness ~ Dx.Status, data = diversity_data_full,
        main = "Richness by Disease Status",
        col = c("blue", "red"),
        ylab = "Viral Richness")

dev.off()

cat("\nPlots completed successfully!\n")
cat("Generated plots:\n")
cat("- diversity_trajectory_heatmap.png: Heatmap of trajectory analysis results\n")
cat("- slope_analysis_results.png: Bar plot of slope differences\n")
cat("- slope_volcano_plot.png: Volcano plot of slope analysis\n")
cat("- diversity_trajectories_by_group.png: Mean trajectories by disease status\n")
cat("- individual_patient_trajectories.png: Individual patient trajectories\n")
cat("- stability_analysis_results.png: Stability analysis results\n")
cat("- trajectory_metrics_correlation.png: Correlation heatmap of all metrics\n")
cat("- analysis_summary_statistics.png: Summary statistics plots\n")

cat("\nAnalysis completed successfully!\n")
cat("Results saved in current directory\n")
cat("Key files generated:\n")
cat("- diversity_trajectory_results.csv: Dx.Status × onset_timeline_numeric interactions\n")
cat("- slope_analysis_results.csv: Individual trajectory slope differences\n")
cat("- stability_analysis_results.csv: Within-individual stability differences\n")
cat("- turnover_analysis_results.csv: Community turnover differences\n")
cat("- comprehensive_results_summary.csv: All results combined\n")

cat("\nAnalysis completed at:", format(Sys.time()), "\n")