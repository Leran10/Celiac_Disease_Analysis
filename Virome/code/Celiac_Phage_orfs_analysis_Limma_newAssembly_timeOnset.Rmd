---
title: "Celiac_Phage_orfs_analysis_Limma_newAssembly_timeOnset"
output: html_document
date: "2025-07-06"
editor_options: 
  chunk_output_type: console
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
library(data.table);packageVersion("data.table")
library(tidyverse);packageVersion("tidyverse")
library(ggplot2);packageVersion("ggplot2")
library(broom);packageVersion("broom")
library(vroom);packageVersion("vroom")
library(limma);packageVersion("limma")
library(edgeR);packageVersion("edgeR")
library(pheatmap);packageVersion("pheatmap")
library(survival);packageVersion("survival")
```



# functions
```{r}

filter_and_save_wide_data <- function(genesCoverm, 
                                      covered_fraction_threshold = 0.75, 
                                      output_path = "~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/orf/data_correct/total/") {
  
  # Set column names to match the original structure
  colnames(genesCoverm) <- c("sampleID", "ORFID", "RPKM", "ReadCount", "Variance", "Mean", "covered_fraction", "covered_bases")
  
  # Apply coverage filter
  genesCoverm2 <- genesCoverm %>%
    mutate(
      ReadCount_modified = ifelse(covered_fraction >= covered_fraction_threshold, ReadCount, 0),
      Changed = ifelse(ReadCount != ReadCount_modified, 1, 0)
    ) %>%
    mutate(ReadCount = ReadCount_modified) %>%
    select(-ReadCount_modified)
  
  # Count the number of changes
  num_changes <- sum(genesCoverm2$Changed)
  print(paste("Number of changes:", num_changes))
  
  # Convert to wide format
  wide_rpkm_genes <- reshape2::dcast(genesCoverm2, ORFID ~ sampleID, value.var = "ReadCount")
  colnames(wide_rpkm_genes) <- gsub("_stats", "", colnames(wide_rpkm_genes))
  
  # Filter out rows with all zeroes
  filtered_wide_rpkm_genes <- wide_rpkm_genes %>%
    filter(rowSums(across(where(is.numeric))) != 0)
  
  # Save the filtered wide format data
  rds_filename_wide <- paste0("wide_rpkm_genes_", covered_fraction_threshold * 100, "Cov.rds")
  
  saveRDS(filtered_wide_rpkm_genes, file = file.path(output_path, rds_filename_wide))
  
  return(filtered_wide_rpkm_genes)
}



```


# load metadata
```{r}

metadata <- read.csv("~/Handley Lab Dropbox/16S/Celiac/metadata/Updated_Metadata_with_Onset_Timeline.csv") %>%
            select(-Sample.Name.External.ID) %>%
            select(-Classification) %>%
            column_to_rownames("X")

dim(metadata)
# 335  24

```


# prepare orf count table with 75% mapping filtering
```{r}

orf <- vroom("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/Orf_Coverm_concatenated.txt",col_names = FALSE)
# we have 340 samples and 46594 orfs in total after phage pipeline


filter_and_save_wide_data(orf, 
                          covered_fraction_threshold = 0.75, 
                          output_path = "~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/")
# Number of changes: 185957

orf.processed <- readRDS("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/wide_rpkm_genes_75Cov.rds") %>%
                 column_to_rownames("ORFID")

# then let's check colSums and ensure there is no sample have all 0s across orfs
sample_all_0 <- names(colSums(orf.processed)[colSums(orf.processed) == 0])
# "NovaSeq_N978_I13149_39572_Celiac_Leonard_Stool_01_GEMM_093_24M"       "NovaSeq_N978_I13150_39573_Celiac_Leonard_Stool_01_GEMM_093_30M"      
# "NovaSeq_N978_I13151_39574_Celiac_Leonard_Stool_01_GEMM_093_36M"       "NovaSeq_N978_I13152_39575_Celiac_Leonard_Stool_01_GEMM_093_48M"      
# "NovaSeq_N982_I13323_39837_Celiac_Leonard_Stool_02_GEMM_077_12M"       "NovaSeq_N983_I13417_39799_Leonard_Human_stool_Celiac_02_GEMM_006_60M"


# let's remove the 6 0 counts samples
orf.processed <- orf.processed %>%
                    select(-all_of(sample_all_0))
dim(orf.processed)
# 46102   334


# here we found two duplicated samples:
# "NovaSeq_N978_I13164_39587_Celiac_Leonard_Stool_01_GEMM_106_12M_stats" and  "NovaSeq_N983_I13413_39587_Celiac_Leonard_Stool_01_GEMM_106_12M_stats"
# after checking with my note, the N983 01_GEMM_106_12M sample should actually be water
orf.processed <- orf.processed %>%
                 select(-NovaSeq_N983_I13413_39587_Celiac_Leonard_Stool_01_GEMM_106_12M)
# 46102   333

orf.count <- orf.processed

colnames(orf.count) <- gsub("NovaSeq_N966_|NovaSeq_N978_|NovaSeq_N979_|NovaSeq_N980_|NovaSeq_N981_|NovaSeq_N982_|NovaSeq_N983_|_stats","",colnames(orf.count))

colnames(orf.count) <- str_replace_all(colnames(orf.count),"Leonard_Human_stool_Celiac","Celiac_Leonard_Stool")
colnames(orf.count) <- sapply(strsplit(colnames(orf.count),"_Stool_|_Stool_Celiac_"),"[",2)
colnames(orf.count) <- ifelse(colnames(orf.count) %like% "_6Y",gsub("_6Y","_72M",colnames(orf.count)),
                                           ifelse(colnames(orf.count) %like% "_7Y",gsub("_7Y","_84M",colnames(orf.count)),colnames(orf.count)))

orf.count.table_0.75 <- t(orf.count) 
# 333 46102


#######################################################################
# no 3% pravelance filtering (still need to remove the 0 counts orfs) #
#######################################################################


#-------------------------------------------prepare abundance table----------------------------------------------------#

orf.abundance.table_0.75 <- merge(metadata,orf.count.table_0.75,by = 0) %>% # 329 samples left
                              filter(feeding_first_year != "Unknown") %>%  # 312 samples left
                              filter(Age.at.Gluten.Introduction..months. != "Unknown") # 308 sample left
# 308 samples x  46127 metadata+orfs

all_0_contigs <- names(colSums(orf.abundance.table_0.75[25:46127])[colSums(orf.abundance.table_0.75[25:46127]) == 0])
# 837 contigs become 0 through all samples after the 25 samples were removed from the above step
# so we need to remove those contigs

orf.abundance.table_0.75 <- orf.abundance.table_0.75 %>%
                            select(-all_of(all_0_contigs))
# 308 samples x 45290 metadata+orfs
# 45290 orfs


#-------------------------------------------prepare PA table------------------------------------------------------#

orf.PA.table_0.75 <- orf.abundance.table_0.75 %>%
                         mutate(across(25:45290, ~ as.integer(. != 0)))

dim(orf.PA.table_0.75)
# final numbers: 308 samples x 45290 metadata+orfs
# final numbers: 45290 orfs


###########################
# 3% pravelance filtering #
###########################

PA.orf.check_0.75 <- orf.PA.table_0.75 %>% 
                   dplyr::select(Row.names,starts_with("virus_"),starts_with("edge")) %>% 
                   pivot_longer(cols = c(starts_with("virus_"),starts_with("edge")),names_to = "orf",values_to = "PA") %>% 
                   group_by(orf) %>% 
                   mutate(total_PA = sum(PA)) %>%
                   distinct(orf,total_PA) %>%
                   arrange(-total_PA)
# 45265     2

# write.csv(PA.orf.check_0.75,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/PA.orf.check_0.75.csv")


# find viruses that exist in only 3% of the samples (308 * 0.03 = 9.24)
non_rare_orf_0.75_0.03 <- PA.orf.check_0.75 %>% filter(total_PA >=9) %>% pull(orf)
length(non_rare_orf_0.75_0.03)
# 2967 orfs passed the 3% prev filtering


# -------------------------------------prevelence filtering on abundance table------------------------------------------#

orf.abundance.table_0.75_prevFiltered <- orf.abundance.table_0.75 %>% dplyr::select(c(1:25,all_of(non_rare_orf_0.75_0.03)))
dim(orf.abundance.table_0.75_prevFiltered)
# 308 samples x 2992 metadata+orfs
# 2967 orfs

# chck if there are samples become 0 counts after 3% prev filtering
check <- orf.abundance.table_0.75_prevFiltered %>% select(c("Row.names",26:2992)) %>% column_to_rownames("Row.names")
names(colSums(check)[colSums(check) < 9])
# character(0)
names(rowSums(check)[rowSums(check) == 0])
# "01_GEMM_154_30M" "02_GEMM_021_36M"

# we will have to remove sample 02_GEMM_021_36M because it becomes 0 counts at this step
orf.abundance.table_0.75_prevFiltered <- orf.abundance.table_0.75_prevFiltered %>%
                                         filter(!Row.names %in% c("01_GEMM_154_30M","02_GEMM_021_36M"))
dim(orf.abundance.table_0.75_prevFiltered)
# final number: 306 samples x 2992 metadata+orfs
# 2967 orfs


# -------------------------------------prevelence filtering on PA table------------------------------------------#

# prevelence filtering on PA table 
orf.PA.table_0.75_prevFiltered <- orf.abundance.table_0.75_prevFiltered %>%
                                   mutate(across(26:2992, ~ as.integer(. != 0)))

# final numbers: 306 samples x 2992 metadata+orfs
# 2967 orfs


##################################################
# 3% pravelance filtering +  temporal filtering. #
##################################################

# Criteria:
# 1. A virus must be detected (i.e. non-zero abundance) in at least 3 different timepoints (e.g. t0, t0-6, t0-12, etc.) to be kept.
# why: Viruses that appear in only 1 or 2 timepoints may just be noise or outliers — not reliable signals for modeling temporal trajectories.

# 2. Within each of those time bins, the virus must be non-zero in at least 2 samples.
# why: If a virus appears in only one person at one timepoint, it's likely due to technical noise or rare biological events — not something generalizable across a group.



filter_by_temporal_support <- function(abundance_data, metadata,
                                       min_time_bins = 3,
                                       min_nonzero_per_bin = 2,
                                       time_var = "onset_timeline_numeric") {
  # Ensure abundance_data columns match metadata row order
  if (!all(colnames(abundance_data) == rownames(metadata))) {
    stop("Sample names in abundance_data and metadata must match and be in the same order.")
  }

  # Initialize vector to store retained gene names
  retained_genes <- c()


  # Loop through each gene
  for (gene in rownames(abundance_data)) {
    gene_counts <- abundance_data[gene, ]
    timepoints <- metadata[[time_var]]

    # Count non-zero samples per time bin
    counts_per_bin <- tapply(gene_counts > 0, timepoints, sum)


    # Count how many time bins have ≥ X non-zero samples
    num_valid_bins <- sum(counts_per_bin >= min_nonzero_per_bin, na.rm = TRUE)

    if (num_valid_bins >= min_time_bins) {
      retained_genes <- c(retained_genes, gene)
    }
  }
    
  # Return filtered abundance table
  abundance_data[retained_genes, , drop = FALSE]
}


# prepare clean metadata
metadata.clean <- orf.abundance.table_0.75_prevFiltered[1:25] %>%
                  data.frame(.) %>%
                  column_to_rownames("Row.names")
# 306  24


orf.abundance.clean <- orf.abundance.table_0.75_prevFiltered %>%
                           select(c("Row.names",26:2992)) %>%
                           filter(Row.names %in% rownames(metadata.clean)) %>%
                           column_to_rownames("Row.names") %>% 
                           t(.) %>%
                           data.frame(.)
colnames(orf.abundance.clean) <- gsub("X","",colnames(orf.abundance.clean))
# 2967  306


orf.abundance.table_0.75_prevFiltered_temporal <- merge(metadata.clean,t(filter_by_temporal_support(orf.abundance.clean,metadata.clean)),by= 0) %>%
                                                  select(-RunNumber)

# 306 2084

# chck if there are samples become 0 counts after 3% prev filtering
check <- orf.abundance.table_0.75_prevFiltered_temporal %>% select(c("Row.names",26:2084)) %>% column_to_rownames("Row.names")
names(colSums(check)[colSums(check) < 9])
# character(0)
names(rowSums(check)[rowSums(check) == 0])
# "01_GEMM_057_60M" "02_GEMM_010_24M" "02_GEMM_030_12M" "02_GEMM_031_12M" "02_GEMM_038_12M" "02_GEMM_041_12M" "02_GEMM_228_12M"


# we will have to remove sample "01_GEMM_057_60M" "02_GEMM_010_24M" "02_GEMM_030_12M" "02_GEMM_031_12M" "02_GEMM_038_12M" "02_GEMM_041_12M" "02_GEMM_228_12M" because it becomes 0 counts at this step
orf.abundance.table_0.75_prevFiltered_temporal <- orf.abundance.table_0.75_prevFiltered_temporal %>%
                                         filter(!Row.names %in% c("01_GEMM_057_60M","02_GEMM_010_24M","02_GEMM_030_12M","02_GEMM_031_12M","02_GEMM_038_12M","02_GEMM_041_12M","02_GEMM_228_12M"))
# final number: 299 samples x 2084 metadata+orfs
# 2060 orfs

```


# prepare orf count table with 75% mapping filtering by country
```{r}

US.orf <- orf %>%
             filter(X1 %like% "_01_GEMM_")
# 208 samples x 46594 orfs

Italy.orf <- orf %>%
             filter(X1 %like% "_02_GEMM_")
# 132 samples x 46594 orfs


filter_and_save_wide_data(US.orf, 
                          covered_fraction_threshold = 0.75, 
                          output_path = "~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/US/")
# "Number of changes: 132493"


filter_and_save_wide_data(Italy.orf, 
                          covered_fraction_threshold = 0.75, 
                          output_path = "~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/Italy/")
# "Number of changes: 53464"


# here we found two duplicated samples:
# "NovaSeq_N978_I13164_39587_Celiac_Leonard_Stool_01_GEMM_106_12M_stats" and  "NovaSeq_N983_I13413_39587_Celiac_Leonard_Stool_01_GEMM_106_12M_stats"
# after checking with my note, the N983 01_GEMM_106_12M sample should actually be water
# so we will just remove it
US_orf.processed <- readRDS("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/US/wide_rpkm_genes_75Cov.rds") %>%
                   column_to_rownames("ORFID") %>%
                   select(-NovaSeq_N983_I13413_39587_Celiac_Leonard_Stool_01_GEMM_106_12M)


US_sample_all_0 <- names(colSums(US_orf.processed)[colSums(US_orf.processed) == 0])
#"NovaSeq_N978_I13149_39572_Celiac_Leonard_Stool_01_GEMM_093_24M" "NovaSeq_N978_I13150_39573_Celiac_Leonard_Stool_01_GEMM_093_30M"
#"NovaSeq_N978_I13151_39574_Celiac_Leonard_Stool_01_GEMM_093_36M" "NovaSeq_N978_I13152_39575_Celiac_Leonard_Stool_01_GEMM_093_48M"


US.orf.count <- US_orf.processed %>%
                   select(-all_of(c(US_sample_all_0))) 
# 35430   203

colnames(US.orf.count) <- gsub("NovaSeq_N966_|NovaSeq_N978_|NovaSeq_N979_|NovaSeq_N980_|NovaSeq_N981_|NovaSeq_N982_|NovaSeq_N983_|_stats","",colnames(US.orf.count))

colnames(US.orf.count) <- str_replace_all(colnames(US.orf.count),"Leonard_Human_stool_Celiac","Celiac_Leonard_Stool")
colnames(US.orf.count) <- sapply(strsplit(colnames(US.orf.count),"_Stool_|_Stool_Celiac_"),"[",2)
colnames(US.orf.count) <- ifelse(colnames(US.orf.count) %like% "_6Y",gsub("_6Y","_72M",colnames(US.orf.count)),
                                           ifelse(colnames(US.orf.count) %like% "_7Y",gsub("_7Y","_84M",colnames(US.orf.count)),colnames(US.orf.count)))

US.orf.count.table_0.75 <- t(US.orf.count) 
# 203 35430


saveRDS(US.orf.count.table_0.75,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/US/US.orf.count.table_0.75_final.rds")


####Italy#####

Italy_orf.processed <- readRDS("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/Italy/wide_rpkm_genes_75Cov.rds") %>%
                 column_to_rownames("ORFID") 
# 23524   132

Italy_sample_all_0 <- names(colSums(Italy_orf.processed)[colSums(Italy_orf.processed) == 0])
# "NovaSeq_N982_I13323_39837_Celiac_Leonard_Stool_02_GEMM_077_12M"       "NovaSeq_N983_I13417_39799_Leonard_Human_stool_Celiac_02_GEMM_006_60M"


Italy.orf.count <- Italy_orf.processed %>%
                   select(-all_of(Italy_sample_all_0)) 


colnames(Italy.orf.count) <- gsub("NovaSeq_N966_|NovaSeq_N978_|NovaSeq_N979_|NovaSeq_N980_|NovaSeq_N981_|NovaSeq_N982_|NovaSeq_N983_|_stats","",colnames(Italy.orf.count))

colnames(Italy.orf.count) <- str_replace_all(colnames(Italy.orf.count),"Leonard_Human_stool_Celiac","Celiac_Leonard_Stool")
colnames(Italy.orf.count) <- sapply(strsplit(colnames(Italy.orf.count),"_Stool_|_Stool_Celiac_"),"[",2)
colnames(Italy.orf.count) <- ifelse(colnames(Italy.orf.count) %like% "_6Y",gsub("_6Y","_72M",colnames(Italy.orf.count)),
                                           ifelse(colnames(Italy.orf.count) %like% "_7Y",gsub("_7Y","_84M",colnames(Italy.orf.count)),colnames(Italy.orf.count)))

Italy.orf.count.table_0.75 <- t(Italy.orf.count) 
# 130 23524


saveRDS(Italy.orf.count.table_0.75,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/Italy/Italy.orf.count.table_0.75_final.rds")



```


# with or without 3% prevelance filtering by country
```{r}

##############################
# no 3% pravelance filtering #
##############################

#-------------------------------------------prepare abundance table----------------------------------------------------#

### US ###

US.orf.abundance.table_0.75 <- merge(metadata %>% filter(rownames(.) %in% rownames(US.orf.count.table_0.75)),US.orf.count.table_0.75,by = 0) %>% # 201 samples
                              filter(feeding_first_year != "Unknown") %>% # 201 samples
                              filter(Age.at.Gluten.Introduction..months. != "Unknown") # 197 samples

all_0_contigs <- names(colSums(US.orf.abundance.table_0.75[26:35455])[colSums(US.orf.abundance.table_0.75[26:35455]) == 0])
# 423 contigs become 0 through all samples after the 25 samples were removed from the above step
# so we need to remove those contigs



US.orf.abundance.table_0.75 <- US.orf.abundance.table_0.75 %>%
                            select(-all_of(all_0_contigs))
# 197 samples x 35032 metadata+orfs
# 35007

### Italy ###

Italy.orf.abundance.table_0.75 <- merge(metadata %>% filter(rownames(.) %in% rownames(Italy.orf.count.table_0.75)),Italy.orf.count.table_0.75,by = 0) %>% # 128 samples
                                  filter(feeding_first_year != "Unknown") %>%  # 111 samples
                                  filter(Age.at.Gluten.Introduction..months. != "Unknown") # 111 samples
# 111 23549

all_0_contigs <- names(colSums(Italy.orf.abundance.table_0.75[26:23549])[colSums(Italy.orf.abundance.table_0.75[26:23549]) == 0])
# 1076 contigs become 0 through all samples after the 17 samples were removed from the above step
# so we need to remove those contigs

Italy.orf.abundance.table_0.75 <- Italy.orf.abundance.table_0.75 %>%
                                  select(-all_of(all_0_contigs))
# final numbers: 111 samples x 22473 metadata+orfs
# 22448 orfs

#-------------------------------------------prepare PA table------------------------------------------------------#

US.orf.PA.table_0.75 <- US.orf.abundance.table_0.75 %>%
                         mutate(across(26:35032, ~ as.integer(. != 0)))
# final numbers: 197 35032
# 35007 orfs


Italy.orf.PA.table_0.75 <- Italy.orf.abundance.table_0.75 %>%
                         mutate(across(26:22473, ~ as.integer(. != 0)))
# final numbers:111 22473
# 22448 orfs

###########################
# 3% pravelance filtering #
###########################

US.PA.orf.check_0.75 <- US.orf.PA.table_0.75 %>% 
                   dplyr::select(Row.names,starts_with("virus_"),starts_with("edge")) %>% 
                   pivot_longer(cols = c(starts_with("virus_"),starts_with("edge")),names_to = "orf",values_to = "PA") %>% 
                   group_by(orf) %>% 
                   mutate(total_PA = sum(PA)) %>%
                   distinct(orf,total_PA) %>%
                   arrange(-total_PA)


write.csv(US.PA.orf.check_0.75,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/US/US_PA.orf.check_0.75.csv")


Italy.PA.orf.check_0.75 <- Italy.orf.PA.table_0.75 %>% 
                   dplyr::select(Row.names,starts_with("virus_"),starts_with("edge")) %>% 
                   pivot_longer(cols = c(starts_with("virus_"),starts_with("edge")),names_to = "orf",values_to = "PA") %>% 
                   group_by(orf) %>% 
                   mutate(total_PA = sum(PA)) %>%
                   distinct(orf,total_PA) %>%
                   arrange(-total_PA)

write.csv(Italy.PA.orf.check_0.75,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/Italy/Italy_PA.orf.check_0.75.csv")


# find viruses that exist in only 3% of the 197 US samples (197*0.03 = 5 samples)
US_non_rare_orf_0.75_0.03 <- US.PA.orf.check_0.75 %>% filter(total_PA >=5) %>% pull(orf)
# 5697

# find viruses that exist in only 3% of the 111 US samples (111*0.03 = 3 samples)
Italy_non_rare_orf_0.75_0.03 <- Italy.PA.orf.check_0.75 %>% filter(total_PA >=3) %>% pull(orf)
# 5650

# ----------------------------------------------prevelence filtering on abundance table------------------------------------------#

US.orf.abundance.table_0.75_prevFiltered <- US.orf.abundance.table_0.75 %>% dplyr::select(c(1:25,all_of(US_non_rare_orf_0.75_0.03)))
# final numbers: 197 samples x 5722 metadata+orfs
# 5697 orfs


# check if there are samples become all 0 counts
check <- US.orf.abundance.table_0.75_prevFiltered %>% select(c(Row.names,26:5722)) %>% column_to_rownames("Row.names")
rowSums(check)[rowSums(check) == 0]
# named numeric(0)
colSums(check)[colSums(check) == 0]
# named numeric(0)


Italy.orf.abundance.table_0.75_prevFiltered <- Italy.orf.abundance.table_0.75 %>% dplyr::select(c(1:25,all_of(Italy_non_rare_orf_0.75_0.03)))
# final numbers 111 samples x 5675 metadata+orfs
# 5650

# check if there are samples become all 0 counts
check <- Italy.orf.abundance.table_0.75_prevFiltered %>% select(c(Row.names,26:5675)) %>% column_to_rownames("Row.names")
rowSums(check)[rowSums(check) == 0]
# named numeric(0)
colSums(check)[colSums(check) == 0]
  # named numeric(0)


# ----------------------------------------------prevelence filtering on PA table------------------------------------------#

US.orf.PA.table_0.75_prevFiltered <- US.orf.abundance.table_0.75_prevFiltered %>%
                         mutate(across(26:5722, ~ as.integer(. != 0)))
# final numbers: 197 5722
# 5697 orfs


Italy.orf.PA.table_0.75_prevFiltered <- Italy.orf.abundance.table_0.75_prevFiltered %>%
                         mutate(across(26:5675, ~ as.integer(. != 0)))
# final numbers:111 5675
# 5650 orfs

##################################################
# 3% pravelance filtering +  temporal filtering. #
##################################################

# Criteria:
# 1. A virus must be detected (i.e. non-zero abundance) in at least 3 different timepoints (e.g. t0, t0-6, t0-12, etc.) to be kept.
# why: Viruses that appear in only 1 or 2 timepoints may just be noise or outliers — not reliable signals for modeling temporal trajectories.

# 2. Within each of those time bins, the virus must be non-zero in at least 2 samples.
# why: If a virus appears in only one person at one timepoint, it's likely due to technical noise or rare biological events — not something generalizable across a group.

################## US ##################

# prepare clean metadata
metadata.clean <- US.orf.abundance.table_0.75_prevFiltered[1:25] %>%
                  column_to_rownames("Row.names")
# 197  24


orf.abundance.clean <- US.orf.abundance.table_0.75_prevFiltered %>%
                           select(c("Row.names",26:5722)) %>%
                           filter(Row.names %in% rownames(metadata.clean)) %>%
                           column_to_rownames("Row.names") %>% 
                           t(.) %>%
                           data.frame(.)
colnames(orf.abundance.clean) <- gsub("X","",colnames(orf.abundance.clean))
# 5697  197


US.orf.abundance.table_0.75_prevFiltered_temporal <- merge(metadata.clean,t(filter_by_temporal_support(orf.abundance.clean,metadata.clean)),by= 0)
# 197 1254


# chck if there are samples become 0 counts after 3% prev filtering
check <- US.orf.abundance.table_0.75_prevFiltered_temporal %>% select(c("Row.names",26:1254)) %>% column_to_rownames("Row.names")
names(colSums(check)[colSums(check) < 9])
# character(0)
names(rowSums(check)[rowSums(check) == 0])
# 01_GEMM_154_30M


# we will have to remove sample 02_GEMM_021_36M because it becomes 0 counts at this step
US.orf.abundance.table_0.75_prevFiltered_temporal <- US.orf.abundance.table_0.75_prevFiltered_temporal %>%
                                         filter(Row.names != "01_GEMM_154_30M")
# final number: 196 samples x 1254 metadata+orfs
# 1229 orfs


################## Italy ##################


# prepare clean metadata
metadata.clean <- Italy.orf.abundance.table_0.75_prevFiltered[1:25] %>%
                  column_to_rownames("Row.names")
# 111  24


orf.abundance.clean <- Italy.orf.abundance.table_0.75_prevFiltered %>%
                           select(c("Row.names",26:5675)) %>%
                           filter(Row.names %in% rownames(metadata.clean)) %>%
                           column_to_rownames("Row.names") %>% 
                           t(.) %>%
                           data.frame(.)
colnames(orf.abundance.clean) <- gsub("X","",colnames(orf.abundance.clean))
# 5650  111


Italy.orf.abundance.table_0.75_prevFiltered_temporal <- merge(metadata.clean,t(filter_by_temporal_support(orf.abundance.clean,metadata.clean)),by= 0) %>%
                                                        select(-RunNumber)
# 111 259


# chck if there are samples become 0 counts after 3% prev filtering
check <- Italy.orf.abundance.table_0.75_prevFiltered_temporal %>% select(c("Row.names",26:259)) %>% column_to_rownames("Row.names")
names(colSums(check)[colSums(check) < 3])
# character(0)
names(rowSums(check)[rowSums(check) == 0])
# "02_GEMM_006_18M" "02_GEMM_006_30M" "02_GEMM_006_36M" "02_GEMM_010_24M" "02_GEMM_010_30M" "02_GEMM_013_12M" "02_GEMM_021_36M" "02_GEMM_024_12M"
# "02_GEMM_030_12M" "02_GEMM_031_12M" "02_GEMM_038_12M" "02_GEMM_041_12M" "02_GEMM_070_24M" "02_GEMM_177_30M" "02_GEMM_228_12M"


# we will have to remove sample 02_GEMM_021_36M because it becomes 0 counts at this step
Italy.orf.abundance.table_0.75_prevFiltered_temporal <- Italy.orf.abundance.table_0.75_prevFiltered_temporal %>%
                                         filter(!Row.names %in% c("02_GEMM_006_18M","02_GEMM_006_30M","02_GEMM_006_36M","02_GEMM_010_24M","02_GEMM_010_30M","02_GEMM_013_12M","02_GEMM_021_36M","02_GEMM_024_12M","02_GEMM_030_12M","02_GEMM_031_12M","02_GEMM_038_12M","02_GEMM_041_12M","02_GEMM_070_24M","02_GEMM_177_30M","02_GEMM_228_12M"))

# final number: 96 samples x 259 metadata+orfs
# 234 orfs

```


# 75% mapping rate filtering and 3% prevlance filtering
```{r}

orf <- vroom("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/Orf_Coverm_concatenated.txt",col_names = FALSE)
# we have 340 samples and 46594 orfs in total after phage pipeline


filter_and_save_wide_data(orf, 
                          covered_fraction_threshold = 0.75, 
                          output_path = "~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/")
# Number of changes: 185957

orf.processed <- readRDS("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/wide_rpkm_genes_75Cov.rds") %>%
                 column_to_rownames("ORFID")

# then let's check colSums and ensure there is no sample have all 0s across orfs
sample_all_0 <- names(colSums(orf.processed)[colSums(orf.processed) == 0])
# "NovaSeq_N978_I13149_39572_Celiac_Leonard_Stool_01_GEMM_093_24M"       "NovaSeq_N978_I13150_39573_Celiac_Leonard_Stool_01_GEMM_093_30M"      
# "NovaSeq_N978_I13151_39574_Celiac_Leonard_Stool_01_GEMM_093_36M"       "NovaSeq_N978_I13152_39575_Celiac_Leonard_Stool_01_GEMM_093_48M"      
# "NovaSeq_N982_I13323_39837_Celiac_Leonard_Stool_02_GEMM_077_12M"       "NovaSeq_N983_I13417_39799_Leonard_Human_stool_Celiac_02_GEMM_006_60M"


# let's remove the 6 0 counts samples
orf.processed <- orf.processed %>%
                    select(-all_of(sample_all_0))
dim(orf.processed)
# 46102   334


# here we found two duplicated samples:
# "NovaSeq_N978_I13164_39587_Celiac_Leonard_Stool_01_GEMM_106_12M_stats" and  "NovaSeq_N983_I13413_39587_Celiac_Leonard_Stool_01_GEMM_106_12M_stats"
# after checking with my note, the N983 01_GEMM_106_12M sample should actually be water
orf.processed <- orf.processed %>%
                 select(-NovaSeq_N983_I13413_39587_Celiac_Leonard_Stool_01_GEMM_106_12M)
# 46102   333

orf.count <- orf.processed

colnames(orf.count) <- gsub("NovaSeq_N966_|NovaSeq_N978_|NovaSeq_N979_|NovaSeq_N980_|NovaSeq_N981_|NovaSeq_N982_|NovaSeq_N983_|_stats","",colnames(orf.count))

colnames(orf.count) <- str_replace_all(colnames(orf.count),"Leonard_Human_stool_Celiac","Celiac_Leonard_Stool")
colnames(orf.count) <- sapply(strsplit(colnames(orf.count),"_Stool_|_Stool_Celiac_"),"[",2)
colnames(orf.count) <- ifelse(colnames(orf.count) %like% "_6Y",gsub("_6Y","_72M",colnames(orf.count)),
                                           ifelse(colnames(orf.count) %like% "_7Y",gsub("_7Y","_84M",colnames(orf.count)),colnames(orf.count)))

orf.count.table_0.75 <- t(orf.count) 
# 333 46102



orf.abundance.table_0.75 <- merge(metadata,orf.count.table_0.75,by = 0) %>% # 329 samples left
                              filter(feeding_first_year != "Unknown") %>%  # 312 samples left
                              filter(Age.at.Gluten.Introduction..months. != "Unknown") # 308 sample left
# 308 samples x  46127 metadata+orfs

all_0_contigs <- names(colSums(orf.abundance.table_0.75[25:46127])[colSums(orf.abundance.table_0.75[25:46127]) == 0])
# 837 contigs become 0 through all samples after the 25 samples were removed from the above step
# so we need to remove those contigs

orf.abundance.table_0.75 <- orf.abundance.table_0.75 %>%
                            select(-all_of(all_0_contigs))
# 308 samples x 45290 metadata+orfs
# 45290 orfs


orf.abundance.table <- orf.abundance.table_0.75 %>%
                       select(c("Row.names",26:45290)) %>%
                       column_to_rownames("Row.names") %>% 
                       t(.) %>%
                       data.frame(.)
colnames(orf.abundance.table) <- gsub("X","",colnames(orf.abundance.table))


# check prevelence filtering
prevalence <- rowSums(orf.abundance.table > 0) / ncol(orf.abundance.table)
table(prevalence > 0.03)  # 5% threshold
# FALSE  TRUE 
# 42952  2313

# Filter ORFs with prevalence > 3%
orf.abundance.clean <- orf.abundance.table[prevalence > 0.03, ]
      
dim(orf.abundance.clean)
# 2313  308 (3% prev)
# 577 308 (5% prev)

# check if there are any samples become 0 counts
names(colSums(orf.abundance.clean)[colSums(orf.abundance.clean) == 0])
# "01_GEMM_154_30M" "02_GEMM_021_36M"

# remove the two 0 counts samples
# we will have to remove sample 02_GEMM_021_36M because it becomes 0 counts at this step
orf.abundance.clean <- orf.abundance.clean %>%
                       select(-c("01_GEMM_154_30M","02_GEMM_021_36M"))
# 2313  306
# 577 306

metadata.clean <- orf.abundance.table_0.75[1:25] %>%
                  filter(!Row.names %in% c("01_GEMM_154_30M","02_GEMM_021_36M")) %>%
                  column_to_rownames("Row.names")
# 308  24
# 306  24


# check if the column names of abundance table match the order of the row names of metadata table
all(rownames(metadata.clean) == colnames(orf.abundance.clean))
# TRUE

count_matrix <- as.matrix(orf.abundance.clean[, sapply(orf.abundance.clean, is.numeric)])
sparsity <- sum(count_matrix == 0) / length(count_matrix)
# 0.9518756

```


# check batch effect
```{r}

# logCPM transform with voom
dge <- DGEList(counts = orf.abundance.clean)
dge <- calcNormFactors(dge)
v <- voom(dge, plot = FALSE)

# PCA on top variable genes
top_var_genes <- head(order(apply(v$E, 1, var), decreasing = TRUE), 500)
pca <- prcomp(t(v$E[top_var_genes, ]), scale. = TRUE)

# Join metadata
pca_df <- data.frame(pca$x[, 1:2], metadata.clean)

# Plot by suspected batch variable
p.batch <- ggplot(pca_df, aes(PC1, PC2, color = RunNumber)) +
  geom_point(size = 2) +
  labs(title = "PCA colored by RunNumber") +
  theme_minimal()


# to remove batch effect
# extract the logCPM matrix from the voom
logCPM <- v$E

# Step 1: Remove batch effect using limma
# Assume `logCPM` is a matrix: genes (rows) x samples (columns)
# `metadata` must have a column named "RunNumber"
logCPM_corrected <- removeBatchEffect(logCPM, batch = metadata.clean$RunNumber)

# Step 2: Transpose the matrix so that PCA treats samples as rows
pca_input <- t(logCPM_corrected)

# Step 3: Run PCA
pca_res <- prcomp(pca_input, scale. = TRUE)

# Step 4: Merge PCA results with metadata
pca_df <- as.data.frame(pca_res$x)
pca_df$SampleID <- rownames(pca_df)
pca_df <- merge(pca_df, metadata.clean, by = 0)  # adjust as needed


# Step 5: Plot PCA with ggplot2
p.batch.correct <- ggplot(pca_df, aes(x = PC1, y = PC2, color = RunNumber)) +
  geom_point(size = 2, alpha = 0.8) +
  theme_minimal() +
  labs(title = "PCA after Batch Correction",
       x = "PC1", y = "PC2", color = "RunNumber")


```





                                                          ##################################################
                                                          #                                                #
                                                          #              Limma      Model                  #
                                                          #                                                #    
                                                          ##################################################





                                                                   
########################################################################## Entire dataset ###############################################################                                                                 
                                                                   
                                                                   
                                              #######################################################################
                                              #             Limma model on 3% pravelance filtered data              #   
                                              #         orf.abundance.table_0.75_prevFiltered (3077 orfs)           #
                                              #######################################################################

Check the sparsity
```{r}

# prepare clean metadata
metadata.clean <- orf.abundance.table_0.75_prevFiltered[1:25] %>%
                  column_to_rownames("Row.names")
# 306  24


orf.abundance.clean <- orf.abundance.table_0.75_prevFiltered %>%
                           select(c("Row.names",26:2992)) %>%
                           filter(Row.names %in% rownames(metadata.clean)) %>%
                           column_to_rownames("Row.names") %>% 
                           t(.) %>%
                           data.frame(.)
colnames(orf.abundance.clean) <- gsub("X","",colnames(orf.abundance.clean))

zero_fraction <- rowMeans(orf.abundance.clean == 0)
summary(zero_fraction)


mean(orf.abundance.clean == 0)


prevalence <- rowSums(orf.abundance.clean > 0) / ncol(orf.abundance.clean)
table(prevalence > 0.03)  # 3% threshold


prevalence <- rowSums(orf.abundance.clean > 0) / ncol(orf.abundance.clean)


ggplot(data.frame(prevalence), aes(x = prevalence)) +
  geom_histogram(binwidth = 0.01, fill = "steelblue", color = "black") +
  geom_vline(xintercept = c(0.03, 0.05, 0.10), linetype = "dashed", color = "red") +
  labs(title = "Prevalence Distribution of ORFs", x = "Fraction of Samples with Non-Zero Counts", y = "Number of ORFs") +
  theme_minimal()


```



Model 1: treating onset_timeline as a factor
~ Dx.Status * onset_timeline + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode, block = patientID
```{r}

# prepare clean metadata
metadata.clean <- orf.abundance.table_0.75_prevFiltered[1:25] %>%
                  column_to_rownames("Row.names")
dim(metadata.clean)
# 306  24


orf.abundance.clean <- orf.abundance.table_0.75_prevFiltered %>%
                           select(c("Row.names",26:2992)) %>%
                           filter(Row.names %in% rownames(metadata.clean)) %>%
                           column_to_rownames("Row.names") %>% 
                           t(.) %>%
                           data.frame(.)
colnames(orf.abundance.clean) <- gsub("X","",colnames(orf.abundance.clean))
# 2967  306


# prepare correct variable format
metadata.clean$feeding_first_year <- factor(metadata.clean$feeding_first_year,levels = c("Breast_fed","Formula","Breastmilk_and_formula"))
# Breast_fed      Formula   Breastmilk_and_formula 
#    120             58              129 
metadata.clean$HLA.Category <- factor(metadata.clean$HLA.Category,levels = c("Standard Risk","High Risk","Low/No Risk"))
# Standard Risk     High Risk   Low/No Risk 
#      169            94            44
metadata.clean$Country <- factor(metadata.clean$Country,levels = c("ITALY","USA"))
# ITALY   USA 
#   110   197 
metadata.clean$Sex <- factor(metadata.clean$Sex,levels = c("Female","Male"))
# Female  Male 
#   238   69
metadata.clean$Delivery.Mode <- factor(metadata.clean$Delivery.Mode,levels = c("Vaginal","C-Section"))
# Vaginal C-Section 
# 217        90
metadata.clean$Dx.Status <- factor(metadata.clean$Dx.Status,levels = c("CELIAC","CONTROL"))
# CONTROL  CELIAC 
#    162     145 
metadata.clean$onset_timeline <- factor(metadata.clean$onset_timeline,levels = c("t0","t0-6","t0-12","t0-18","t0-24","t0-30","t0-36","t0-42","t0-48","t0-54","t0-60","t0-66","t0-72"))
# t0  t0-6 t0-12 t0-18 t0-24 t0-30 t0-36 t0-42 t0-48 t0-54 t0-60 t0-66 t0-72 
# 64    30    46    27    32    29    33    14    16     4     4     4     4 
metadata.clean$Age.at.Gluten.Introduction..months. <- as.numeric(metadata.clean$Age.at.Gluten.Introduction..months.)
# Here we treat Age.at.Gluten.Introduction..months. as numrical variable because:

# They have inherent order (4 < 5 < 6 < ... < 36)
# The differences between values are meaningful
# Thus, not categorical in nature, even if some values are sparse

# for this round we treat Age.at.Gluten.Introduction..months. as linear 


# before fitting the model, we better check if we have enough number of sample at each timepoint, if the number is too small, it may cause
# 1. The model can overfit or produce unstable estimates
# 2. Some interaction terms (e.g. Dx.StatusCELIAC:onset_timeline_t0-6) may be unestimable or have inflated standard errors.
# 3. Limma may drop these levels silently if they’re not estimable due to collinearity.
table(metadata.clean$Dx.Status,metadata.clean$onset_timeline)
  #      CELIAC CONTROL
  # t0        31      33
  # t0-6      14      16
  # t0-12     21      25
  # t0-18     12      15
  # t0-24     14      18
  # t0-30     14      15
  # t0-36     16      17
  # t0-42      7       7
  # t0-48      8       8
  # t0-54      2       2
  # t0-60      2       2
  # t0-66      2       2
  # t0-72      2       2

# As we see from the above table, from t0-42 to t0-72, there are too few of samples per group, (7 and 8 mightbe ok).
# We will go ahead and fit the model in this way first, then see how the model output.

# treat Age.at.Gluten.Introduction..months. as linear
linear.model.design <- model.matrix(~ Dx.Status * onset_timeline + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
linear.model.fit <- voomLmFit(orf.abundance.clean,linear.model.design,block= metadata.clean$patientID,plot=FALSE)
linear.model.fit <- eBayes(linear.model.fit)


# treat Age.at.Gluten.Introduction..months. as non-linear
nonlinear.model.design <- model.matrix(~ Dx.Status * onset_timeline + Country + Sex + ns(Age.at.Gluten.Introduction..months.,df=3) + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
nonlinear.model.fit <- voomLmFit(orf.abundance.clean,nonlinear.model.design,block= metadata.clean$patientID,plot=FALSE)
nonlinear.model.fit <- eBayes(nonlinear.model.fit)



#######################################################################################################################################
# check which model is better

# Manual computation of fitted values
fitted_linear <- linear.model.fit$coefficients %*% t(linear.model.design)  # Genes × Samples
fitted_spline <- nonlinear.model.fit$coefficients %*% t(nonlinear.model.design)

# calculate the residules for each genes
resid_linear <- orf.abundance.clean - fitted_linear
resid_spline <- orf.abundance.clean - fitted_spline

# compute residual sum of squares (RSS)
rss_linear <- rowSums(resid_linear^2)
rss_spline <- rowSums(resid_spline^2)


# get the sample size per gene
n <- ncol(orf.abundance.clean)
# get the number of model parameters for both models
k_linear <- ncol(linear.model.design)
k_spline <- ncol(nonlinear.model.design)

# given the formula of calculating AIC
# AIC = n * log(RSS / n) + 2 * k
# n = number of observations (samples)
# RSS = residual sum of squares per gene
# k = number of parameters used in the model

# calculate AICs for both models
aic_linear <- n * log(rss_linear / n) + 2 * k_linear
aic_spline <- n * log(rss_spline / n) + 2 * k_spline

# compare AICs of genes for both models
delta_aic <- aic_linear - aic_spline

# make a histogram plot to visualize how the differences of AIC scores distributed 
AIC_differences <- ggplot(data.frame(delta_aic), aes(delta_aic)) +
  geom_histogram(binwidth = 1) +
  labs("Gluten Age ΔAIC (Linear - Spline)", x = "ΔAIC: Positive = spline better")

# calculate how many genes has AIC scores at least 2 points lower than linear model (ΔAIC > 2 is a common cutoff for "meaningful" improvement)
mean(delta_aic > 2)
# 0.0003370408 (only 0.03370408% genes are better fit in splines model)


ggsave(AIC_differences,file="~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/GlutenAge_ΔAIC_LinearVSSpline).pdf",dpi = 600, width = 8, height = 10)

# Conclusion: use linear model
########################################################################################################################################

colnames(linear.model.fit)
#  [1] "(Intercept)"                              "Dx.StatusCONTROL"                         "onset_timelinet0-6"                      
#  [4] "onset_timelinet0-12"                      "onset_timelinet0-18"                      "onset_timelinet0-24"                     
#  [7] "onset_timelinet0-30"                      "onset_timelinet0-36"                      "onset_timelinet0-42"                     
# [10] "onset_timelinet0-48"                      "onset_timelinet0-54"                      "onset_timelinet0-60"                     
# [13] "onset_timelinet0-66"                      "onset_timelinet0-72"                      "CountryUSA"                              
# [16] "SexMale"                                  "Age.at.Gluten.Introduction..months."      "HLA.CategoryHigh Risk"                   
# [19] "HLA.CategoryLow/No Risk"                  "feeding_first_yearFormula"                "feeding_first_yearBreastmilk_and_formula"
# [22] "Delivery.ModeC-Section"                   "Dx.StatusCONTROL:onset_timelinet0-6"      "Dx.StatusCONTROL:onset_timelinet0-12"    
# [25] "Dx.StatusCONTROL:onset_timelinet0-18"     "Dx.StatusCONTROL:onset_timelinet0-24"     "Dx.StatusCONTROL:onset_timelinet0-30"    
# [28] "Dx.StatusCONTROL:onset_timelinet0-36"     "Dx.StatusCONTROL:onset_timelinet0-42"     "Dx.StatusCONTROL:onset_timelinet0-48"    
# [31] "Dx.StatusCONTROL:onset_timelinet0-54"     "Dx.StatusCONTROL:onset_timelinet0-60"     "Dx.StatusCONTROL:onset_timelinet0-66"    
# [34] "Dx.StatusCONTROL:onset_timelinet0-72" 


model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-6",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-6",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-12",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-12",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-18",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-18",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-24",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-24",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-30",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-30",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-36",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-36",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2208
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-42",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-42",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 1927
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-48",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-48",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2678
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-54",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-54",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-60",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-60",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 3
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-66",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-66",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-72",adjust.method = "BH",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-72",adjust.method = "BH",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2485

# hist(sig.model.res$adj.P.Val, breaks = 50) # the shape looks valid
# hist(model.res$adj.P.Val, breaks = 50, col = "gray", main = "All Adjusted P-Values") # the shape looks valid as well

###########################################################################################################################


model.res <- topTable(linear.model.fit,coef="onset_timelinet0-6",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-6",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-12",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-12",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-18",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-18",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-24",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-24",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-30",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-30",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 5
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-36",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-36",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-48",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-48",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-60",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-60",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-66",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-66",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-72",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-72",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0

#################################################################################################

model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 significant orf

#################################################################################################

model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 1834
model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6


```


Model 2: modifying onset_timeline by combining the to-42M to t0-72M as one names "t0-over42"
~ Dx.Status * onset_timeline_combined + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode, block = patientID
```{r}


# prepare clean metadata
metadata.clean <- orf.abundance.table_0.75_prevFiltered[1:25] %>%
                  column_to_rownames("Row.names")
# 306  24

orf.abundance.clean <- orf.abundance.table_0.75_prevFiltered %>%
                           select(c("Row.names",26:2992)) %>%
                           filter(Row.names %in% rownames(metadata.clean)) %>%
                           column_to_rownames("Row.names") %>% 
                           t(.) %>%
                           data.frame(.)
colnames(orf.abundance.clean) <- gsub("X","",colnames(orf.abundance.clean))
# 2967  306


# prepare correct variable format
metadata.clean$feeding_first_year <- factor(metadata.clean$feeding_first_year,levels = c("Breast_fed","Formula","Breastmilk_and_formula"))
# Breast_fed      Formula   Breastmilk_and_formula 
#    120             58              129 
metadata.clean$HLA.Category <- factor(metadata.clean$HLA.Category,levels = c("Standard Risk","High Risk","Low/No Risk"))
# Standard Risk     High Risk   Low/No Risk 
#      169            94            44
metadata.clean$Country <- factor(metadata.clean$Country,levels = c("ITALY","USA"))
# ITALY   USA 
#   110   197 
metadata.clean$Sex <- factor(metadata.clean$Sex,levels = c("Female","Male"))
# Female  Male 
#   238   69
metadata.clean$Delivery.Mode <- factor(metadata.clean$Delivery.Mode,levels = c("Vaginal","C-Section"))
# Vaginal C-Section 
# 217        90
metadata.clean$Dx.Status <- factor(metadata.clean$Dx.Status,levels = c("CELIAC","CONTROL"))
# CONTROL  CELIAC 
#    162     145 
metadata.clean$onset_timeline_combined <- factor(metadata.clean$onset_timeline_combined,levels = c("t0","t0-6","t0-12","t0-18","t0-24","t0-30","t0-36","t0-over42"))
 # t0      t0-6     t0-12     t0-18     t0-24     t0-30     t0-36 t0-over42 
 # 64        30        46        27        32        29        33        46 
metadata.clean$Age.at.Gluten.Introduction..months. <- as.numeric(metadata.clean$Age.at.Gluten.Introduction..months.)
# 4  5  6  7  8  9 10 11 12 15 36 
# 5 11 57 91 40 33 33 10  2 16  9 


# after combine the late timepoints of onset_timeline, the distribution is like below:
table(metadata.clean$Dx.Status, metadata.clean$onset_timeline_combined) %>% t(.)
#             CELIAC CONTROL
# t0            31      33
# t0-6          14      16
# t0-12         21      25
# t0-18         12      15
# t0-24         14      18
# t0-30         14      15
# t0-36         16      17
# t0-over42     23      23

# since the number of parameters changed (less levels in onset_timeline_combined variable), so we need to re-evaluate the linearity of Age.at.Gluten.Introduction..months. variable

# treat Age.at.Gluten.Introduction..months. as linear
linear.model.design <- model.matrix(~ Dx.Status * onset_timeline_combined + RunNumber + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
linear.model.fit <- voomLmFit(orf.abundance.clean,linear.model.design,block= metadata.clean$patientID,plot=FALSE)
linear.model.fit <- eBayes(linear.model.fit)
linear.model.fit.factor <- linear.model.fit


# treat Age.at.Gluten.Introduction..months. as non-linear
nonlinear.model.design <- model.matrix(~ Dx.Status * onset_timeline_combined + Country + Sex + ns(Age.at.Gluten.Introduction..months.,df=3) + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
nonlinear.model.fit <- voomLmFit(orf.abundance.clean,nonlinear.model.design,block= metadata.clean$patientID,plot=FALSE)
nonlinear.model.fit <- eBayes(nonlinear.model.fit)



#######################################################################################################################################
# check which model is better

# Manual computation of fitted values
fitted_linear <- linear.model.fit$coefficients %*% t(linear.model.design)  # Genes × Samples
fitted_spline <- nonlinear.model.fit$coefficients %*% t(nonlinear.model.design)

# calculate the residules for each genes
resid_linear <- orf.abundance.clean - fitted_linear
resid_spline <- orf.abundance.clean - fitted_spline

# compute residual sum of squares (RSS)
rss_linear <- rowSums(resid_linear^2)
rss_spline <- rowSums(resid_spline^2)


# get the sample size per gene
n <- ncol(orf.abundance.clean)
# get the number of model parameters for both models
k_linear <- ncol(linear.model.design)
k_spline <- ncol(nonlinear.model.design)

# given the formula of calculating AIC
# AIC = n * log(RSS / n) + 2 * k
# n = number of observations (samples)
# RSS = residual sum of squares per gene
# k = number of parameters used in the model

# calculate AICs for both models
aic_linear <- n * log(rss_linear / n) + 2 * k_linear
aic_spline <- n * log(rss_spline / n) + 2 * k_spline

# compare AICs of genes for both models
delta_aic <- aic_linear - aic_spline

# make a histogram plot to visualize how the differences of AIC scores distributed 
AIC_differences <- ggplot(data.frame(delta_aic), aes(delta_aic)) +
                  geom_histogram(binwidth = 1) +
                  labs("Gluten Age ΔAIC (Linear - Spline)", x = "ΔAIC: Positive = spline better")

# calculate how many genes has AIC scores at least 2 points lower than linear model (ΔAIC > 2 is a common cutoff for "meaningful" improvement)
mean(delta_aic > 2)
# 0.0003370408 (only 0.03370408% genes are better fit in splines model)

# Conclusion: use linear model
########################################################################################################################################

colnames(linear.model.fit)
#  [1] "(Intercept)"                                       "Dx.StatusCONTROL"                                  "onset_timeline_combinedt0-12"                     
#  [4] "onset_timeline_combinedt0-18"                      "onset_timeline_combinedt0-24"                      "onset_timeline_combinedt0-30"                     
#  [7] "onset_timeline_combinedt0-36"                      "onset_timeline_combinedt0-6"                       "onset_timeline_combinedt0-over42"                 
# [10] "CountryUSA"                                        "SexMale"                                           "Age.at.Gluten.Introduction..months."              
# [13] "HLA.CategoryHigh Risk"                             "HLA.CategoryLow/No Risk"                           "feeding_first_yearFormula"                        
# [16] "feeding_first_yearBreastmilk_and_formula"          "Delivery.ModeC-Section"                            "Dx.StatusCONTROL:onset_timeline_combinedt0-12"    
# [19] "Dx.StatusCONTROL:onset_timeline_combinedt0-18"     "Dx.StatusCONTROL:onset_timeline_combinedt0-24"     "Dx.StatusCONTROL:onset_timeline_combinedt0-30"    
# [22] "Dx.StatusCONTROL:onset_timeline_combinedt0-36"     "Dx.StatusCONTROL:onset_timeline_combinedt0-6"      "Dx.StatusCONTROL:onset_timeline_combinedt0-over42"         

model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-6",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-6",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-12",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-12",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-18",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-18",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 1
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-24",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-24",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-30",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-30",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-36",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-36",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 1683
sig.factor <- rownames(sig.model.res)

model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-over42",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-over42",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2027

# hist(sig.model.res$adj.P.Val, breaks = 50) # the shape looks valid
# hist(model.res$adj.P.Val, breaks = 50, col = "gray", main = "All Adjusted P-Values") # the shape looks valid as well

###########################################################################################################################


model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-6",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-6",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-12",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-12",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 9
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-18",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-18",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-24",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-24",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-30",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-30",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 9
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-36",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-36",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-over42",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-over42",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0

#################################################################################################

model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 significant orf


#################################################################################################

model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2183 6
model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6

```


Model 3: create a numeric format of onset_timeline and make it onset_timeline_numeric assume it is linear in the model
~ Dx.Status * onset_timeline_numeric + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode, block = patientID
```{r}

# 
# # prepare clean metadata
# metadata.clean <- orf.abundance.table_0.75_prevFiltered[1:25] %>%
#                   column_to_rownames("Row.names")
# # 306  24
# 
# 
# orf.abundance.clean <- orf.abundance.table_0.75_prevFiltered %>%
#                            select(c("Row.names",26:2992)) %>%
#                            filter(Row.names %in% rownames(metadata.clean)) %>%
#                            column_to_rownames("Row.names") %>% 
#                            t(.) %>%
#                            data.frame(.)
# colnames(orf.abundance.clean) <- gsub("X","",colnames(orf.abundance.clean))
# # 2967 306

# write.csv(orf.abundance.clean,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/orf.abundance.clean.csv",quote = FALSE,row.names = TRUE)


# prepare correct variable format
metadata.clean$feeding_first_year <- factor(metadata.clean$feeding_first_year,levels = c("Breast_fed","Formula","Breastmilk_and_formula"))
# Breast_fed      Formula   Breastmilk_and_formula 
#    120             58              129 
metadata.clean$HLA.Category <- factor(metadata.clean$HLA.Category,levels = c("Standard Risk","High Risk","Low/No Risk"))
# Standard Risk     High Risk   Low/No Risk 
#      169            94            44
metadata.clean$Country <- factor(metadata.clean$Country,levels = c("ITALY","USA"))
# ITALY   USA 
#   110   197 
metadata.clean$Sex <- factor(metadata.clean$Sex,levels = c("Female","Male"))
# Female  Male 
#   238   69
metadata.clean$Delivery.Mode <- factor(metadata.clean$Delivery.Mode,levels = c("Vaginal","C-Section"))
# Vaginal C-Section 
# 217        90
metadata.clean$Age.at.Gluten.Introduction..months. <- as.numeric(metadata.clean$Age.at.Gluten.Introduction..months.)
# #  # 4  5  6  7  8  9 10 11 12 15 36 
# #  # 5 11 57 91 40 33 33 10  2 16  9 
metadata.clean$Dx.Status <- factor(metadata.clean$Dx.Status,levels = c("CELIAC","CONTROL"))
# CONTROL  CELIAC 
#    162     145 


# since the number of parameters changed (onset_timeline as linear numeric), so we need to re-evaluate the linearity of Age.at.Gluten.Introduction..months. variable

# treat Age.at.Gluten.Introduction..months. as linear
linear.model.design <- model.matrix(~ Dx.Status * onset_timeline_numeric + RunNumber + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
# linear.model.fit <- lmFit(logCPM_corrected, design = linear.model.design)
# linear.model.fit <- eBayes(linear.model.fit)
linear.model.fit <- voomLmFit(orf.abundance.clean,linear.model.design,block= metadata.clean$patientID,plot=FALSE)
linear.model.fit <- eBayes(linear.model.fit)


# treat Age.at.Gluten.Introduction..months. as non-linear
nonlinear.model.design <- model.matrix(~ Dx.Status * onset_timeline_numeric + Country + Sex + ns(Age.at.Gluten.Introduction..months.,df=3) + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
nonlinear.model.fit <- voomLmFit(orf.abundance.clean,nonlinear.model.design,block= metadata.clean$patientID,plot=FALSE)
nonlinear.model.fit <- eBayes(nonlinear.model.fit)


#######################################################################################################################################
# check which model is better

# Manual computation of fitted values
fitted_linear <- linear.model.fit$coefficients %*% t(linear.model.design)  # Genes × Samples
fitted_spline <- nonlinear.model.fit$coefficients %*% t(nonlinear.model.design)

# calculate the residules for each genes
resid_linear <- orf.abundance.clean - fitted_linear
resid_spline <- orf.abundance.clean - fitted_spline

# compute residual sum of squares (RSS)
rss_linear <- rowSums(resid_linear^2)
rss_spline <- rowSums(resid_spline^2)


# get the sample size per gene
n <- ncol(orf.abundance.clean)
# get the number of model parameters for both models
k_linear <- ncol(linear.model.design)
k_spline <- ncol(nonlinear.model.design)

# given the formula of calculating AIC
# AIC = n * log(RSS / n) + 2 * k
# n = number of observations (samples)
# RSS = residual sum of squares per gene
# k = number of parameters used in the model

# calculate AICs for both models
aic_linear <- n * log(rss_linear / n) + 2 * k_linear
aic_spline <- n * log(rss_spline / n) + 2 * k_spline

# compare AICs of genes for both models
delta_aic <- aic_linear - aic_spline

# make a histogram plot to visualize how the differences of AIC scores distributed 
AIC_differences <- ggplot(data.frame(delta_aic), aes(delta_aic)) +
                  geom_histogram(binwidth = 1) +
                  labs("Gluten Age ΔAIC (Linear - Spline)", x = "ΔAIC: Positive = spline better")


# calculate how many genes has AIC scores at least 2 points lower than linear model (ΔAIC > 2 is a common cutoff for "meaningful" improvement)
mean(delta_aic > 2)
# 0.0003370408 (only 0.03370408% genes are better fit in splines model)

# Conclusion: use linear model
########################################################################################################################################
colnames(linear.model.fit)
#  [1] "(Intercept)"                              "Dx.StatusCONTROL"                         "onset_timeline_numeric"                  
#  [4] "CountryUSA"                               "SexMale"                                  "Age.at.Gluten.Introduction..months."     
#  [7] "HLA.CategoryHigh Risk"                    "HLA.CategoryLow/No Risk"                  "feeding_first_yearFormula"               
# [10] "feeding_first_yearBreastmilk_and_formula" "Delivery.ModeC-Section"                   "Dx.StatusCONTROL:onset_timeline_numeric" 


model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_numeric",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_numeric",number=Inf) %>% filter(adj.P.Val < 0.01)
# 1347

sig.linear <- rownames(sig.model.res)

length(intersect(sig.linear,sig.factor))
# 1226 overlapped

# write.csv(model.res,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/limma_model_res.csv",quote = FALSE,row.names = TRUE)

# Define gene of interest
selected_gene <- rownames(sig.model.res)

# Subset design matrix and model coefficients for prediction
linear.model.design <- model.matrix(~ Dx.Status * onset_timeline_numeric + RunNumber + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)

trajectory_plot_list <- list()


for (i in selected_gene){
  
   # Extract observed abundance vector for gene i
  gene_abundance <- orf.abundance.clean[i, ]

  # Create metadata + model prediction + observed abundance
  predicted_df <- metadata.clean %>%
    mutate(predicted_abundance = as.numeric(linear.model.design %*% linear.model.fit$coefficients[i, ]),
           observed_abundance = as.numeric(gene_abundance))

  # Count non-zero samples and total abundance per group and time
  count_df <- predicted_df %>%
    group_by(onset_timeline_numeric, Dx.Status) %>%
    summarise(
      non_zero_n = sum(observed_abundance > 0, na.rm = TRUE),
      total_reads = sum(observed_abundance, na.rm = TRUE),
      .groups = "drop"
    )

  # Get mean predicted values per group and time
  plot_df_pred <- predicted_df %>%
  left_join(count_df, by = c("onset_timeline_numeric", "Dx.Status")) %>%
  group_by(onset_timeline_numeric, Dx.Status) %>%
  summarise(
    mean_pred = mean(predicted_abundance, na.rm = TRUE),
    non_zero_n = first(non_zero_n),      # from count_df
    total_reads = first(total_reads),    # from count_df
    .groups = "drop"
  ) %>%
  mutate(mean_pred = ifelse(non_zero_n == 0 & total_reads == 0, NA, mean_pred))
  

  # Label showing both counts
  plot_df_pred <- plot_df_pred %>%
    mutate(label_text = paste0("n=", non_zero_n, "\nreads=", round(total_reads)))

  # Plot with annotations for sample count and total reads
  p <- ggplot(plot_df_pred, aes(x = onset_timeline_numeric, y = mean_pred, color = Dx.Status)) +
    geom_line(size = 1.2) +
    geom_point(size = 2) +
    geom_text(aes(label = label_text), vjust = -0.5, size = 3) +
    labs(title = i,
         x = "Months before onset", y = "Predicted Abundance (logCPM)") +
    theme(legend.position = "none")

  # Store in list
  trajectory_plot_list[[i]] <- p
}


# # Pick 10 plots
# plot_subset <- trajectory_plot_list[1:500]  # or use names: trajectory_plot_list[c("gene1", "gene2", ...)]
# # Combine into grid: 2 rows × 5 columns
# grid_plot <- wrap_plots(plot_subset)
# ggsave(grid_plot,file=paste0("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/Total_trajectory_batchRemoved_clean.pdf"),dpi = 600,width = 75,height=65,limitsize = FALSE)



# hist(sig.model.res$adj.P.Val, breaks = 50) # the shape looks valid
# hist(model.res$adj.P.Val, breaks = 50, col = "gray", main = "All Adjusted P-Values") # the shape looks valid as well

###########################################################################################################################

model.res <- topTable(linear.model.fit,coef="onset_timeline_numeric",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_numeric",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 1

#################################################################################################

model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2015


#################################################################################################

model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6


```


Reliability Checks
```{r}

# 1.Distribution of p-values and logFC, Detect inflated significance or very small effect sizes.

hist(model.res$P.Value, main = "Raw p-values", xlab = "p-value")
hist(model.res$adj.P.Val, main = "Adjusted p-values", xlab = "adj.P.Val")
plot(model.res$logFC, -log10(model.res$adj.P.Val),
     xlab = "logFC", ylab = "-log10(adj.P.Val)",
     main = "Volcano Plot")



# 2.Permutation test (null distribution)
set.seed(123)
metadata.permuted <- metadata.clean

n_permutations <- 100
sig_counts <- numeric(n_permutations)

for (i in 1:n_permutations) {
  # 1. Shuffle the condition labels
  metadata.permuted$Dx.Status <- sample(metadata.permuted$Dx.Status)
  
  # 3. Build design matrix with permuted status
  design <- model.matrix(~ Dx.Status * onset_timeline_numeric + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.permuted)
  
v <- voomLmFit(orf.abundance.clean,design,block= metadata.permuted$patientID,plot=FALSE)
fit <- eBayes(v)
top <- topTable(fit, coef = "Dx.StatusCONTROL:onset_timeline_numeric", number = Inf) 

  sig_counts[i] <- sum(top$adj.P.Val < 0.05)
}


# Visualize the null distribution
hist(sig_counts, main = "Empirical Null: Significant ORFs per Permutation", xlab = "Number of significant ORFs (FDR < 0.05)")

# Compare to your real result
abline(v = num_real_sig, col = "red", lwd = 2)  # replace num_real_sig with your real value



```



Model 4: create a numeric format of onset_timeline and make it onset_timeline_numeric assume it is nonlinear in the model
~ Dx.Status * ns(onset_timeline_numeric,df=3) + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode, block = patientID
```{r}


# prepare clean metadata
metadata.clean <- orf.abundance.table_0.75_prevFiltered[1:25] %>%
                  mutate(onset_timeline_numeric = as.numeric(
                         gsub("t0$", "0",          # replace exact "t0" with "0"
                          gsub("t0-", "-", onset_timeline))  # replace "t0-" with "-"
                    )
                    ) %>%
                  column_to_rownames("Row.names")
# 307  25


orf.abundance.clean <- orf.abundance.table_0.75_prevFiltered %>%
                           select(c("Row.names",26:2992)) %>%
                           filter(Row.names %in% rownames(metadata.clean)) %>%
                           column_to_rownames("Row.names") %>% 
                           t(.) %>%
                           data.frame(.)
colnames(orf.abundance.clean) <- gsub("X","",colnames(orf.abundance.clean))
# 2967  307


# prepare correct variable format
metadata.clean$feeding_first_year <- factor(metadata.clean$feeding_first_year,levels = c("Breast_fed","Formula","Breastmilk_and_formula"))
# Breast_fed      Formula   Breastmilk_and_formula 
#    120             58              129 
metadata.clean$HLA.Category <- factor(metadata.clean$HLA.Category,levels = c("Standard Risk","High Risk","Low/No Risk"))
# Standard Risk     High Risk   Low/No Risk 
#      169            94            44
metadata.clean$Country <- factor(metadata.clean$Country,levels = c("ITALY","USA"))
# ITALY   USA 
#   110   197 
metadata.clean$Sex <- factor(metadata.clean$Sex,levels = c("Female","Male"))
# Female  Male 
#   238   69
metadata.clean$Delivery.Mode <- factor(metadata.clean$Delivery.Mode,levels = c("Vaginal","C-Section"))
# Vaginal C-Section 
# 217        90
metadata.clean$Age.at.Gluten.Introduction..months. <- as.numeric(metadata.clean$Age.at.Gluten.Introduction..months.)
# #  # 4  5  6  7  8  9 10 11 12 15 36 
# #  # 5 11 57 91 40 33 33 10  2 16  9 
metadata.clean$Dx.Status <- factor(metadata.clean$Dx.Status,levels = c("CELIAC","CONTROL"))
# CONTROL  CELIAC 
#    162     145 


# since the number of parameters changed (onset_timeline as nonlinear numeric), so we need to re-evaluate the linearity of Age.at.Gluten.Introduction..months. variable

# treat Age.at.Gluten.Introduction..months. as linear
linear.model.design <- model.matrix(~ Dx.Status * ns(onset_timeline_numeric,df=3) + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
linear.model.fit <- voomLmFit(orf.abundance.clean,linear.model.design,block= metadata.clean$patientID,plot=FALSE)
linear.model.fit <- eBayes(linear.model.fit)
linear.model.fit.nonlinear <- linear.model.fit


# treat Age.at.Gluten.Introduction..months. as non-linear
nonlinear.model.design <- model.matrix(~ Dx.Status * ns(onset_timeline_numeric,df=3) + Country + Sex + ns(Age.at.Gluten.Introduction..months.,df=3) + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
nonlinear.model.fit <- voomLmFit(orf.abundance.clean,nonlinear.model.design,block= metadata.clean$patientID,plot=FALSE)
nonlinear.model.fit <- eBayes(nonlinear.model.fit)

#######################################################################################################################################
# check which model is better

# Manual computation of fitted values
fitted_linear <- linear.model.fit$coefficients %*% t(linear.model.design)  # Genes × Samples
fitted_spline <- nonlinear.model.fit$coefficients %*% t(nonlinear.model.design)

# calculate the residules for each genes
resid_linear <- orf.abundance.clean - fitted_linear
resid_spline <- orf.abundance.clean - fitted_spline

# compute residual sum of squares (RSS)
rss_linear <- rowSums(resid_linear^2)
rss_spline <- rowSums(resid_spline^2)


# get the sample size per gene
n <- ncol(orf.abundance.clean)
# get the number of model parameters for both models
k_linear <- ncol(linear.model.design)
k_spline <- ncol(nonlinear.model.design)

# given the formula of calculating AIC
# AIC = n * log(RSS / n) + 2 * k
# n = number of observations (samples)
# RSS = residual sum of squares per gene
# k = number of parameters used in the model

# calculate AICs for both models
aic_linear <- n * log(rss_linear / n) + 2 * k_linear
aic_spline <- n * log(rss_spline / n) + 2 * k_spline

# compare AICs of genes for both models
delta_aic <- aic_linear - aic_spline

# make a histogram plot to visualize how the differences of AIC scores distributed 
AIC_differences <- ggplot(data.frame(delta_aic), aes(delta_aic)) +
                  geom_histogram(binwidth = 1) +
                  labs("Gluten Age ΔAIC (Linear - Spline)", x = "ΔAIC: Positive = spline better")

# calculate how many genes has AIC scores at least 2 points lower than linear model (ΔAIC > 2 is a common cutoff for "meaningful" improvement)
mean(delta_aic > 2)
# 0 (only 0% genes are better fit in splines model)
summary(delta_aic > 2)
#    Mode   FALSE 
# logical    2967 

# Conclusion: use linear model
########################################################################################################################################
colnames(linear.model.fit)
#  [1] "(Intercept)"                                          "Dx.StatusCONTROL"                                    
#  [3] "ns(onset_timeline_numeric, df = 3)1"                  "ns(onset_timeline_numeric, df = 3)2"                 
#  [5] "ns(onset_timeline_numeric, df = 3)3"                  "CountryUSA"                                          
#  [7] "SexMale"                                              "Age.at.Gluten.Introduction..months."                 
#  [9] "HLA.CategoryHigh Risk"                                "HLA.CategoryLow/No Risk"                             
# [11] "feeding_first_yearFormula"                            "feeding_first_yearBreastmilk_and_formula"            
# [13] "Delivery.ModeC-Section"                               "Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)1"
# [15] "Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)2" "Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)3"

########################################################################################################################################


model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)1",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)1",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2769
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)2",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)2",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)3",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)3",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2745

# Define gene of interest
selected_gene <- rownames(sig.model.res)


# Subset design matrix and model coefficients for prediction
linear.model.design <- model.matrix(~ Dx.Status * ns(onset_timeline_numeric,df=3) + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)

trajectory_plot_list <- list()


for (i in selected_gene){
  
   # Extract observed abundance vector for gene i
  gene_abundance <- orf.abundance.clean[i, ]

  # Create metadata + model prediction + observed abundance
  predicted_df <- metadata.clean %>%
    mutate(predicted_abundance = as.numeric(linear.model.design %*% linear.model.fit$coefficients[i, ]),
           observed_abundance = as.numeric(gene_abundance))

  # Count non-zero samples and total abundance per group and time
  count_df <- predicted_df %>%
    group_by(onset_timeline_numeric, Dx.Status) %>%
    summarise(
      non_zero_n = sum(observed_abundance > 0, na.rm = TRUE),
      total_reads = sum(observed_abundance, na.rm = TRUE),
      .groups = "drop"
    )

  # Get mean predicted values per group and time
  plot_df_pred <- predicted_df %>%
    group_by(onset_timeline_numeric, Dx.Status) %>%
    summarise(mean_pred = mean(predicted_abundance, na.rm = TRUE), .groups = "drop") %>%
    left_join(count_df, by = c("onset_timeline_numeric", "Dx.Status"))

  # Label showing both counts
  plot_df_pred <- plot_df_pred %>%
    mutate(label_text = paste0("n=", non_zero_n, "\nreads=", round(total_reads)))

  # Plot with annotations for sample count and total reads
  p <- ggplot(plot_df_pred, aes(x = onset_timeline_numeric, y = mean_pred, color = Dx.Status)) +
    geom_line(size = 1.2) +
    geom_point(size = 2) +
    geom_text(aes(label = label_text), vjust = -0.5, size = 3) +
    labs(title = paste("Model-Predicted Abundance for", i),
         x = "Months before onset", y = "Predicted Abundance (logCPM)") +
    theme(legend.position = "none")

  # Store in list
  trajectory_plot_list[[i]] <- p
}



# Pick 10 plots
plot_subset <- trajectory_plot_list[301:400]  # or use names: trajectory_plot_list[c("gene1", "gene2", ...)]

# Combine into grid: 2 rows × 5 columns
grid_plot <- wrap_plots(plot_subset, nrow = 10, ncol = 10)

# Show the grid
grid_plot

ggsave(grid_plot,file=paste0("~/Downloads/test_trajectory4.pdf"),dpi = 600,width = 20,height=20)



########################################################################################################################################
model.res <- topTable(linear.model.fit,coef="ns(onset_timeline_numeric, df = 3)1",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="ns(onset_timeline_numeric, df = 3)1",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="ns(onset_timeline_numeric, df = 3)2",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="ns(onset_timeline_numeric, df = 3)2",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 39
model.res <- topTable(linear.model.fit,coef="ns(onset_timeline_numeric, df = 3)3",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="ns(onset_timeline_numeric, df = 3)3",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 70

########################################################################################################################################
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
#################################################################################################

model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2523
model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 3
model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6


```




Model 5: treat onset_timeline as a categorical variable: modifying onset_timeline by combining the to-42M to t0-72M as one names "t0-over42"
~ Dx.Status * onset_timeline_combined + RunNumber + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode, block = patientID
```{r}

# prepare correct variable format
metadata.clean$feeding_first_year <- factor(metadata.clean$feeding_first_year,levels = c("Breast_fed","Formula","Breastmilk_and_formula"))
# Breast_fed      Formula   Breastmilk_and_formula 
#    120             58              129 
metadata.clean$HLA.Category <- factor(metadata.clean$HLA.Category,levels = c("Standard Risk","High Risk","Low/No Risk"))
# Standard Risk     High Risk   Low/No Risk 
#      169            94            44
metadata.clean$Country <- factor(metadata.clean$Country,levels = c("ITALY","USA"))
# ITALY   USA 
#   110   197 
metadata.clean$Sex <- factor(metadata.clean$Sex,levels = c("Female","Male"))
# Female  Male 
#   238   69
metadata.clean$Delivery.Mode <- factor(metadata.clean$Delivery.Mode,levels = c("Vaginal","C-Section"))
# Vaginal C-Section 
# 217        90
metadata.clean$Dx.Status <- factor(metadata.clean$Dx.Status,levels = c("CELIAC","CONTROL"))
# CONTROL  CELIAC 
#    162     145 
metadata.clean$onset_timeline_combined <- factor(metadata.clean$onset_timeline_combined,levels = c("t0","t0-6","t0-12","t0-18","t0-24","t0-30","t0-36","t0-over42"))
 # t0      t0-6     t0-12     t0-18     t0-24     t0-30     t0-36 t0-over42 
 # 64        30        46        27        32        29        33        46 
metadata.clean$Age.at.Gluten.Introduction..months. <- as.numeric(metadata.clean$Age.at.Gluten.Introduction..months.)
# 4  5  6  7  8  9 10 11 12 15 36 
# 5 11 57 91 40 33 33 10  2 16  9 


# after combine the late timepoints of onset_timeline, the distribution is like below:
table(metadata.clean$Dx.Status, metadata.clean$onset_timeline_combined) %>% t(.)
#             CELIAC CONTROL
# t0            31      33
# t0-6          14      16
# t0-12         21      25
# t0-18         12      15
# t0-24         14      18
# t0-30         14      15
# t0-36         16      17
# t0-over42     23      23

# since the number of parameters changed (less levels in onset_timeline_combined variable), so we need to re-evaluate the linearity of Age.at.Gluten.Introduction..months. variable

# treat Age.at.Gluten.Introduction..months. as linear
linear.model.design <- model.matrix(~ Dx.Status * onset_timeline_combined + RunNumber + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
linear.model.fit <- voomLmFit(orf.abundance.clean,linear.model.design,block= metadata.clean$patientID,plot=FALSE)
linear.model.fit <- eBayes(linear.model.fit)
linear.model.fit.factor <- linear.model.fit

########################################################################################################################################

colnames(linear.model.fit)
#  [1] "(Intercept)"                                       "Dx.StatusCONTROL"                                  "onset_timeline_combinedt0-12"                     
#  [4] "onset_timeline_combinedt0-18"                      "onset_timeline_combinedt0-24"                      "onset_timeline_combinedt0-30"                     
#  [7] "onset_timeline_combinedt0-36"                      "onset_timeline_combinedt0-6"                       "onset_timeline_combinedt0-over42"                 
# [10] "CountryUSA"                                        "SexMale"                                           "Age.at.Gluten.Introduction..months."              
# [13] "HLA.CategoryHigh Risk"                             "HLA.CategoryLow/No Risk"                           "feeding_first_yearFormula"                        
# [16] "feeding_first_yearBreastmilk_and_formula"          "Delivery.ModeC-Section"                            "Dx.StatusCONTROL:onset_timeline_combinedt0-12"    
# [19] "Dx.StatusCONTROL:onset_timeline_combinedt0-18"     "Dx.StatusCONTROL:onset_timeline_combinedt0-24"     "Dx.StatusCONTROL:onset_timeline_combinedt0-30"    
# [22] "Dx.StatusCONTROL:onset_timeline_combinedt0-36"     "Dx.StatusCONTROL:onset_timeline_combinedt0-6"      "Dx.StatusCONTROL:onset_timeline_combinedt0-over42"         

model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-6",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-6",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-12",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-12",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-18",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-18",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-24",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-24",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-30",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-30",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-36",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-36",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(sig.model.res)
# 469
sig.factor <- rownames(sig.model.res)

model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-over42",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-over42",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(sig.model.res)
# 1432

# hist(sig.model.res$adj.P.Val, breaks = 50) # the shape looks valid
# hist(model.res$adj.P.Val, breaks = 50, col = "gray", main = "All Adjusted P-Values") # the shape looks valid as well

###########################################################################################################################


model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-6",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-6",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-12",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-12",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-18",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-18",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-24",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-24",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-30",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-30",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-36",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-36",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-over42",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-over42",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0

#################################################################################################

model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0

#################################################################################################

model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 20
model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0

```




compare the factor model, linear model, and splines model
```{r}

factor.model.design <- model.matrix(~ Dx.Status * onset_timeline_combined + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)

linear.model.design <- model.matrix(~ Dx.Status * onset_timeline_numeric + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)

nonlinear.model.design <- model.matrix(~ Dx.Status * ns(onset_timeline_numeric,df=3) + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)


fit_factor <- eBayes(voomLmFit(orf.abundance.clean, factor.model.design, block = metadata.clean$patientID, plot = FALSE))
fit_linear <- eBayes(voomLmFit(orf.abundance.clean, linear.model.design, block = metadata.clean$patientID, plot = FALSE))
fit_spline <- eBayes(voomLmFit(orf.abundance.clean, nonlinear.model.design, block = metadata.clean$patientID, plot = FALSE))


# Residuals
resid_factor <- residuals(fit_factor, orf.abundance.clean)
resid_linear <- residuals(fit_linear, orf.abundance.clean)
resid_spline <- residuals(fit_spline, orf.abundance.clean)

# RSS
rss_factor <- rowSums(resid_factor^2)
rss_linear <- rowSums(resid_linear^2)
rss_spline <- rowSums(resid_spline^2)


# Parameters
n <- ncol(orf.abundance.clean)  # Number of samples
kf <- ncol(factor.model.design)
kl <- ncol(linear.model.design)
ks <- ncol(nonlinear.model.design)

# AIC
aic_factor <- n * log(rss_factor / n) + 2 * kf
aic_linear <- n * log(rss_linear / n) + 2 * kl
aic_spline <- n * log(rss_spline / n) + 2 * ks

# For each gene, which model has the lowest AIC?
best_model <- apply(cbind(aic_factor, aic_linear,aic_spline), 1, which.min)


# Tabulate
table(best_model)
 #   1    2     3 
 #  234  2678   55 

# Optional: Proportion of genes preferring each
data.frame(prop.table(table(best_model)))
#          1          2          3 
# 0.07886754 0.90259521 0.01853724 


df <- data.frame(prop.table(table(best_model)))
df$best_model <- factor(df$best_model,levels = c(1, 2, 3), labels = c("factor", "linear", "spline"))

p.best_model <- ggplot(df, aes(x = best_model, y = Freq)) +
  geom_bar(stat = "identity", fill = "steelblue") +
  labs(x = "Best Model", y = "Frequency") +
  theme_minimal()

ggsave(p.best_model,file ="~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/p.best_model.pdf",dpi = 600,width = 6, height = 6)

# So, the linear model won.

```



permutation test
```{r}

set.seed(123)
metadata.permuted <- metadata.clean

n_permutations <- 100
sig_counts <- numeric(n_permutations)

for (i in 1:n_permutations) {
  # 1. Shuffle the condition labels
  metadata.permuted$Dx.Status <- sample(metadata.permuted$Dx.Status)
  
  # 3. Build design matrix with permuted status
  design <- model.matrix(~ Dx.Status * onset_timeline_numeric + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.permuted)
  
v <- voomLmFit(orf.abundance.clean,design,block= metadata.permuted$patientID,plot=FALSE)
fit <- eBayes(v)
top <- topTable(fit, coef = "Dx.StatusCONTROL:onset_timeline_numeric", number = Inf) 

  sig_counts[i] <- sum(top$adj.P.Val < 0.05)
}


# Visualize the null distribution
hist(sig_counts, main = "Empirical Null: Significant ORFs per Permutation", xlab = "Number of significant ORFs (FDR < 0.05)")

# Compare to your real result
abline(v = num_real_sig, col = "red", lwd = 2)  # replace num_real_sig with your real value




```



# volcano plot and heatmap
```{r}

significant_gene_function_table <- read_delim("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/phold_per_cds_predictions.tsv") %>%
          select(`cds_id`,`phrog`,`function`,`product`) %>%
          column_to_rownames("cds_id") %>%
          merge(model.res,by = 0)


# make volcano plots for the significant genes

# Add significance categories
significant_gene_function_table$significant <- significant_gene_function_table$adj.P.Val < 0.05
significant_gene_function_table$highly_significant <- significant_gene_function_table$adj.P.Val < 0.001
significant_gene_function_table$neg_log10_padj <- -log10(significant_gene_function_table$adj.P.Val)


# FLIP THE SIGN of logFC to switch axis orientation
significant_gene_function_table$logFC_flipped <- -significant_gene_function_table$logFC


# Create significance labels
significant_gene_function_table$significance_label <- "Not Significant"
significant_gene_function_table$significance_label[significant_gene_function_table$significant] <- "Significant (adj.p < 0.05)"
significant_gene_function_table$significance_label[significant_gene_function_table$highly_significant] <- "Highly Significant (adj.p < 0.001)"



significant_gene_function_table$significance_label <- factor(significant_gene_function_table$significance_label,
                                          levels = c("Not Significant",
                                                    "Significant (adj.p < 0.05)",
                                                    "Highly Significant (adj.p < 0.001)"))

# Define colors
colors <- c("Not Significant" = "grey70",
           "Significant (adj.p < 0.05)" = "#E31A1C",
           "Highly Significant (adj.p < 0.001)" = "#B2182B")

# Create volcano plot
total_dataset_volcano_plot <- ggplot(significant_gene_function_table, aes(x = logFC_flipped, y = neg_log10_padj)) +
  geom_point(aes(color = significance_label), size = 0.8, alpha = 0.7) +
  scale_color_manual(values = colors, name = "Significance") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red", alpha = 0.7) +
  geom_hline(yintercept = -log10(0.001), linetype = "dashed", color = "darkred", alpha = 0.7) +
  labs(
    title = "Viral ORF Differential Abundance: CONTROL vs CELIAC",
    x = "Log2 Fold Change (CONTROL vs CELIAC)",
    y = "-Log10(Adjusted P-value)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    legend.position = "bottom"
  )

# Save plot
ggsave(total_dataset_volcano_plot, file="~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/compositonal_analysis/total_cohort_noTemporalFilter_volcano_plot.pdf", width = 8, height = 8, dpi = 300)


######################### color the points based on gene functions ##############################

# Clean up function names and create simplified categories
significant_gene_function_table$`function`[is.na(significant_gene_function_table$`function`)] <- "unknown function"
significant_gene_function_table$`function`[significant_gene_function_table$`function` == ""] <- "unknown function"


# Create simplified functional categories for better visualization
significant_gene_function_table$func_category <- significant_gene_function_table$`function`
significant_gene_function_table$func_category[grepl("DNA|RNA|nucleotide|replication",
significant_gene_function_table$`function`, ignore.case = TRUE)] <- "DNA/RNA metabolism"
significant_gene_function_table$func_category[grepl("head|packaging|capsid",
significant_gene_function_table$`function`, ignore.case = TRUE)] <- "Head & packaging"
significant_gene_function_table$func_category[grepl("tail|fiber", significant_gene_function_table$`function`,ignore.case = TRUE)] <- "Tail"
significant_gene_function_table$func_category[grepl("lysis|holin", significant_gene_function_table$`function`,ignore.case = TRUE)] <- "Lysis"
significant_gene_function_table$func_category[grepl("transcription|regulation",
significant_gene_function_table$`function`, ignore.case = TRUE)] <- "Transcription"
significant_gene_function_table$func_category[grepl("integration|excision|recombination",
significant_gene_function_table$`function`, ignore.case = TRUE)] <- "Integration/excision"
significant_gene_function_table$func_category[grepl("connector", significant_gene_function_table$`function`,ignore.case = TRUE)] <- "Connector"
significant_gene_function_table$func_category[grepl("unknown|hypothetical",significant_gene_function_table$`function`, ignore.case = TRUE)] <- "Unknown function"
significant_gene_function_table$func_category[grepl("other", significant_gene_function_table$`function`,ignore.case = TRUE)] <- "Other"

# Count functions and keep only top categories, group rare ones as 
"Other"
func_counts <- table(significant_gene_function_table$func_category)
top_functions <- names(sort(func_counts, decreasing = TRUE))[1:8]  # Keep top 8
significant_gene_function_table$func_category[!significant_gene_function_table$func_category %in% top_functions] <- "Other/Rare"

# Create color palette for functions
func_colors <- c(
"DNA/RNA metabolism" = "#1f77b4",
"Head & packaging" = "#ff7f0e",
"Tail" = "#2ca02c",
"Unknown function" = "#d62728",
"Lysis" = "#9467bd",
"Transcription" = "#8c564b",
"Integration/excision" = "#e377c2",
"Connector" = "#7f7f7f",
"Other" = "#bcbd22",
"Other/Rare" = "#17becf"
)



# Create volcano plot colored by function
total_dataset_volcano_plot_color_by_function <- ggplot(significant_gene_function_table, aes(x = logFC_flipped, y = neg_log10_padj)) +
                              geom_point(data = significant_gene_function_table %>% filter(adj.P.Val < 0.05), aes(color = func_category), size = 0.8, alpha = 0.7) +
                              geom_point(data = significant_gene_function_table %>% filter(adj.P.Val >= 0.05),color = "gray",size = 0.8, alpha = 0.7)+ 
                              scale_color_manual(values = func_colors, name = "Gene Function") +
                              geom_hline(yintercept = -log10(0.05), linetype = "dashed", color =
                              "black", alpha = 0.5) +
                              geom_hline(yintercept = -log10(0.001), linetype = "dashed", color =
                              "black", alpha = 0.7) +
                              labs(
                                title = "Viral ORF Differential Abundance by Gene Function",
                                subtitle = paste("Total:", nrow(significant_gene_function_table), "ORFs | Significant:",
                              sum(significant_gene_function_table$significant), "ORFs (adj.p < 0.05)"),
                                x = "Log2 Fold Change (CONTROL vs CELIAC)",
                                y = "-Log10(Adjusted P-value)",
                                caption = "Negative logFC = Higher in CONTROL, Lower in CELIAC"
                              ) +
                              theme_minimal() +
                              theme(
                                plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
                                plot.subtitle = element_text(size = 11, hjust = 0.5),
                                legend.position = "right",
                                legend.title = element_text(size = 11, face = "bold"),
                                panel.grid.minor = element_blank()
                              )

ggsave(total_dataset_volcano_plot_color_by_function,file="~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/compositonal_analysis/total_cohort_noTemporalFilter_volcano_plot_color_by_function.pdf", width = 8, height = 8, dpi = 300)

function.table <- significant_gene_function_table %>% filter(adj.P.Val < 0.05) %>% select(c("Row.names","phrog","function","product"))
write.csv(function.table,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/compositonal_analysis/total_cohort_noTemporalFilter_function_table.csv",quote = FALSE,row.names = FALSE)




######################### heatmap for all the significant orfs (stopped here)##############################


color_palette <- colorRampPalette(c("#2166AC", "#4393C3", "#92C5DE","#D1E5F0","white","#FDBF6F", "#FF7F00","#E31A1C","#B2182B"))(100)

max_abs_val <- max(abs(ordered_temporal_data), na.rm = TRUE)
break_range <- min(max_abs_val, 4)
breaks <- seq(-break_range, break_range, length.out = 101)

pheatmap(
  ordered_temporal_data,
  cluster_rows = FALSE,  # Already ordered by pattern clusters
  cluster_cols = FALSE,
  scale = "none",
  color = color_palette,
  main = paste("Pattern-Clustered Temporal Analysis:",
nrow(ordered_temporal_data), "Significant ORFs\n",
               "(", optimal_k, "pattern clusters, ordered by temporal 
trends)"),
  fontsize = 8,
  fontsize_row = 0,  # No row names due to size
  fontsize_col = 12,
  show_rownames = FALSE,
  breaks = breaks,
  na_col = "grey90",
  annotation_row = annotation_row,
  annotation_colors = annotation_colors,
  annotation_legend = TRUE,
  border_color = NA
)

```





                                              #########################################################################
                                              #      Limma model on 3% pravelance filtered + temporal filtered data   #   
                                              #         orf.abundance.table_0.75_prevFiltered_temporal  (2154 orfs)   #
                                              #########################################################################
                                              

Model 1: treating onset_timeline as a factor
~ Dx.Status * onset_timeline + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode, block = patientID
```{r}

# prepare clean metadata
metadata.clean <- orf.abundance.table_0.75_prevFiltered_temporal[1:25] %>%
                  column_to_rownames("Row.names")
dim(metadata.clean)
# 306  24

orf.abundance.clean <- orf.abundance.table_0.75_prevFiltered_temporal %>%
                           select(c("Row.names",26:2179)) %>%
                           filter(Row.names %in% rownames(metadata.clean)) %>%
                           column_to_rownames("Row.names") %>% 
                           t(.) %>%
                           data.frame(.)
colnames(orf.abundance.clean) <- gsub("X","",colnames(orf.abundance.clean))
# 2154  306


# prepare correct variable format
metadata.clean$feeding_first_year <- factor(metadata.clean$feeding_first_year,levels = c("Breast_fed","Formula","Breastmilk_and_formula"))
# Breast_fed      Formula   Breastmilk_and_formula 
#    120             58              129 
metadata.clean$HLA.Category <- factor(metadata.clean$HLA.Category,levels = c("Standard Risk","High Risk","Low/No Risk"))
# Standard Risk     High Risk   Low/No Risk 
#      169            94            44
metadata.clean$Country <- factor(metadata.clean$Country,levels = c("ITALY","USA"))
# ITALY   USA 
#   110   197 
metadata.clean$Sex <- factor(metadata.clean$Sex,levels = c("Female","Male"))
# Female  Male 
#   238   69
metadata.clean$Delivery.Mode <- factor(metadata.clean$Delivery.Mode,levels = c("Vaginal","C-Section"))
# Vaginal C-Section 
# 217        90
metadata.clean$Dx.Status <- factor(metadata.clean$Dx.Status,levels = c("CELIAC","CONTROL"))
# CONTROL  CELIAC 
#    162     145 
metadata.clean$onset_timeline <- factor(metadata.clean$onset_timeline,levels = c("t0","t0-6","t0-12","t0-18","t0-24","t0-30","t0-36","t0-42","t0-48","t0-54","t0-60","t0-66","t0-72"))
# t0  t0-6 t0-12 t0-18 t0-24 t0-30 t0-36 t0-42 t0-48 t0-54 t0-60 t0-66 t0-72 
# 64    30    46    27    32    29    33    14    16     4     4     4     4 
metadata.clean$Age.at.Gluten.Introduction..months. <- as.numeric(metadata.clean$Age.at.Gluten.Introduction..months.)
# Here we treat Age.at.Gluten.Introduction..months. as numrical variable because:

# They have inherent order (4 < 5 < 6 < ... < 36)
# The differences between values are meaningful
# Thus, not categorical in nature, even if some values are sparse

# for this round we treat Age.at.Gluten.Introduction..months. as linear 


# before fitting the model, we better check if we have enough number of sample at each timepoint, if the number is too small, it may cause
# 1. The model can overfit or produce unstable estimates
# 2. Some interaction terms (e.g. Dx.StatusCELIAC:onset_timeline_t0-6) may be unestimable or have inflated standard errors.
# 3. Limma may drop these levels silently if they’re not estimable due to collinearity.
t(table(metadata.clean$Dx.Status,metadata.clean$onset_timeline))
  #      CELIAC CONTROL
  # t0        31      33
  # t0-6      14      16
  # t0-12     21      25
  # t0-18     12      15
  # t0-24     14      18
  # t0-30     14      15
  # t0-36     16      17
  # t0-42      7       7
  # t0-48      8       8
  # t0-54      2       2
  # t0-60      2       2
  # t0-66      2       2
  # t0-72      2       2

# As we see from the above table, from t0-42 to t0-72, there are too few of samples per group, (7 and 8 mightbe ok).
# We will go ahead and fit the model in this way first, then see how the model output.

# treat Age.at.Gluten.Introduction..months. as linear
linear.model.design <- model.matrix(~ Dx.Status * onset_timeline + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
linear.model.fit <- voomLmFit(orf.abundance.clean,linear.model.design,block= metadata.clean$patientID,plot=FALSE)
linear.model.fit <- eBayes(linear.model.fit)


# treat Age.at.Gluten.Introduction..months. as non-linear
nonlinear.model.design <- model.matrix(~ Dx.Status * onset_timeline + Country + Sex + ns(Age.at.Gluten.Introduction..months.,df=3) + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
nonlinear.model.fit <- voomLmFit(orf.abundance.clean,nonlinear.model.design,block= metadata.clean$patientID,plot=FALSE)
nonlinear.model.fit <- eBayes(nonlinear.model.fit)



#######################################################################################################################################
# check which model is better

# Manual computation of fitted values
fitted_linear <- linear.model.fit$coefficients %*% t(linear.model.design)  # Genes × Samples
fitted_spline <- nonlinear.model.fit$coefficients %*% t(nonlinear.model.design)

# calculate the residules for each genes
resid_linear <- orf.abundance.clean - fitted_linear
resid_spline <- orf.abundance.clean - fitted_spline

# compute residual sum of squares (RSS)
rss_linear <- rowSums(resid_linear^2)
rss_spline <- rowSums(resid_spline^2)


# get the sample size per gene
n <- ncol(orf.abundance.clean)
# get the number of model parameters for both models
k_linear <- ncol(linear.model.design)
k_spline <- ncol(nonlinear.model.design)

# given the formula of calculating AIC
# AIC = n * log(RSS / n) + 2 * k
# n = number of observations (samples)
# RSS = residual sum of squares per gene
# k = number of parameters used in the model

# calculate AICs for both models
aic_linear <- n * log(rss_linear / n) + 2 * k_linear
aic_spline <- n * log(rss_spline / n) + 2 * k_spline

# compare AICs of genes for both models
delta_aic <- aic_linear - aic_spline

# make a histogram plot to visualize how the differences of AIC scores distributed 
AIC_differences <- hist(delta_aic, breaks = 50, main = "ΔAIC (Linear - Spline)",
     xlab = "ΔAIC: Positive = spline better")

# calculate how many genes has AIC scores at least 2 points lower than linear model (ΔAIC > 2 is a common cutoff for "meaningful" improvement)
mean(delta_aic > 2)
# 0.0003249919 (only 0.03249919% genes are better fit in splines model)

# Conclusion: use linear model
########################################################################################################################################

colnames(linear.model.fit)
#  [1] "(Intercept)"                              "Dx.StatusCONTROL"                         "onset_timelinet0-6"                      
#  [4] "onset_timelinet0-12"                      "onset_timelinet0-18"                      "onset_timelinet0-24"                     
#  [7] "onset_timelinet0-30"                      "onset_timelinet0-36"                      "onset_timelinet0-42"                     
# [10] "onset_timelinet0-48"                      "onset_timelinet0-54"                      "onset_timelinet0-60"                     
# [13] "onset_timelinet0-66"                      "onset_timelinet0-72"                      "CountryUSA"                              
# [16] "SexMale"                                  "Age.at.Gluten.Introduction..months."      "HLA.CategoryHigh Risk"                   
# [19] "HLA.CategoryLow/No Risk"                  "feeding_first_yearFormula"                "feeding_first_yearBreastmilk_and_formula"
# [22] "Delivery.ModeC-Section"                   "Dx.StatusCONTROL:onset_timelinet0-6"      "Dx.StatusCONTROL:onset_timelinet0-12"    
# [25] "Dx.StatusCONTROL:onset_timelinet0-18"     "Dx.StatusCONTROL:onset_timelinet0-24"     "Dx.StatusCONTROL:onset_timelinet0-30"    
# [28] "Dx.StatusCONTROL:onset_timelinet0-36"     "Dx.StatusCONTROL:onset_timelinet0-42"     "Dx.StatusCONTROL:onset_timelinet0-48"    
# [31] "Dx.StatusCONTROL:onset_timelinet0-54"     "Dx.StatusCONTROL:onset_timelinet0-60"     "Dx.StatusCONTROL:onset_timelinet0-66"    
# [34] "Dx.StatusCONTROL:onset_timelinet0-72" 


model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-6",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-6",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-12",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-12",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-18",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-18",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-24",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-24",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-30",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-30",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2267
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-36",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-36",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2426
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-48",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-48",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2881
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-54",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-54",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-60",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-60",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 5
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-66",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-66",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-72",adjust.method = "BH",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timelinet0-72",adjust.method = "BH",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2547

# hist(sig.model.res$adj.P.Val, breaks = 50) # the shape looks valid
# hist(model.res$adj.P.Val, breaks = 50, col = "gray", main = "All Adjusted P-Values") # the shape looks valid as well

###########################################################################################################################


model.res <- topTable(linear.model.fit,coef="onset_timelinet0-6",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-6",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-12",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-12",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-18",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-18",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-24",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-24",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-30",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-30",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-36",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-36",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-48",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-48",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-60",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-60",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-66",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-66",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timelinet0-72",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timelinet0-72",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0

#################################################################################################

model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 1581 significant orf

#################################################################################################

model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2515
model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6


```



Model 2: modifying onset_timeline by combining the to-42M to t0-72M as one names "t0-over42"
~ Dx.Status * onset_timeline_combined + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode, block = patientID
```{r}


# prepare clean metadata
metadata.clean <- orf.abundance.table_0.75_prevFiltered_temporal[1:25]  %>%
                  mutate(onset_timeline_combined = ifelse(onset_timeline %in% c("t0-42","t0-48","t0-54","t0-60","t0-66","t0-72"),"t0-over42",onset_timeline)) %>%
                  column_to_rownames("Row.names")
# 306  24

orf.abundance.clean <- orf.abundance.table_0.75_prevFiltered_temporal %>%
                           select(c("Row.names",26:2179)) %>%
                           filter(Row.names %in% rownames(metadata.clean)) %>%
                           column_to_rownames("Row.names") %>% 
                           t(.) %>%
                           data.frame(.)
colnames(orf.abundance.clean) <- gsub("X","",colnames(orf.abundance.clean))
# 2154  306

# prepare correct variable format
metadata.clean$feeding_first_year <- factor(metadata.clean$feeding_first_year,levels = c("Breast_fed","Formula","Breastmilk_and_formula"))
# Breast_fed      Formula   Breastmilk_and_formula 
#    120             58              129 
metadata.clean$HLA.Category <- factor(metadata.clean$HLA.Category,levels = c("Standard Risk","High Risk","Low/No Risk"))
# Standard Risk     High Risk   Low/No Risk 
#      169            94            44
metadata.clean$Country <- factor(metadata.clean$Country,levels = c("ITALY","USA"))
# ITALY   USA 
#   110   197 
metadata.clean$Sex <- factor(metadata.clean$Sex,levels = c("Female","Male"))
# Female  Male 
#   238   69
metadata.clean$Delivery.Mode <- factor(metadata.clean$Delivery.Mode,levels = c("Vaginal","C-Section"))
# Vaginal C-Section 
# 217        90
metadata.clean$Dx.Status <- factor(metadata.clean$Dx.Status,levels = c("CELIAC","CONTROL"))
# CONTROL  CELIAC 
#    162     145 
metadata.clean$onset_timeline_combined <- factor(metadata.clean$onset_timeline_combined,levels = c("t0","t0-6","t0-12","t0-18","t0-24","t0-30","t0-36","t0-over42"))
 # t0      t0-6     t0-12     t0-18     t0-24     t0-30     t0-36 t0-over42 
 # 64        30        46        27        32        29        33        46 
metadata.clean$Age.at.Gluten.Introduction..months. <- as.numeric(metadata.clean$Age.at.Gluten.Introduction..months.)
# 4  5  6  7  8  9 10 11 12 15 36 
# 5 11 57 91 40 33 33 10  2 16  9 


# after combine the late timepoints of onset_timeline, the distribution is like below:
table(metadata.clean$Dx.Status, metadata.clean$onset_timeline_combined) %>% t(.)
  #           CELIAC CONTROL
  # t0            31      33
  # t0-6          14      16
  # t0-12         21      25
  # t0-18         12      15
  # t0-24         14      18
  # t0-30         14      14
  # t0-36         16      17
  # t0-over42     23      23

# since the number of parameters changed (less levels in onset_timeline_combined variable), so we need to re-evaluate the linearity of Age.at.Gluten.Introduction..months. variable

# treat Age.at.Gluten.Introduction..months. as linear
linear.model.design <- model.matrix(~ Dx.Status * onset_timeline_combined + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
linear.model.fit <- voomLmFit(orf.abundance.clean,linear.model.design,block= metadata.clean$patientID,plot=FALSE)
linear.model.fit <- eBayes(linear.model.fit)
linear.model.fit.factor <- linear.model.fit


# treat Age.at.Gluten.Introduction..months. as non-linear
nonlinear.model.design <- model.matrix(~ Dx.Status * onset_timeline_combined + Country + Sex + ns(Age.at.Gluten.Introduction..months.,df=3) + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
nonlinear.model.fit <- voomLmFit(orf.abundance.clean,nonlinear.model.design,block= metadata.clean$patientID,plot=FALSE)
nonlinear.model.fit <- eBayes(nonlinear.model.fit)



#######################################################################################################################################
# check which model is better

# Manual computation of fitted values
fitted_linear <- linear.model.fit$coefficients %*% t(linear.model.design)  # Genes × Samples
fitted_spline <- nonlinear.model.fit$coefficients %*% t(nonlinear.model.design)

# calculate the residules for each genes
resid_linear <- orf.abundance.clean - fitted_linear
resid_spline <- orf.abundance.clean - fitted_spline

# compute residual sum of squares (RSS)
rss_linear <- rowSums(resid_linear^2)
rss_spline <- rowSums(resid_spline^2)


# get the sample size per gene
n <- ncol(orf.abundance.clean)
# get the number of model parameters for both models
k_linear <- ncol(linear.model.design)
k_spline <- ncol(nonlinear.model.design)

# given the formula of calculating AIC
# AIC = n * log(RSS / n) + 2 * k
# n = number of observations (samples)
# RSS = residual sum of squares per gene
# k = number of parameters used in the model

# calculate AICs for both models
aic_linear <- n * log(rss_linear / n) + 2 * k_linear
aic_spline <- n * log(rss_spline / n) + 2 * k_spline

# compare AICs of genes for both models
delta_aic <- aic_linear - aic_spline

# make a histogram plot to visualize how the differences of AIC scores distributed 
AIC_differences <- hist(delta_aic, breaks = 50, main = "ΔAIC (Linear - Spline)",
     xlab = "ΔAIC: Positive = spline better")

# calculate how many genes has AIC scores at least 2 points lower than linear model (ΔAIC > 2 is a common cutoff for "meaningful" improvement)
mean(delta_aic > 2)
# 0.0009285051 (only 009285051% genes are better fit in splines model)

# Conclusion: use linear model
########################################################################################################################################

colnames(linear.model.fit)
#  [1] "(Intercept)"                                       "Dx.StatusCONTROL"                                  "onset_timeline_combinedt0-12"                     
#  [4] "onset_timeline_combinedt0-18"                      "onset_timeline_combinedt0-24"                      "onset_timeline_combinedt0-30"                     
#  [7] "onset_timeline_combinedt0-36"                      "onset_timeline_combinedt0-6"                       "onset_timeline_combinedt0-over42"                 
# [10] "CountryUSA"                                        "SexMale"                                           "Age.at.Gluten.Introduction..months."              
# [13] "HLA.CategoryHigh Risk"                             "HLA.CategoryLow/No Risk"                           "feeding_first_yearFormula"                        
# [16] "feeding_first_yearBreastmilk_and_formula"          "Delivery.ModeC-Section"                            "Dx.StatusCONTROL:onset_timeline_combinedt0-12"    
# [19] "Dx.StatusCONTROL:onset_timeline_combinedt0-18"     "Dx.StatusCONTROL:onset_timeline_combinedt0-24"     "Dx.StatusCONTROL:onset_timeline_combinedt0-30"    
# [22] "Dx.StatusCONTROL:onset_timeline_combinedt0-36"     "Dx.StatusCONTROL:onset_timeline_combinedt0-6"      "Dx.StatusCONTROL:onset_timeline_combinedt0-over42"         

model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-6",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-6",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-12",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-12",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-18",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-18",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-24",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-24",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-24",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-24",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-30",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-30",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 17
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-36",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-36",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 519
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-over42",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-over42",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 1666

# hist(sig.model.res$adj.P.Val, breaks = 50) # the shape looks valid
# hist(model.res$adj.P.Val, breaks = 50, col = "gray", main = "All Adjusted P-Values") # the shape looks valid as well

###########################################################################################################################


model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-6",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-6",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-12",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-12",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 14
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-18",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-18",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-24",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-24",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-30",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-30",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 3
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-36",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-36",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-over42",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_combinedt0-over42",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0

#################################################################################################

model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0


#################################################################################################

model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 1610
model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0

```




Model 3: create a numeric format of onset_timeline and make it onset_timeline_numeric assume it is linear in the model
~ Dx.Status * onset_timeline_numeric + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode, block = patientID
```{r}


# prepare clean metadata
metadata.clean <- orf.abundance.table_0.75_prevFiltered_temporal[1:25] %>%
                  column_to_rownames("Row.names")
# 299  24


orf.abundance.clean <- orf.abundance.table_0.75_prevFiltered_temporal %>%
                           select(c("Row.names",25:2084)) %>%
                           filter(Row.names %in% rownames(metadata.clean)) %>%
                           column_to_rownames("Row.names") %>% 
                           t(.) %>%
                           data.frame(.)
colnames(orf.abundance.clean) <- gsub("X","",colnames(orf.abundance.clean))
# 2084  299


# write.csv(orf.abundance.clean,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/total.orf.abundance.table_0.75_prevFiltered_temporal_cleaned.csv",quote = FALSE,row.names = TRUE)
# 
# write.csv(metadata.clean,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/total.metadata.cleaned.csv",quote = FALSE,row.names = TRUE)




# prepare correct variable format
metadata.clean$feeding_first_year <- factor(metadata.clean$feeding_first_year,levels = c("Breast_fed","Formula","Breastmilk_and_formula"))
# Breast_fed      Formula   Breastmilk_and_formula 
#    120             58              129 
metadata.clean$HLA.Category <- factor(metadata.clean$HLA.Category,levels = c("Standard Risk","High Risk","Low/No Risk"))
# Standard Risk     High Risk   Low/No Risk 
#      169            94            44
metadata.clean$Country <- factor(metadata.clean$Country,levels = c("ITALY","USA"))
# ITALY   USA 
#   110   197 
metadata.clean$Sex <- factor(metadata.clean$Sex,levels = c("Female","Male"))
# Female  Male 
#   238   69
metadata.clean$Delivery.Mode <- factor(metadata.clean$Delivery.Mode,levels = c("Vaginal","C-Section"))
# Vaginal C-Section 
# 217        90
metadata.clean$Age.at.Gluten.Introduction..months. <- as.numeric(metadata.clean$Age.at.Gluten.Introduction..months.)
# #  # 4  5  6  7  8  9 10 11 12 15 36 
# #  # 5 11 57 91 40 33 33 10  2 16  9 
metadata.clean$Dx.Status <- factor(metadata.clean$Dx.Status,levels = c("CELIAC","CONTROL"))
# CONTROL  CELIAC 
#    162     145 


# since the number of parameters changed (onset_timeline as linear numeric), so we need to re-evaluate the linearity of Age.at.Gluten.Introduction..months. variable

# treat Age.at.Gluten.Introduction..months. as linear
linear.model.design <- model.matrix(~ Dx.Status * onset_timeline_numeric + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
linear.model.fit <- voomLmFit(orf.abundance.clean,linear.model.design,block= metadata.clean$patientID,plot=FALSE)
linear.model.fit <- eBayes(linear.model.fit)
linear.model.fit.linear <- linear.model.fit


# treat Age.at.Gluten.Introduction..months. as non-linear
nonlinear.model.design <- model.matrix(~ Dx.Status * onset_timeline_numeric + Country + Sex + ns(Age.at.Gluten.Introduction..months.,df=3) + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
nonlinear.model.fit <- voomLmFit(orf.abundance.clean,nonlinear.model.design,block= metadata.clean$patientID,plot=FALSE)
nonlinear.model.fit <- eBayes(nonlinear.model.fit)


#######################################################################################################################################
# check which model is better

# Manual computation of fitted values
fitted_linear <- linear.model.fit$coefficients %*% t(linear.model.design)  # Genes × Samples
fitted_spline <- nonlinear.model.fit$coefficients %*% t(nonlinear.model.design)

# calculate the residules for each genes
resid_linear <- orf.abundance.clean - fitted_linear
resid_spline <- orf.abundance.clean - fitted_spline

# compute residual sum of squares (RSS)
rss_linear <- rowSums(resid_linear^2)
rss_spline <- rowSums(resid_spline^2)


# get the sample size per gene
n <- ncol(orf.abundance.clean)
# get the number of model parameters for both models
k_linear <- ncol(linear.model.design)
k_spline <- ncol(nonlinear.model.design)

# given the formula of calculating AIC
# AIC = n * log(RSS / n) + 2 * k
# n = number of observations (samples)
# RSS = residual sum of squares per gene
# k = number of parameters used in the model

# calculate AICs for both models
aic_linear <- n * log(rss_linear / n) + 2 * k_linear
aic_spline <- n * log(rss_spline / n) + 2 * k_spline

# compare AICs of genes for both models
delta_aic <- aic_linear - aic_spline

# make a histogram plot to visualize how the differences of AIC scores distributed 
AIC_differences <- hist(delta_aic, breaks = 50, main = "ΔAIC (Linear - Spline)",
     xlab = "ΔAIC: Positive = spline better")

# calculate how many genes has AIC scores at least 2 points lower than linear model (ΔAIC > 2 is a common cutoff for "meaningful" improvement)
mean(delta_aic > 2)
# 0 (only 0 genes are better fit in splines model)

# Conclusion: use linear model
########################################################################################################################################
colnames(linear.model.fit)
#  [1] "(Intercept)"                              "Dx.StatusCONTROL"                         "onset_timeline_numeric"                  
#  [4] "CountryUSA"                               "SexMale"                                  "Age.at.Gluten.Introduction..months."     
#  [7] "HLA.CategoryHigh Risk"                    "HLA.CategoryLow/No Risk"                  "feeding_first_yearFormula"               
# [10] "feeding_first_yearBreastmilk_and_formula" "Delivery.ModeC-Section"                   "Dx.StatusCONTROL:onset_timeline_numeric" 

model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_numeric",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_numeric",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 170

# write.csv(model.res,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data/total/total_limma_results.csv",quote = FALSE,row.names = TRUE)


# lable the spurious genes

# --- Parameters you can adjust ---
min_timepoints_with_signal <- 3
min_samples_per_timepoint <- 2
min_total_reads_per_group <- 1000

# --- Function to assess one virus ---
flag_virus <- function(gene_name, abundance_table, metadata, time_col = "onset_timeline_numeric") {
  # Extract abundance
  gene_abund <- abundance_table[gene_name, , drop = FALSE]
  gene_abund <- as.numeric(gene_abund)
  
  # Combine with metadata
  df <- metadata %>%
    mutate(abund = gene_abund,
           reads = 2^abund - 1)  # assuming log2(CPM+1), convert back
  
  # Count non-zero samples and reads per time x group
  signal_stats <- df %>%
    group_by(!!sym(time_col), Dx.Status) %>%
    summarise(n_nonzero = sum(abund > 0, na.rm = TRUE),
              total_reads = sum(reads[abund > 0], na.rm = TRUE),
              .groups = "drop")
  
  # Timepoints with at least X non-zero samples
  valid_timepoints <- signal_stats %>%
    filter(n_nonzero >= min_samples_per_timepoint) %>%
    group_by(Dx.Status) %>%
    summarise(n_timepoints_with_signal = n(), .groups = "drop")
  
  # Total reads per group
  read_totals <- signal_stats %>%
    group_by(Dx.Status) %>%
    summarise(total_reads = sum(total_reads), .groups = "drop")
  
  # Flag if any group fails any of the thresholds
  flagged <- any(
    valid_timepoints$n_timepoints_with_signal < min_timepoints_with_signal |
    read_totals$total_reads < min_total_reads_per_group
  )
  
  return(flagged)
}

# --- Apply to all significant genes ---
flagged_results <- sapply(rownames(sig.model.res), function(gene) {
  flag_virus(gene, orf.abundance.clean, metadata.clean)
})

# Get flagged gene names
flagged_genes <- names(flagged_results)[flagged_results]
# 1398 genes


# plot the flagged genes

library(tidyverse)
library(reshape2)
library(pheatmap)

# Subset abundance matrix to spurious genes
spurious_abund <- orf.abundance.clean[rownames(orf.abundance.clean) %in% rownames(orf.abundance.clean), ] #flagged_genes

# ---------------------------
# Summary statistics
# ---------------------------
# 1. Sparsity (proportion of samples with 0 counts)
sparsity <- rowMeans(spurious_abund == 0, na.rm = TRUE)

# 2. Max count per gene
max_count <- apply(spurious_abund, 1, max, na.rm = TRUE)

# 3. Number of time bins with ≥2 non-zero samples
temporal_support <- function(gene_row, metadata, min_nonzero = 2) {
  df <- data.frame(value = gene_row, time = metadata$onset_timeline_numeric)
  df$nonzero <- df$value > 0
  by_bin <- df %>% group_by(time) %>% summarise(nonzero_n = sum(nonzero, na.rm = TRUE))
  sum(by_bin$nonzero_n >= min_nonzero)
}
support_counts <- apply(spurious_abund, 1, temporal_support, metadata = metadata.clean)

# Combine summary
spurious_summary <- data.frame(
  Gene = rownames(spurious_abund),
  Sparsity = sparsity,
  MaxCount = max_count,
  TimeBinsWithSupport = support_counts
)

# ---------------------------
# Plot distributions
# ---------------------------
# Histogram of sparsity
ggplot(spurious_summary, aes(x = Sparsity)) +
  geom_histogram(bins = 30, fill = "tomato") +
  labs(title = "Sparsity of Spurious Genes", x = "Proportion of 0 Counts", y = "Number of Genes") +
  theme_minimal()

# Histogram of time bin support
ggplot(spurious_summary, aes(x = TimeBinsWithSupport)) +
  geom_histogram(binwidth = 1, fill = "steelblue") +
  labs(title = "Temporal Support of Spurious Genes", x = "# Time Bins with ≥2 Non-zero", y = "Number of Genes") +
  theme_minimal()

# ---------------------------
# Heatmap for inspection (top 50 sparse genes)
# ---------------------------
top_sparse <- head(order(sparsity, decreasing = TRUE), 50)
pheatmap(spurious_abund[top_sparse, ], scale = "row", show_rownames = FALSE,
         main = "Spurious Genes - Top Sparse Profiles")



# plot trajectory for those reliable genes
#selected_gene <- rownames(sig.model.res)[!rownames(sig.model.res) %in% flagged_genes]
# 447 genes are reliable

selected_gene <- rownames(sig.model.res)
# 170 genes are significant

# Subset design matrix and model coefficients for prediction
linear.model.design <- model.matrix(~ Dx.Status * onset_timeline_numeric + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)

trajectory_plot_list <- list()


for (i in selected_gene){
  
   # Extract observed abundance vector for gene i
  gene_abundance <- orf.abundance.clean[i, ]

  # Create metadata + model prediction + observed abundance
  predicted_df <- metadata.clean %>%
    mutate(predicted_abundance = as.numeric(linear.model.design %*% linear.model.fit$coefficients[i, ]),
           observed_abundance = as.numeric(gene_abundance))

  # Count non-zero samples and total abundance per group and time
  count_df <- predicted_df %>%
    group_by(onset_timeline_numeric, Dx.Status) %>%
    summarise(
      non_zero_n = sum(observed_abundance > 0, na.rm = TRUE),
      total_reads = sum(observed_abundance, na.rm = TRUE),
      .groups = "drop"
    )

  # Get mean predicted values per group and time
  plot_df_pred <- predicted_df %>%
  left_join(count_df, by = c("onset_timeline_numeric", "Dx.Status")) %>%
  group_by(onset_timeline_numeric, Dx.Status) %>%
  summarise(
    mean_pred = mean(predicted_abundance, na.rm = TRUE),
    non_zero_n = first(non_zero_n),      # from count_df
    total_reads = first(total_reads),    # from count_df
    .groups = "drop"
  ) %>%
  mutate(mean_pred = ifelse(non_zero_n == 0 & total_reads == 0, NA, mean_pred))

  # Label showing both counts
  plot_df_pred <- plot_df_pred %>%
    mutate(label_text = paste0("n=", non_zero_n, "\nreads=", round(total_reads)))

  # Plot with annotations for sample count and total reads
  p <- ggplot(plot_df_pred, aes(x = onset_timeline_numeric, y = mean_pred, color = Dx.Status)) +
    geom_line(size = 1.2) +
    geom_point(size = 2) +
    geom_text(aes(label = label_text), vjust = -0.5, size = 3) +
    labs(title = i,
         x = "Months before onset", y = "Predicted Abundance (logCPM)") +
    theme(legend.position = "none")

  # Store in list
  trajectory_plot_list[[i]] <- p
}

dev.off()
trajectory_plot_list[5]


# Pick 10 plots
plot_subset <- trajectory_plot_list[1:170]  # or use names: trajectory_plot_list[c("gene1", "gene2", ...)]
# Combine into grid: 2 rows × 5 columns
grid_plot <- wrap_plots(plot_subset)
ggsave(grid_plot,file=paste0("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/total_trajectory_75_3prev_temporal_clear.pdf"),dpi = 600,width = 60,height=60,limitsize = FALSE)



# hist(sig.model.res$adj.P.Val, breaks = 50) # the shape looks valid
# hist(model.res$adj.P.Val, breaks = 50, col = "gray", main = "All Adjusted P-Values") # the shape looks valid as well

###########################################################################################################################

model.res <- topTable(linear.model.fit,coef="onset_timeline_numeric",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_numeric",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0

#################################################################################################

model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2066


#################################################################################################

model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2034
model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6


```




Model 4: create a numeric format of onset_timeline and make it onset_timeline_numeric assume it is nonlinear in the model
~ Dx.Status * ns(onset_timeline_numeric,df=3) + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode, block = patientID
```{r}


# prepare clean metadata
metadata.clean <- orf.abundance.table_0.75_prevFiltered_temporal[1:25] %>%
                  mutate(onset_timeline_numeric = as.numeric(
                         gsub("t0$", "0",          # replace exact "t0" with "0"
                          gsub("t0-", "-", onset_timeline))  # replace "t0-" with "-"
                    )
                    ) %>%
                  column_to_rownames("Row.names")
# 306  24


orf.abundance.clean <- orf.abundance.table_0.75_prevFiltered_temporal %>%
                           select(c("Row.names",26:2179)) %>%
                           filter(Row.names %in% rownames(metadata.clean)) %>%
                           column_to_rownames("Row.names") %>% 
                           t(.) %>%
                           data.frame(.)
colnames(orf.abundance.clean) <- gsub("X","",colnames(orf.abundance.clean))
# 2154  306


# prepare correct variable format
metadata.clean$feeding_first_year <- factor(metadata.clean$feeding_first_year,levels = c("Breast_fed","Formula","Breastmilk_and_formula"))
# Breast_fed      Formula   Breastmilk_and_formula 
#    120             58              129 
metadata.clean$HLA.Category <- factor(metadata.clean$HLA.Category,levels = c("Standard Risk","High Risk","Low/No Risk"))
# Standard Risk     High Risk   Low/No Risk 
#      169            94            44
metadata.clean$Country <- factor(metadata.clean$Country,levels = c("ITALY","USA"))
# ITALY   USA 
#   110   197 
metadata.clean$Sex <- factor(metadata.clean$Sex,levels = c("Female","Male"))
# Female  Male 
#   238   69
metadata.clean$Delivery.Mode <- factor(metadata.clean$Delivery.Mode,levels = c("Vaginal","C-Section"))
# Vaginal C-Section 
# 217        90
metadata.clean$Age.at.Gluten.Introduction..months. <- as.numeric(metadata.clean$Age.at.Gluten.Introduction..months.)
# #  # 4  5  6  7  8  9 10 11 12 15 36 
# #  # 5 11 57 91 40 33 33 10  2 16  9 
metadata.clean$Dx.Status <- factor(metadata.clean$Dx.Status,levels = c("CELIAC","CONTROL"))
# CONTROL  CELIAC 
#    162     145 


# since the number of parameters changed (onset_timeline as nonlinear numeric), so we need to re-evaluate the linearity of Age.at.Gluten.Introduction..months. variable

# treat Age.at.Gluten.Introduction..months. as linear
linear.model.design <- model.matrix(~ Dx.Status * ns(onset_timeline_numeric,df=3) + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
linear.model.fit <- voomLmFit(orf.abundance.clean,linear.model.design,block= metadata.clean$patientID,plot=FALSE)
linear.model.fit <- eBayes(linear.model.fit)
linear.model.fit.nonlinear <- linear.model.fit


# treat Age.at.Gluten.Introduction..months. as non-linear
nonlinear.model.design <- model.matrix(~ Dx.Status * ns(onset_timeline_numeric,df=3) + Country + Sex + ns(Age.at.Gluten.Introduction..months.,df=3) + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
nonlinear.model.fit <- voomLmFit(orf.abundance.clean,nonlinear.model.design,block= metadata.clean$patientID,plot=FALSE)
nonlinear.model.fit <- eBayes(nonlinear.model.fit)

#######################################################################################################################################
# check which model is better

# Manual computation of fitted values
fitted_linear <- linear.model.fit$coefficients %*% t(linear.model.design)  # Genes × Samples
fitted_spline <- nonlinear.model.fit$coefficients %*% t(nonlinear.model.design)

# calculate the residules for each genes
resid_linear <- orf.abundance.clean - fitted_linear
resid_spline <- orf.abundance.clean - fitted_spline

# compute residual sum of squares (RSS)
rss_linear <- rowSums(resid_linear^2)
rss_spline <- rowSums(resid_spline^2)


# get the sample size per gene
n <- ncol(orf.abundance.clean)
# get the number of model parameters for both models
k_linear <- ncol(linear.model.design)
k_spline <- ncol(nonlinear.model.design)

# given the formula of calculating AIC
# AIC = n * log(RSS / n) + 2 * k
# n = number of observations (samples)
# RSS = residual sum of squares per gene
# k = number of parameters used in the model

# calculate AICs for both models
aic_linear <- n * log(rss_linear / n) + 2 * k_linear
aic_spline <- n * log(rss_spline / n) + 2 * k_spline

# compare AICs of genes for both models
delta_aic <- aic_linear - aic_spline

# make a histogram plot to visualize how the differences of AIC scores distributed 
AIC_differences <- hist(delta_aic, breaks = 50, main = "ΔAIC (Linear - Spline)",
     xlab = "ΔAIC: Positive = spline better")

# calculate how many genes has AIC scores at least 2 points lower than linear model (ΔAIC > 2 is a common cutoff for "meaningful" improvement)
mean(delta_aic > 2)
# 0 (only 0 genes are better fit in splines model)
summary(delta_aic > 2)
#    Mode   FALSE 
# logical    2154

# Conclusion: use linear model
########################################################################################################################################
colnames(linear.model.fit)
#  [1] "(Intercept)"                                          "Dx.StatusCONTROL"                                    
#  [3] "ns(onset_timeline_numeric, df = 3)1"                  "ns(onset_timeline_numeric, df = 3)2"                 
#  [5] "ns(onset_timeline_numeric, df = 3)3"                  "CountryUSA"                                          
#  [7] "SexMale"                                              "Age.at.Gluten.Introduction..months."                 
#  [9] "HLA.CategoryHigh Risk"                                "HLA.CategoryLow/No Risk"                             
# [11] "feeding_first_yearFormula"                            "feeding_first_yearBreastmilk_and_formula"            
# [13] "Delivery.ModeC-Section"                               "Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)1"
# [15] "Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)2" "Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)3"

########################################################################################################################################


model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)1",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)1",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2033
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)2",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)2",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)3",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)3",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 1902

# Define gene of interest
selected_gene <- rownames(sig.model.res)


# Subset design matrix and model coefficients for prediction
linear.model.design <- model.matrix(~ Dx.Status * ns(onset_timeline_numeric,df=3) + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)

trajectory_plot_list <- list()


for (i in selected_gene){
  
   # Extract observed abundance vector for gene i
  gene_abundance <- orf.abundance.clean[i, ]

  # Create metadata + model prediction + observed abundance
  predicted_df <- metadata.clean %>%
    mutate(predicted_abundance = as.numeric(linear.model.design %*% linear.model.fit$coefficients[i, ]),
           observed_abundance = as.numeric(gene_abundance))

  # Count non-zero samples and total abundance per group and time
  count_df <- predicted_df %>%
    group_by(onset_timeline_numeric, Dx.Status) %>%
    summarise(
      non_zero_n = sum(observed_abundance > 0, na.rm = TRUE),
      total_reads = sum(observed_abundance, na.rm = TRUE),
      .groups = "drop"
    )

  # Get mean predicted values per group and time
  plot_df_pred <- predicted_df %>%
    group_by(onset_timeline_numeric, Dx.Status) %>%
    summarise(mean_pred = mean(predicted_abundance, na.rm = TRUE), .groups = "drop") %>%
    left_join(count_df, by = c("onset_timeline_numeric", "Dx.Status"))

  # Label showing both counts
  plot_df_pred <- plot_df_pred %>%
    mutate(label_text = paste0("n=", non_zero_n, "\nreads=", round(total_reads)))

  # Plot with annotations for sample count and total reads
  p <- ggplot(plot_df_pred, aes(x = onset_timeline_numeric, y = mean_pred, color = Dx.Status)) +
    geom_line(size = 1.2) +
    geom_point(size = 2) +
    geom_text(aes(label = label_text), vjust = -0.5, size = 3) +
    labs(title = paste("Model-Predicted Abundance for", i),
         x = "Months before onset", y = "Predicted Abundance (logCPM)") +
    theme(legend.position = "none")

  # Store in list
  trajectory_plot_list[[i]] <- p
}



# Pick 10 plots
plot_subset <- trajectory_plot_list[301:400]  # or use names: trajectory_plot_list[c("gene1", "gene2", ...)]

# Combine into grid: 2 rows × 5 columns
grid_plot <- wrap_plots(plot_subset, nrow = 10, ncol = 10)

# Show the grid
grid_plot

ggsave(grid_plot,file=paste0("~/Downloads/test_trajectory4.pdf"),dpi = 600,width = 20,height=20)



########################################################################################################################################
model.res <- topTable(linear.model.fit,coef="ns(onset_timeline_numeric, df = 3)1",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="ns(onset_timeline_numeric, df = 3)1",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="ns(onset_timeline_numeric, df = 3)2",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="ns(onset_timeline_numeric, df = 3)2",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 39
model.res <- topTable(linear.model.fit,coef="ns(onset_timeline_numeric, df = 3)3",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="ns(onset_timeline_numeric, df = 3)3",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 70

########################################################################################################################################
model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 1
#################################################################################################

model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="CountryUSA",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2874
model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 2533
model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6


```



compare model 3 and model 4
```{r}

metadata.clean <- metadata.clean %>%
                  mutate(onset_timeline_combined = ifelse(onset_timeline %in% c("t0-42","t0-48","t0-54","t0-60","t0-66","t0-72"),"t0-over42",onset_timeline))
metadata.clean$onset_timeline_combined <- factor(metadata.clean$onset_timeline_combined,levels = c("t0","t0-6","t0-12","t0-18","t0-24","t0-30","t0-36","t0-over42"))

factor.model.design <- model.matrix(~ Dx.Status * onset_timeline_combined + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)

linear.model.design <- model.matrix(~ Dx.Status * onset_timeline_numeric + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)

nonlinear.model.design <- model.matrix(~ Dx.Status * ns(onset_timeline_numeric,df=3) + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)


fit_factor <- eBayes(voomLmFit(orf.abundance.clean, factor.model.design, block = metadata.clean$patientID, plot = FALSE))
fit_linear <- eBayes(voomLmFit(orf.abundance.clean, linear.model.design, block = metadata.clean$patientID, plot = FALSE))
fit_spline <- eBayes(voomLmFit(orf.abundance.clean, nonlinear.model.design, block = metadata.clean$patientID, plot = FALSE))


# Residuals
resid_factor <- residuals(fit_factor, orf.abundance.clean)
resid_linear <- residuals(fit_linear, orf.abundance.clean)
resid_spline <- residuals(fit_spline, orf.abundance.clean)

# RSS
rss_factor <- rowSums(resid_factor^2)
rss_linear <- rowSums(resid_linear^2)
rss_spline <- rowSums(resid_spline^2)


# Parameters
n <- ncol(orf.abundance.clean)  # Number of samples
kf <- ncol(factor.model.design)
kl <- ncol(linear.model.design)
ks <- ncol(nonlinear.model.design)

# AIC
aic_factor <- n * log(rss_factor / n) + 2 * kf
aic_linear <- n * log(rss_linear / n) + 2 * kl
aic_spline <- n * log(rss_spline / n) + 2 * ks

summary(rss_spline)
summary(rss_linear)
anova(fit_linear, fit_spline)
# For each gene, which model has the lowest AIC?
best_model <- apply(cbind(aic_factor, aic_linear,aic_spline), 1, which.min)


# Tabulate
table(best_model)
# 1 = factor, 2 = linear, 3 = spline

# Optional: Proportion of genes preferring each
prop.table(table(best_model))


```

# we ended up choosing Model 3.


# volcano plot
```{r}



significant_gene_function_table <- read_delim("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/phold_per_cds_predictions.tsv") %>%
          select(`cds_id`,`phrog`,`function`,`product`) %>%
          column_to_rownames("cds_id") %>%
          merge(model.res,by = 0)


# make volcano plots for the significant genes

# Add significance categories
significant_gene_function_table$significant <- significant_gene_function_table$adj.P.Val < 0.05
significant_gene_function_table$highly_significant <- significant_gene_function_table$adj.P.Val < 0.001
significant_gene_function_table$neg_log10_padj <- -log10(significant_gene_function_table$adj.P.Val)


# FLIP THE SIGN of logFC to switch axis orientation
significant_gene_function_table$logFC_flipped <- -significant_gene_function_table$logFC


# Create significance labels
significant_gene_function_table$significance_label <- "Not Significant"
significant_gene_function_table$significance_label[significant_gene_function_table$significant] <- "Significant (adj.p < 0.05)"
significant_gene_function_table$significance_label[significant_gene_function_table$highly_significant] <- "Highly Significant (adj.p < 0.001)"



significant_gene_function_table$significance_label <- factor(significant_gene_function_table$significance_label,
                                          levels = c("Not Significant",
                                                    "Significant (adj.p < 0.05)",
                                                    "Highly Significant (adj.p < 0.001)"))

# Define colors
colors <- c("Not Significant" = "grey70",
           "Significant (adj.p < 0.05)" = "#E31A1C",
           "Highly Significant (adj.p < 0.001)" = "#B2182B")

# Create volcano plot
total_dataset_volcano_plot <- ggplot(significant_gene_function_table, aes(x = logFC_flipped, y = neg_log10_padj)) +
  geom_point(aes(color = significance_label), size = 0.8, alpha = 0.7) +
  scale_color_manual(values = colors, name = "Significance") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red", alpha = 0.7) +
  geom_hline(yintercept = -log10(0.001), linetype = "dashed", color = "darkred", alpha = 0.7) +
  labs(
    title = "Viral ORF Differential Abundance: CONTROL vs CELIAC",
    x = "Log2 Fold Change (CONTROL vs CELIAC)",
    y = "-Log10(Adjusted P-value)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    legend.position = "bottom"
  )

# Save plot
ggsave(total_dataset_volcano_plot, file="~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/compositonal_analysis/total_cohort_volcano_plot.pdf", width = 8, height = 8, dpi = 300)


######################### color the points based on gene functions ##############################

# Clean up function names and create simplified categories
significant_gene_function_table$`function`[is.na(significant_gene_function_table$`function`)] <- "unknown function"
significant_gene_function_table$`function`[significant_gene_function_table$`function` == ""] <- "unknown function"


# Create simplified functional categories for better visualization
significant_gene_function_table$func_category <- significant_gene_function_table$`function`
significant_gene_function_table$func_category[grepl("DNA|RNA|nucleotide|replication",
significant_gene_function_table$`function`, ignore.case = TRUE)] <- "DNA/RNA metabolism"
significant_gene_function_table$func_category[grepl("head|packaging|capsid",
significant_gene_function_table$`function`, ignore.case = TRUE)] <- "Head & packaging"
significant_gene_function_table$func_category[grepl("tail|fiber", significant_gene_function_table$`function`,ignore.case = TRUE)] <- "Tail"
significant_gene_function_table$func_category[grepl("lysis|holin", significant_gene_function_table$`function`,ignore.case = TRUE)] <- "Lysis"
significant_gene_function_table$func_category[grepl("transcription|regulation",
significant_gene_function_table$`function`, ignore.case = TRUE)] <- "Transcription"
significant_gene_function_table$func_category[grepl("integration|excision|recombination",
significant_gene_function_table$`function`, ignore.case = TRUE)] <- "Integration/excision"
significant_gene_function_table$func_category[grepl("connector", significant_gene_function_table$`function`,ignore.case = TRUE)] <- "Connector"
significant_gene_function_table$func_category[grepl("unknown|hypothetical",significant_gene_function_table$`function`, ignore.case = TRUE)] <- "Unknown function"
significant_gene_function_table$func_category[grepl("other", significant_gene_function_table$`function`,ignore.case = TRUE)] <- "Other"

# Count functions and keep only top categories, group rare ones as 
"Other"
func_counts <- table(significant_gene_function_table$func_category)
top_functions <- names(sort(func_counts, decreasing = TRUE))[1:8]  # Keep top 8
significant_gene_function_table$func_category[!significant_gene_function_table$func_category %in% top_functions] <- "Other/Rare"

# Create color palette for functions
func_colors <- c(
"DNA/RNA metabolism" = "#1f77b4",
"Head & packaging" = "#ff7f0e",
"Tail" = "#2ca02c",
"Unknown function" = "#d62728",
"Lysis" = "#9467bd",
"Transcription" = "#8c564b",
"Integration/excision" = "#e377c2",
"Connector" = "#7f7f7f",
"Other" = "#bcbd22",
"Other/Rare" = "#17becf"
)



# Create volcano plot colored by function
total_dataset_volcano_plot_color_by_function <- ggplot(significant_gene_function_table, aes(x = logFC_flipped, y = neg_log10_padj)) +
                              geom_point(data = significant_gene_function_table %>% filter(adj.P.Val < 0.05), aes(color = func_category), size = 0.8, alpha = 0.7) +
                              geom_point(data = significant_gene_function_table %>% filter(adj.P.Val >= 0.05),color = "gray",size = 0.8, alpha = 0.7)+ 
                              scale_color_manual(values = func_colors, name = "Gene Function") +
                              geom_hline(yintercept = -log10(0.05), linetype = "dashed", color =
                              "black", alpha = 0.5) +
                              geom_hline(yintercept = -log10(0.001), linetype = "dashed", color =
                              "black", alpha = 0.7) +
                              labs(
                                title = "Viral ORF Differential Abundance by Gene Function",
                                subtitle = paste("Total:", nrow(significant_gene_function_table), "ORFs | Significant:",
                              sum(significant_gene_function_table$significant), "ORFs (adj.p < 0.05)"),
                                x = "Log2 Fold Change (CONTROL vs CELIAC)",
                                y = "-Log10(Adjusted P-value)",
                                caption = "Negative logFC = Higher in CONTROL, Lower in CELIAC"
                              ) +
                              theme_minimal() +
                              theme(
                                plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
                                plot.subtitle = element_text(size = 11, hjust = 0.5),
                                legend.position = "right",
                                legend.title = element_text(size = 11, face = "bold"),
                                panel.grid.minor = element_blank()
                              )

ggsave(total_dataset_volcano_plot_color_by_function,file="~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/compositonal_analysis/total_cohort_volcano_plot_color_by_function.pdf", width = 8, height = 8, dpi = 300)

function.table <- significant_gene_function_table %>% filter(adj.P.Val < 0.05) %>% select(c("Row.names","phrog","function","product"))
write.csv(function.table,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/compositonal_analysis/function_table.csv",quote = FALSE,row.names = FALSE)

```




########################################################################## US ############################################################### 




                                              ############################################################################
                                              #      Limma model on 3% pravelance filtered + temporal filtered data      #   
                                              #         US.orf.abundance.table_0.75_prevFiltered_temporal  (2154 orfs)   #
                                              ############################################################################
                                              
                                              
Model 3: create a numeric format of onset_timeline and make it onset_timeline_numeric assume it is linear in the model
~ Dx.Status * onset_timeline_numeric + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode, block = patientID
```{r}


# prepare clean metadata
metadata.clean <- US.orf.abundance.table_0.75_prevFiltered_temporal[1:25] %>%
                  column_to_rownames("Row.names")
# 196  24


orf.abundance.clean <- US.orf.abundance.table_0.75_prevFiltered_temporal %>%
                           select(c("Row.names",26:1254)) %>%
                           filter(Row.names %in% rownames(metadata.clean)) %>%
                           column_to_rownames("Row.names") %>% 
                           t(.) %>%
                           data.frame(.)
colnames(orf.abundance.clean) <- gsub("X","",colnames(orf.abundance.clean))
# 1229 196


# write.csv(orf.abundance.clean,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/US/US.orf.abundance.table_0.75_prevFiltered_temporal_cleaned.csv",quote = FALSE,row.names = TRUE)
# 
# write.csv(metadata.clean,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/US/US.metadata.cleaned.csv",quote = FALSE,row.names = TRUE)



# write.csv(orf.abundance.clean,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data/US.orf.abundance.table_0.75_prevFiltered_temporal_cleaned.csv",quote = FALSE,row.names = TRUE)
# 1312  196


# prepare correct variable format
metadata.clean$feeding_first_year <- factor(metadata.clean$feeding_first_year,levels = c("Breast_fed","Formula","Breastmilk_and_formula"))
# Breast_fed      Formula   Breastmilk_and_formula 
#    120             58              129 
metadata.clean$HLA.Category <- factor(metadata.clean$HLA.Category,levels = c("Standard Risk","High Risk","Low/No Risk"))
# Standard Risk     High Risk   Low/No Risk 
#      169            94            44
metadata.clean$Country <- factor(metadata.clean$Country,levels = c("ITALY","USA"))
# ITALY   USA 
#   110   197 
metadata.clean$Sex <- factor(metadata.clean$Sex,levels = c("Female","Male"))
# Female  Male 
#   238   69
metadata.clean$Delivery.Mode <- factor(metadata.clean$Delivery.Mode,levels = c("Vaginal","C-Section"))
# Vaginal C-Section 
# 217        90
metadata.clean$Age.at.Gluten.Introduction..months. <- as.numeric(metadata.clean$Age.at.Gluten.Introduction..months.)
# #  # 4  5  6  7  8  9 10 11 12 15 36 
# #  # 5 11 57 91 40 33 33 10  2 16  9 
metadata.clean$Dx.Status <- factor(metadata.clean$Dx.Status,levels = c("CELIAC","CONTROL"))
# CONTROL  CELIAC 
#    162     145 


# since the number of parameters changed (onset_timeline as linear numeric), so we need to re-evaluate the linearity of Age.at.Gluten.Introduction..months. variable

# treat Age.at.Gluten.Introduction..months. as linear
linear.model.design <- model.matrix(~ Dx.Status * onset_timeline_numeric + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
linear.model.fit <- voomLmFit(orf.abundance.clean,linear.model.design,block= metadata.clean$patientID,plot=FALSE)
linear.model.fit <- eBayes(linear.model.fit)
linear.model.fit.linear <- linear.model.fit



# treat Age.at.Gluten.Introduction..months. as non-linear
nonlinear.model.design <- model.matrix(~ Dx.Status * onset_timeline_numeric + Sex + ns(Age.at.Gluten.Introduction..months.,df=3) + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
nonlinear.model.fit <- voomLmFit(orf.abundance.clean,nonlinear.model.design,block= metadata.clean$patientID,plot=FALSE)
nonlinear.model.fit <- eBayes(nonlinear.model.fit)


#######################################################################################################################################
# check which model is better

# Manual computation of fitted values
fitted_linear <- linear.model.fit$coefficients %*% t(linear.model.design)  # Genes × Samples
fitted_spline <- nonlinear.model.fit$coefficients %*% t(nonlinear.model.design)

# calculate the residules for each genes
resid_linear <- orf.abundance.clean - fitted_linear
resid_spline <- orf.abundance.clean - fitted_spline

# compute residual sum of squares (RSS)
rss_linear <- rowSums(resid_linear^2)
rss_spline <- rowSums(resid_spline^2)


# get the sample size per gene
n <- ncol(orf.abundance.clean)
# get the number of model parameters for both models
k_linear <- ncol(linear.model.design)
k_spline <- ncol(nonlinear.model.design)

# given the formula of calculating AIC
# AIC = n * log(RSS / n) + 2 * k
# n = number of observations (samples)
# RSS = residual sum of squares per gene
# k = number of parameters used in the model

# calculate AICs for both models
aic_linear <- n * log(rss_linear / n) + 2 * k_linear
aic_spline <- n * log(rss_spline / n) + 2 * k_spline

# compare AICs of genes for both models
delta_aic <- aic_linear - aic_spline

# make a histogram plot to visualize how the differences of AIC scores distributed 
AIC_differences <- hist(delta_aic, breaks = 50, main = "ΔAIC (Linear - Spline)",
     xlab = "ΔAIC: Positive = spline better")

# calculate how many genes has AIC scores at least 2 points lower than linear model (ΔAIC > 2 is a common cutoff for "meaningful" improvement)
mean(delta_aic > 2)
# 0 (only 0 genes are better fit in splines model)

# Conclusion: use linear model
########################################################################################################################################
colnames(linear.model.fit)
#  [1] "(Intercept)"                              "Dx.StatusCONTROL"                        
#  [3] "onset_timeline_numeric"                   "SexMale"                                 
#  [5] "Age.at.Gluten.Introduction..months."      "HLA.CategoryHigh Risk"                   
#  [7] "HLA.CategoryLow/No Risk"                  "feeding_first_yearFormula"               
#  [9] "feeding_first_yearBreastmilk_and_formula" "Delivery.ModeC-Section"                  
# [11] "Dx.StatusCONTROL:onset_timeline_numeric" 


model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_numeric",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_numeric",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 377


# lable the spurious genes

# --- Parameters you can adjust ---
min_timepoints_with_signal <- 3
min_samples_per_timepoint <- 2
min_total_reads_per_group <- 1000

# --- Function to assess one virus ---
flag_virus <- function(gene_name, abundance_table, metadata, time_col = "onset_timeline_numeric") {
  # Extract abundance
  gene_abund <- abundance_table[gene_name, , drop = FALSE]
  gene_abund <- as.numeric(gene_abund)
  
  # Combine with metadata
  df <- metadata %>%
    mutate(abund = gene_abund,
           reads = 2^abund - 1)  # assuming log2(CPM+1), convert back
  
  # Count non-zero samples and reads per time x group
  signal_stats <- df %>%
    group_by(!!sym(time_col), Dx.Status) %>%
    summarise(n_nonzero = sum(abund > 0, na.rm = TRUE),
              total_reads = sum(reads[abund > 0], na.rm = TRUE),
              .groups = "drop")
  
  # Timepoints with at least X non-zero samples
  valid_timepoints <- signal_stats %>%
    filter(n_nonzero >= min_samples_per_timepoint) %>%
    group_by(Dx.Status) %>%
    summarise(n_timepoints_with_signal = n(), .groups = "drop")
  
  # Total reads per group
  read_totals <- signal_stats %>%
    group_by(Dx.Status) %>%
    summarise(total_reads = sum(total_reads), .groups = "drop")
  
  # Flag if any group fails any of the thresholds
  flagged <- any(
    valid_timepoints$n_timepoints_with_signal < min_timepoints_with_signal |
    read_totals$total_reads < min_total_reads_per_group
  )
  
  return(flagged)
}

# --- Apply to all significant genes ---
flagged_results <- sapply(rownames(sig.model.res), function(gene) {
  flag_virus(gene, orf.abundance.clean, metadata.clean)
})

# Get flagged gene names
flagged_genes <- names(flagged_results)[flagged_results]
# 173 genes


# plot the flagged genes

# Subset abundance matrix to spurious genes
spurious_abund <- orf.abundance.clean[rownames(orf.abundance.clean) %in% flagged_genes, ]

# ---------------------------
# Summary statistics
# ---------------------------
# 1. Sparsity (proportion of samples with 0 counts)
sparsity <- rowMeans(spurious_abund == 0, na.rm = TRUE)

# 2. Max count per gene
max_count <- apply(spurious_abund, 1, max, na.rm = TRUE)

# 3. Number of time bins with ≥2 non-zero samples
temporal_support <- function(gene_row, metadata, min_nonzero = 2) {
  df <- data.frame(value = gene_row, time = metadata$onset_timeline_numeric)
  df$nonzero <- df$value > 0
  by_bin <- df %>% group_by(time) %>% summarise(nonzero_n = sum(nonzero, na.rm = TRUE))
  sum(by_bin$nonzero_n >= min_nonzero)
}
support_counts <- apply(spurious_abund, 1, temporal_support, metadata = metadata.clean)

# Combine summary
spurious_summary <- data.frame(
  Gene = rownames(spurious_abund),
  Sparsity = sparsity,
  MaxCount = max_count,
  TimeBinsWithSupport = support_counts
)

# ---------------------------
# Plot distributions
# ---------------------------
# Histogram of sparsity
ggplot(spurious_summary, aes(x = Sparsity)) +
  geom_histogram(bins = 30, fill = "tomato") +
  labs(title = "Sparsity of Spurious Genes", x = "Proportion of 0 Counts", y = "Number of Genes") +
  theme_minimal()

# Histogram of time bin support
ggplot(spurious_summary, aes(x = TimeBinsWithSupport)) +
  geom_histogram(binwidth = 1, fill = "steelblue") +
  labs(title = "Temporal Support of Spurious Genes", x = "# Time Bins with ≥2 Non-zero", y = "Number of Genes") +
  theme_minimal()

# ---------------------------
# Heatmap for inspection (top 50 sparse genes)
# ---------------------------
top_sparse <- head(order(sparsity, decreasing = TRUE), 50)
pheatmap(spurious_abund[top_sparse, ], scale = "row", show_rownames = FALSE,
         main = "Spurious Genes - Top Sparse Profiles")



# plot trajectory for those reliable genes
#selected_gene <- rownames(sig.model.res)[!rownames(sig.model.res) %in% flagged_genes]
selected_gene <- rownames(sig.model.res)

# Subset design matrix and model coefficients for prediction
linear.model.design <- model.matrix(~ Dx.Status * onset_timeline_numeric + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)

trajectory_plot_list <- list()


for (i in selected_gene){
  
   # Extract observed abundance vector for gene i
  gene_abundance <- orf.abundance.clean[i, ]

  # Create metadata + model prediction + observed abundance
  predicted_df <- metadata.clean %>%
    mutate(predicted_abundance = as.numeric(linear.model.design %*% linear.model.fit$coefficients[i, ]),
           observed_abundance = as.numeric(gene_abundance))

  # Count non-zero samples and total abundance per group and time
  count_df <- predicted_df %>%
    group_by(onset_timeline_numeric, Dx.Status) %>%
    summarise(
      non_zero_n = sum(observed_abundance > 0, na.rm = TRUE),
      total_reads = sum(observed_abundance, na.rm = TRUE),
      .groups = "drop"
    )

  # Get mean predicted values per group and time
  plot_df_pred <- predicted_df %>%
  left_join(count_df, by = c("onset_timeline_numeric", "Dx.Status")) %>%
  group_by(onset_timeline_numeric, Dx.Status) %>%
  summarise(
    mean_pred = mean(predicted_abundance, na.rm = TRUE),
    non_zero_n = first(non_zero_n),      # from count_df
    total_reads = first(total_reads),    # from count_df
    .groups = "drop"
  ) %>%
  mutate(mean_pred = ifelse(non_zero_n == 0 & total_reads == 0, NA, mean_pred))

  # Label showing both counts
  plot_df_pred <- plot_df_pred %>%
    mutate(label_text = paste0("n=", non_zero_n, "\nreads=", round(total_reads)))

  # Plot with annotations for sample count and total reads
  p <- ggplot(plot_df_pred, aes(x = onset_timeline_numeric, y = mean_pred, color = Dx.Status)) +
    geom_line(size = 1.2) +
    geom_point(size = 2) +
    geom_text(aes(label = label_text), vjust = -0.5, size = 3) +
    labs(title = paste("Model-Predicted Abundance for", i),
         x = "Months before onset", y = "Predicted Abundance (logCPM)") +
    theme(legend.position = "none")

  # Store in list
  trajectory_plot_list[[i]] <- p
}

dev.off()
trajectory_plot_list[7]
length(trajectory_plot_list)

# Pick 10 plots
plot_subset <- trajectory_plot_list[1:377]  # or use names: trajectory_plot_list[c("gene1", "gene2", ...)]
# Combine into grid: 2 rows × 5 columns
grid_plot <- wrap_plots(plot_subset)
ggsave(grid_plot,file=paste0("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/US/US_significant_rajectory_75_3prev_Temporal_clean.pdf"),dpi = 600,width = 49,height=49)



# hist(sig.model.res$adj.P.Val, breaks = 50) # the shape looks valid
# hist(model.res$adj.P.Val, breaks = 50, col = "gray", main = "All Adjusted P-Values") # the shape looks valid as well

###########################################################################################################################

model.res <- topTable(linear.model.fit,coef="onset_timeline_numeric",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_numeric",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 4

#################################################################################################

model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0


#################################################################################################

model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf) %>% filter(adj.P.Val < 0.05)
# 1 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6


```




Model splines: treat onset_timeline as a numerical variable: create a numeric format of onset_timeline and make it onset_timeline_numeric assume it is linear in the model
~ Dx.Status * ns(onset_timeline_numeric,df=3) + RunNumber + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode, block = patientID
```{r}

# prepare correct variable format
US.metadata.clean$feeding_first_year <- factor(US.metadata.clean$feeding_first_year,levels = c("Breast_fed","Formula","Breastmilk_and_formula"))
# Breast_fed      Formula   Breastmilk_and_formula 
#    120             58              129 
US.metadata.clean$HLA.Category <- factor(US.metadata.clean$HLA.Category,levels = c("Standard Risk","High Risk","Low/No Risk"))
# Standard Risk     High Risk   Low/No Risk 
#      169            94            44
US.metadata.clean$Sex <- factor(US.metadata.clean$Sex,levels = c("Female","Male"))
# Female  Male 
#   238   69
US.metadata.clean$Delivery.Mode <- factor(US.metadata.clean$Delivery.Mode,levels = c("Vaginal","C-Section"))
# Vaginal C-Section 
# 217        90
US.metadata.clean$Age.at.Gluten.Introduction..months. <- as.numeric(US.metadata.clean$Age.at.Gluten.Introduction..months.)
# #  # 4  5  6  7  8  9 10 11 12 15 36 
# #  # 5 11 57 91 40 33 33 10  2 16  9 
US.metadata.clean$Dx.Status <- factor(US.metadata.clean$Dx.Status,levels = c("CELIAC","CONTROL"))
# CONTROL  CELIAC 
#    162     145 


# treat Age.at.Gluten.Introduction..months. as linear
US.splines.model.design <- model.matrix(~ Dx.Status * ns(onset_timeline_numeric,df=3) + RunNumber + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,US.metadata.clean)
US.splines.model.fit <- voomLmFit(US.orf.abundance.clean,US.splines.model.design,block= US.metadata.clean$patientID,plot=FALSE)
US.splines.model.fit <- eBayes(US.splines.model.fit)

colnames(US.splines.model.fit)
# [1] "(Intercept)"                                          "Dx.StatusCONTROL"                                    
#  [3] "ns(onset_timeline_numeric, df = 3)1"                  "ns(onset_timeline_numeric, df = 3)2"                 
#  [5] "ns(onset_timeline_numeric, df = 3)3"                  "RunNumberN978"                                       
#  [7] "RunNumberN979"                                        "RunNumberN980"                                       
#  [9] "RunNumberN981"                                        "RunNumberN983"                                       
# [11] "SexMale"                                              "Age.at.Gluten.Introduction..months."                 
# [13] "HLA.CategoryHigh Risk"                                "HLA.CategoryLow/No Risk"                             
# [15] "feeding_first_yearFormula"                            "feeding_first_yearBreastmilk_and_formula"            
# [17] "Delivery.ModeC-Section"                               "Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)1"
# [19] "Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)2" "Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)3"



US.model.res <- topTable(US.splines.model.fit,coef="Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)1",number=Inf)
US.sig.model.res <- topTable(US.splines.model.fit,coef="Dx.StatusCONTROL:ns(onset_timeline_numeric, df = 3)1",number=Inf) %>% filter(adj.P.Val < 0.01)
# 973
sig.linear <- rownames(US.sig.model.res)

write.csv(US.model.res,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/US/US.limma_model_res.csv",quote = FALSE,row.names = TRUE)

# Define gene of interest
selected_gene <- rownames(US.sig.model.res)

# Subset design matrix and model coefficients for prediction
US.linear.model.design <- model.matrix(~ Dx.Status * onset_timeline_numeric + RunNumber + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,US.metadata.clean)

trajectory_plot_list <- list()


for (i in selected_gene){
  
   # Extract observed abundance vector for gene i
  gene_abundance <- orf.abundance.clean[i, ]

  # Create metadata + model prediction + observed abundance
  predicted_df <- metadata.clean %>%
    mutate(predicted_abundance = as.numeric(linear.model.design %*% linear.model.fit$coefficients[i, ]),
           observed_abundance = as.numeric(gene_abundance))

  # Count non-zero samples and total abundance per group and time
  count_df <- predicted_df %>%
    group_by(onset_timeline_numeric, Dx.Status) %>%
    summarise(
      non_zero_n = sum(observed_abundance > 0, na.rm = TRUE),
      total_reads = sum(observed_abundance, na.rm = TRUE),
      .groups = "drop"
    )

  # Get mean predicted values per group and time
  plot_df_pred <- predicted_df %>%
  left_join(count_df, by = c("onset_timeline_numeric", "Dx.Status")) %>%
  group_by(onset_timeline_numeric, Dx.Status) %>%
  summarise(
    mean_pred = mean(predicted_abundance, na.rm = TRUE),
    non_zero_n = first(non_zero_n),      # from count_df
    total_reads = first(total_reads),    # from count_df
    .groups = "drop"
  ) %>%
  mutate(mean_pred = ifelse(non_zero_n == 0 & total_reads == 0, NA, mean_pred))
  

  # Label showing both counts
  plot_df_pred <- plot_df_pred %>%
    mutate(label_text = paste0("n=", non_zero_n, "\nreads=", round(total_reads)))

  # Plot with annotations for sample count and total reads
  p <- ggplot(plot_df_pred, aes(x = onset_timeline_numeric, y = mean_pred, color = Dx.Status)) +
    geom_line(size = 1.2) +
    geom_point(size = 2) +
    geom_text(aes(label = label_text), vjust = -0.5, size = 3) +
    labs(title = i,
         x = "Months before onset", y = "Predicted Abundance (logCPM)") +
    theme(legend.position = "none")

  # Store in list
  trajectory_plot_list[[i]] <- p
}


# # Pick 10 plots
# plot_subset <- trajectory_plot_list[1:500]  # or use names: trajectory_plot_list[c("gene1", "gene2", ...)]
# # Combine into grid: 2 rows × 5 columns
# grid_plot <- wrap_plots(plot_subset)
# ggsave(grid_plot,file=paste0("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/Total_trajectory_batchRemoved_clean.pdf"),dpi = 600,width = 75,height=65,limitsize = FALSE)


# hist(sig.model.res$adj.P.Val, breaks = 50) # the shape looks valid
# hist(model.res$adj.P.Val, breaks = 50, col = "gray", main = "All Adjusted P-Values") # the shape looks valid as well

###########################################################################################################################

US.model.res <- topTable(US.linear.model.fit,coef="onset_timeline_numeric",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="onset_timeline_numeric",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 30

#################################################################################################

US.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0

#################################################################################################

US.model.res <- topTable(US.linear.model.fit,coef="SexMale",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="SexMale",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 4
US.model.res <- topTable(US.linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0 6
US.model.res <- topTable(US.linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0 6
US.model.res <- topTable(US.linear.model.fit,coef="feeding_first_yearFormula",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="feeding_first_yearFormula",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0 6
US.model.res <- topTable(US.linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(US.sig.model.res)
# 0 6

```




Model 2: treat onset_timeline as a categorical variable: modifying onset_timeline by combining the to-42M to t0-72M as one names "t0-over42"
~ Dx.Status * onset_timeline_combined + RunNumber + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode, block = patientID
```{r}

# prepare correct variable format
US.metadata.clean$feeding_first_year <- factor(US.metadata.clean$feeding_first_year,levels = c("Breast_fed","Formula","Breastmilk_and_formula"))
# Breast_fed      Formula   Breastmilk_and_formula 
#    120             58              129 
US.metadata.clean$HLA.Category <- factor(US.metadata.clean$HLA.Category,levels = c("Standard Risk","High Risk","Low/No Risk"))
# Standard Risk     High Risk   Low/No Risk 
#      169            94            44
US.metadata.clean$Country <- factor(US.metadata.clean$Country,levels = c("ITALY","USA"))
# ITALY   USA 
#   110   197 
US.metadata.clean$Sex <- factor(US.metadata.clean$Sex,levels = c("Female","Male"))
# Female  Male 
#   238   69
US.metadata.clean$Delivery.Mode <- factor(US.metadata.clean$Delivery.Mode,levels = c("Vaginal","C-Section"))
# Vaginal C-Section 
# 217        90
US.metadata.clean$Dx.Status <- factor(US.metadata.clean$Dx.Status,levels = c("CELIAC","CONTROL"))
# CONTROL  CELIAC 
#    162     145 
US.metadata.clean$onset_timeline_combined <- factor(US.metadata.clean$onset_timeline_combined,levels = c("t0","t0-6","t0-12","t0-18","t0-24","t0-30","t0-36","t0-over42"))
 # t0      t0-6     t0-12     t0-18     t0-24     t0-30     t0-36 t0-over42 
 # 64        30        46        27        32        29        33        46 
US.metadata.clean$Age.at.Gluten.Introduction..months. <- as.numeric(US.metadata.clean$Age.at.Gluten.Introduction..months.)
# 4  5  6  7  8  9 10 11 12 15 36 
# 5 11 57 91 40 33 33 10  2 16  9 


# after combine the late timepoints of onset_timeline, the distribution is like below:
table(US.metadata.clean$Dx.Status, US.metadata.clean$onset_timeline_combined) %>% t(.)
  #         CELIAC CONTROL
  # t0            16      16
  # t0-6           4       4
  # t0-12         14      14
  # t0-18          7       7
  # t0-24         12      13
  # t0-30         11      11
  # t0-36         13      13
  # t0-over42     21      21

# since the number of parameters changed (less levels in onset_timeline_combined variable), so we need to re-evaluate the linearity of Age.at.Gluten.Introduction..months. variable

# treat Age.at.Gluten.Introduction..months. as linear
US.categorical.model.design <- model.matrix(~ Dx.Status * onset_timeline_combined + RunNumber + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,US.metadata.clean)
US.categorical.model.fit <- voomLmFit(US.orf.abundance.clean,US.categorical.model.design,block= US.metadata.clean$patientID,plot=FALSE)
US.categorical.model.fit <- eBayes(US.categorical.model.fit)

########################################################################################################################################
colnames(US.categorical.model.fit)
#  [1] "(Intercept)"                                       "Dx.StatusCONTROL"                                 
#  [3] "onset_timeline_combinedt0-6"                       "onset_timeline_combinedt0-12"                     
#  [5] "onset_timeline_combinedt0-18"                      "onset_timeline_combinedt0-24"                     
#  [7] "onset_timeline_combinedt0-30"                      "onset_timeline_combinedt0-36"                     
#  [9] "onset_timeline_combinedt0-over42"                  "RunNumberN978"                                    
# [11] "RunNumberN979"                                     "RunNumberN980"                                    
# [13] "RunNumberN981"                                     "RunNumberN983"                                    
# [15] "SexMale"                                           "Age.at.Gluten.Introduction..months."              
# [17] "HLA.CategoryHigh Risk"                             "HLA.CategoryLow/No Risk"                          
# [19] "feeding_first_yearFormula"                         "feeding_first_yearBreastmilk_and_formula"         
# [21] "Delivery.ModeC-Section"                            "Dx.StatusCONTROL:onset_timeline_combinedt0-6"     
# [23] "Dx.StatusCONTROL:onset_timeline_combinedt0-12"     "Dx.StatusCONTROL:onset_timeline_combinedt0-18"    
# [25] "Dx.StatusCONTROL:onset_timeline_combinedt0-24"     "Dx.StatusCONTROL:onset_timeline_combinedt0-30"    
# [27] "Dx.StatusCONTROL:onset_timeline_combinedt0-36"     "Dx.StatusCONTROL:onset_timeline_combinedt0-over42"        

US.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-6",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-6",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0
US.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-12",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-12",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0
US.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-18",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-18",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0
US.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-24",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-24",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 4
US.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-30",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-30",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(US.sig.model.res)
# 0
US.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-36",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-36",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 25
US.sig.factor <- rownames(US.sig.model.res)

US.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-over42",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-over42",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 3

# hist(sig.model.res$adj.P.Val, breaks = 50) # the shape looks valid
# hist(model.res$adj.P.Val, breaks = 50, col = "gray", main = "All Adjusted P-Values") # the shape looks valid as well

###########################################################################################################################


US.model.res <- topTable(US.linear.model.fit,coef="onset_timeline_combinedt0-6",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="onset_timeline_combinedt0-6",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 153
US.model.res <- topTable(US.linear.model.fit,coef="onset_timeline_combinedt0-12",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="onset_timeline_combinedt0-12",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 362
US.model.res <- topTable(US.linear.model.fit,coef="onset_timeline_combinedt0-18",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="onset_timeline_combinedt0-18",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 96
US.model.res <- topTable(US.linear.model.fit,coef="onset_timeline_combinedt0-24",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="onset_timeline_combinedt0-24",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0
US.model.res <- topTable(US.linear.model.fit,coef="onset_timeline_combinedt0-30",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="onset_timeline_combinedt0-30",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0
US.model.res <- topTable(US.linear.model.fit,coef="onset_timeline_combinedt0-36",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="onset_timeline_combinedt0-36",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0
US.model.res <- topTable(US.linear.model.fit,coef="onset_timeline_combinedt0-over42",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="onset_timeline_combinedt0-over42",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0

#################################################################################################

US.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="Dx.StatusCONTROL",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0

#################################################################################################

US.model.res <- topTable(US.linear.model.fit,coef="SexMale",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="SexMale",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0
US.model.res <- topTable(US.linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0
US.model.res <- topTable(US.linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0
US.model.res <- topTable(US.linear.model.fit,coef="feeding_first_yearFormula",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="feeding_first_yearFormula",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0
US.model.res <- topTable(US.linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf)
US.sig.model.res <- topTable(US.linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(US.sig.model.res)
# 0

```





# compare models (categorical vs numerical vs splines)
```{r}


## categorical vs numerical

fitted_categorical <- t(US.linear.model.design %*% t(US.linear.model.fit$coefficients))
fitted_numeric     <- t(US.categorical.model.design  %*% t(US.categorical.model.fit$coefficients))


# Step 3: Compute residual sum of squares (RSS) for each gene
resid_categorical <- US.orf.abundance.clean - fitted_categorical
resid_numeric     <- US.orf.abundance.clean - fitted_numeric


rss_categorical <- rowSums(resid_categorical^2)
rss_numeric     <- rowSums(resid_numeric^2)

# Step 4: Get number of samples and parameters
n <- ncol(US.orf.abundance.clean)
k_cat <- ncol(US.categorical.model.design)
k_num <- ncol(US.linear.model.design)

# Step 5: Calculate AIC
aic_categorical <- n * log(rss_categorical / n) + 2 * k_cat
aic_numeric     <- n * log(rss_numeric / n) + 2 * k_num

# Step 6: Compare AIC
delta_aic <- aic_categorical - aic_numeric  # positive means numeric model better
table(delta_aic > 2)  # how many genes favor numeric model by AIC difference > 2
table(delta_aic < -2) # how many genes favor categorical model
table(abs(delta_aic) <= 2)  # how many are roughly equivalent

# Optional: Summarize
summary(delta_aic)



## numerical vs splines

fitted_splines <- t(US.splines.model.design %*% t(US.splines.model.fit$coefficients))
fitted_numeric     <- t(US.categorical.model.design  %*% t(US.categorical.model.fit$coefficients))


# Step 3: Compute residual sum of squares (RSS) for each gene
resid_splines <- US.orf.abundance.clean - fitted_splines
resid_numeric     <- US.orf.abundance.clean - fitted_numeric


rss_splines <- rowSums(resid_splines^2)
rss_numeric     <- rowSums(resid_numeric^2)

# Step 4: Get number of samples and parameters
n <- ncol(US.orf.abundance.clean)
k_cat <- ncol(US.splines.model.design)
k_num <- ncol(US.linear.model.design)

# Step 5: Calculate AIC
aic_splines <- n * log(rss_splines / n) + 2 * k_cat
aic_numeric     <- n * log(rss_numeric / n) + 2 * k_num

# Step 6: Compare AIC
delta_aic <- aic_splines - aic_numeric  # positive means numeric model better
table(delta_aic > 2)  # how many genes favor numeric model by AIC difference > 2
table(delta_aic < -2) # how many genes favor categorical model
table(abs(delta_aic) <= 2)  # how many are roughly equivalent

# Optional: Summarize
summary(delta_aic)


```





Volcano plot
```{r}



significant_gene_function_table <- read_delim("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/phold_per_cds_predictions.tsv") %>%
          select(`cds_id`,`phrog`,`function`,`product`) %>%
          column_to_rownames("cds_id") %>%
          merge(model.res,by = 0)


# make volcano plots for the significant genes

# Add significance categories
significant_gene_function_table$significant <- significant_gene_function_table$adj.P.Val < 0.05
significant_gene_function_table$highly_significant <- significant_gene_function_table$adj.P.Val < 0.001
significant_gene_function_table$neg_log10_padj <- -log10(significant_gene_function_table$adj.P.Val)


# FLIP THE SIGN of logFC to switch axis orientation
significant_gene_function_table$logFC_flipped <- -significant_gene_function_table$logFC


# Create significance labels
significant_gene_function_table$significance_label <- "Not Significant"
significant_gene_function_table$significance_label[significant_gene_function_table$significant] <- "Significant (adj.p < 0.05)"
significant_gene_function_table$significance_label[significant_gene_function_table$highly_significant] <- "Highly Significant (adj.p < 0.001)"



significant_gene_function_table$significance_label <- factor(significant_gene_function_table$significance_label,
                                          levels = c("Not Significant",
                                                    "Significant (adj.p < 0.05)",
                                                    "Highly Significant (adj.p < 0.001)"))

# Define colors
colors <- c("Not Significant" = "grey70",
           "Significant (adj.p < 0.05)" = "#E31A1C",
           "Highly Significant (adj.p < 0.001)" = "#B2182B")

# Create volcano plot
total_dataset_volcano_plot <- ggplot(significant_gene_function_table, aes(x = logFC_flipped, y = neg_log10_padj)) +
  geom_point(aes(color = significance_label), size = 0.8, alpha = 0.7) +
  scale_color_manual(values = colors, name = "Significance") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red", alpha = 0.7) +
  geom_hline(yintercept = -log10(0.001), linetype = "dashed", color = "darkred", alpha = 0.7) +
  labs(
    title = "Viral ORF Differential Abundance: CONTROL vs CELIAC",
    x = "Log2 Fold Change (CONTROL vs CELIAC)",
    y = "-Log10(Adjusted P-value)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    legend.position = "bottom"
  )

# Save plot
ggsave(total_dataset_volcano_plot, file="~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/US/compositonal_analysis/total_cohort_volcano_plot.pdf", width = 8, height = 8, dpi = 300)


######################### color the points based on gene functions ##############################

# Clean up function names and create simplified categories
significant_gene_function_table$`function`[is.na(significant_gene_function_table$`function`)] <- "unknown function"
significant_gene_function_table$`function`[significant_gene_function_table$`function` == ""] <- "unknown function"


# Create simplified functional categories for better visualization
significant_gene_function_table$func_category <- significant_gene_function_table$`function`
significant_gene_function_table$func_category[grepl("DNA|RNA|nucleotide|replication",
significant_gene_function_table$`function`, ignore.case = TRUE)] <- "DNA/RNA metabolism"
significant_gene_function_table$func_category[grepl("head|packaging|capsid",
significant_gene_function_table$`function`, ignore.case = TRUE)] <- "Head & packaging"
significant_gene_function_table$func_category[grepl("tail|fiber", significant_gene_function_table$`function`,ignore.case = TRUE)] <- "Tail"
significant_gene_function_table$func_category[grepl("lysis|holin", significant_gene_function_table$`function`,ignore.case = TRUE)] <- "Lysis"
significant_gene_function_table$func_category[grepl("transcription|regulation",
significant_gene_function_table$`function`, ignore.case = TRUE)] <- "Transcription"
significant_gene_function_table$func_category[grepl("integration|excision|recombination",
significant_gene_function_table$`function`, ignore.case = TRUE)] <- "Integration/excision"
significant_gene_function_table$func_category[grepl("connector", significant_gene_function_table$`function`,ignore.case = TRUE)] <- "Connector"
significant_gene_function_table$func_category[grepl("unknown|hypothetical",significant_gene_function_table$`function`, ignore.case = TRUE)] <- "Unknown function"
significant_gene_function_table$func_category[grepl("other", significant_gene_function_table$`function`,ignore.case = TRUE)] <- "Other"

# Count functions and keep only top categories, group rare ones as 
"Other"
func_counts <- table(significant_gene_function_table$func_category)
top_functions <- names(sort(func_counts, decreasing = TRUE))[1:8]  # Keep top 8
significant_gene_function_table$func_category[!significant_gene_function_table$func_category %in% top_functions] <- "Other/Rare"

# Create color palette for functions
func_colors <- c(
"DNA/RNA metabolism" = "#1f77b4",
"Head & packaging" = "#ff7f0e",
"Tail" = "#2ca02c",
"Unknown function" = "#d62728",
"Lysis" = "#9467bd",
"Transcription" = "#8c564b",
"Integration/excision" = "#e377c2",
"Connector" = "#7f7f7f",
"Other" = "#bcbd22",
"Other/Rare" = "#17becf"
)



# Create volcano plot colored by function
total_dataset_volcano_plot_color_by_function <- ggplot(significant_gene_function_table, aes(x = logFC_flipped, y = neg_log10_padj)) +
                              geom_point(data = significant_gene_function_table %>% filter(adj.P.Val < 0.05), aes(color = func_category), size = 0.8, alpha = 0.7) +
                              geom_point(data = significant_gene_function_table %>% filter(adj.P.Val >= 0.05),color = "gray",size = 0.8, alpha = 0.7)+ 
                              scale_color_manual(values = func_colors, name = "Gene Function") +
                              geom_hline(yintercept = -log10(0.05), linetype = "dashed", color =
                              "black", alpha = 0.5) +
                              geom_hline(yintercept = -log10(0.001), linetype = "dashed", color =
                              "black", alpha = 0.7) +
                              labs(
                                title = "Viral ORF Differential Abundance by Gene Function",
                                subtitle = paste("Total:", nrow(significant_gene_function_table), "ORFs | Significant:",
                              sum(significant_gene_function_table$significant), "ORFs (adj.p < 0.05)"),
                                x = "Log2 Fold Change (CONTROL vs CELIAC)",
                                y = "-Log10(Adjusted P-value)",
                                caption = "Negative logFC = Higher in CONTROL, Lower in CELIAC"
                              ) +
                              theme_minimal() +
                              theme(
                                plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
                                plot.subtitle = element_text(size = 11, hjust = 0.5),
                                legend.position = "right",
                                legend.title = element_text(size = 11, face = "bold"),
                                panel.grid.minor = element_blank()
                              )

ggsave(total_dataset_volcano_plot_color_by_function,file="~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/US/compositonal_analysis/total_cohort_volcano_plot_color_by_function.pdf", width = 8, height = 8, dpi = 300)

function.table <- significant_gene_function_table %>% filter(adj.P.Val < 0.05) %>% select(c("Row.names","phrog","function","product"))
write.csv(function.table,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/US/compositonal_analysis/function_table.csv",quote = FALSE,row.names = FALSE)




```

########################################################################## Italy ############################################################### 




                                              ############################################################################
                                              #      Limma model on 3% pravelance filtered + temporal filtered data      #   
                                              #         Italy.orf.abundance.table_0.75_prevFiltered_temporal  (2154 orfs)#
                                              ############################################################################
                                              
                                              
Model 3: create a numeric format of onset_timeline and make it onset_timeline_numeric assume it is linear in the model
~ Dx.Status * onset_timeline_numeric + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode, block = patientID
```{r}


# prepare clean metadata
metadata.clean <- Italy.orf.abundance.table_0.75_prevFiltered_temporal[1:25] %>%
                  column_to_rownames("Row.names")
# 96  24


orf.abundance.clean <- Italy.orf.abundance.table_0.75_prevFiltered_temporal %>%
                           select(c("Row.names",26:259)) %>%
                           filter(Row.names %in% rownames(metadata.clean)) %>%
                           column_to_rownames("Row.names") %>% 
                           t(.) %>%
                           data.frame(.)
colnames(orf.abundance.clean) <- gsub("X","",colnames(orf.abundance.clean))
# 234 96


# write.csv(orf.abundance.clean,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/Italy/Italy.orf.abundance.table_0.75_prevFiltered_temporal_cleaned.csv",quote = FALSE,row.names = TRUE)
# 
# write.csv(metadata.clean,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/Italy/Italy.metadata.cleaned.csv",quote = FALSE,row.names = TRUE)

# prepare correct variable format
metadata.clean$feeding_first_year <- factor(metadata.clean$feeding_first_year,levels = c("Breast_fed","Formula","Breastmilk_and_formula"))
# Breast_fed      Formula   Breastmilk_and_formula 
#    120             58              129 
metadata.clean$HLA.Category <- factor(metadata.clean$HLA.Category,levels = c("Standard Risk","High Risk","Low/No Risk"))
# Standard Risk     High Risk   Low/No Risk 
#      169            94            44
metadata.clean$Country <- factor(metadata.clean$Country,levels = c("ITALY","USA"))
# ITALY   USA 
#   110   197 
metadata.clean$Sex <- factor(metadata.clean$Sex,levels = c("Female","Male"))
# Female  Male 
#   238   69
metadata.clean$Delivery.Mode <- factor(metadata.clean$Delivery.Mode,levels = c("Vaginal","C-Section"))
# Vaginal C-Section 
# 217        90
metadata.clean$Age.at.Gluten.Introduction..months. <- as.numeric(metadata.clean$Age.at.Gluten.Introduction..months.)
# #  # 4  5  6  7  8  9 10 11 12 15 36 
# #  # 5 11 57 91 40 33 33 10  2 16  9 
metadata.clean$Dx.Status <- factor(metadata.clean$Dx.Status,levels = c("CELIAC","CONTROL"))
# CONTROL  CELIAC 
#    162     145 


# since the number of parameters changed (onset_timeline as linear numeric), so we need to re-evaluate the linearity of Age.at.Gluten.Introduction..months. variable

# treat Age.at.Gluten.Introduction..months. as linear
linear.model.design <- model.matrix(~ Dx.Status * onset_timeline_numeric + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
linear.model.fit <- voomLmFit(orf.abundance.clean,linear.model.design,block= metadata.clean$patientID,plot=FALSE)
linear.model.fit <- eBayes(linear.model.fit)
linear.model.fit.linear <- linear.model.fit


# treat Age.at.Gluten.Introduction..months. as non-linear
nonlinear.model.design <- model.matrix(~ Dx.Status * onset_timeline_numeric + Sex + ns(Age.at.Gluten.Introduction..months.,df=3) + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)
nonlinear.model.fit <- voomLmFit(orf.abundance.clean,nonlinear.model.design,block= metadata.clean$patientID,plot=FALSE)
nonlinear.model.fit <- eBayes(nonlinear.model.fit)


#######################################################################################################################################
# check which model is better

# Manual computation of fitted values
fitted_linear <- linear.model.fit$coefficients %*% t(linear.model.design)  # Genes × Samples
fitted_spline <- nonlinear.model.fit$coefficients %*% t(nonlinear.model.design)

# calculate the residules for each genes
resid_linear <- orf.abundance.clean - fitted_linear
resid_spline <- orf.abundance.clean - fitted_spline

# compute residual sum of squares (RSS)
rss_linear <- rowSums(resid_linear^2)
rss_spline <- rowSums(resid_spline^2)


# get the sample size per gene
n <- ncol(orf.abundance.clean)
# get the number of model parameters for both models
k_linear <- ncol(linear.model.design)
k_spline <- ncol(nonlinear.model.design)

# given the formula of calculating AIC
# AIC = n * log(RSS / n) + 2 * k
# n = number of observations (samples)
# RSS = residual sum of squares per gene
# k = number of parameters used in the model

# calculate AICs for both models
aic_linear <- n * log(rss_linear / n) + 2 * k_linear
aic_spline <- n * log(rss_spline / n) + 2 * k_spline

# compare AICs of genes for both models
delta_aic <- aic_linear - aic_spline

# make a histogram plot to visualize how the differences of AIC scores distributed 
AIC_differences <- hist(delta_aic, breaks = 50, main = "ΔAIC (Linear - Spline)",
     xlab = "ΔAIC: Positive = spline better")

# calculate how many genes has AIC scores at least 2 points lower than linear model (ΔAIC > 2 is a common cutoff for "meaningful" improvement)
mean(delta_aic > 2)
# 0.03404255 (only 0.03404255 genes are better fit in splines model)

# Conclusion: use linear model
########################################################################################################################################
colnames(linear.model.fit)
#  [1] "(Intercept)"                              "Dx.StatusCONTROL"                        
#  [3] "onset_timeline_numeric"                   "SexMale"                                 
#  [5] "Age.at.Gluten.Introduction..months."      "HLA.CategoryHigh Risk"                   
#  [7] "HLA.CategoryLow/No Risk"                  "feeding_first_yearFormula"               
#  [9] "feeding_first_yearBreastmilk_and_formula" "Delivery.ModeC-Section"                  
# [11] "Dx.StatusCONTROL:onset_timeline_numeric" 


model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_numeric",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_numeric",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 231


# lable the spurious genes

# --- Parameters you can adjust ---
min_timepoints_with_signal <- 3
min_samples_per_timepoint <- 2
min_total_reads_per_group <- 1000

# --- Function to assess one virus ---
flag_virus <- function(gene_name, abundance_table, metadata, time_col = "onset_timeline_numeric") {
  # Extract abundance
  gene_abund <- abundance_table[gene_name, , drop = FALSE]
  gene_abund <- as.numeric(gene_abund)
  
  # Combine with metadata
  df <- metadata %>%
    mutate(abund = gene_abund,
           reads = 2^abund - 1)  # assuming log2(CPM+1), convert back
  
  # Count non-zero samples and reads per time x group
  signal_stats <- df %>%
    group_by(!!sym(time_col), Dx.Status) %>%
    summarise(n_nonzero = sum(abund > 0, na.rm = TRUE),
              total_reads = sum(reads[abund > 0], na.rm = TRUE),
              .groups = "drop")
  
  # Timepoints with at least X non-zero samples
  valid_timepoints <- signal_stats %>%
    filter(n_nonzero >= min_samples_per_timepoint) %>%
    group_by(Dx.Status) %>%
    summarise(n_timepoints_with_signal = n(), .groups = "drop")
  
  # Total reads per group
  read_totals <- signal_stats %>%
    group_by(Dx.Status) %>%
    summarise(total_reads = sum(total_reads), .groups = "drop")
  
  # Flag if any group fails any of the thresholds
  flagged <- any(
    valid_timepoints$n_timepoints_with_signal < min_timepoints_with_signal |
    read_totals$total_reads < min_total_reads_per_group
  )
  
  return(flagged)
}

# --- Apply to all significant genes ---
flagged_results <- sapply(rownames(sig.model.res), function(gene) {
  flag_virus(gene, orf.abundance.clean, metadata.clean)
})

# Get flagged gene names
flagged_genes <- names(flagged_results)[flagged_results]
# 65 genes


# plot the flagged genes

# Subset abundance matrix to spurious genes
spurious_abund <- orf.abundance.clean[rownames(orf.abundance.clean) %in% flagged_genes, ]

# ---------------------------
# Summary statistics
# ---------------------------
# 1. Sparsity (proportion of samples with 0 counts)
sparsity <- rowMeans(spurious_abund == 0, na.rm = TRUE)

# 2. Max count per gene
max_count <- apply(spurious_abund, 1, max, na.rm = TRUE)

# 3. Number of time bins with ≥2 non-zero samples
temporal_support <- function(gene_row, metadata, min_nonzero = 2) {
  df <- data.frame(value = gene_row, time = metadata$onset_timeline_numeric)
  df$nonzero <- df$value > 0
  by_bin <- df %>% group_by(time) %>% summarise(nonzero_n = sum(nonzero, na.rm = TRUE))
  sum(by_bin$nonzero_n >= min_nonzero)
}
support_counts <- apply(spurious_abund, 1, temporal_support, metadata = metadata.clean)

# Combine summary
spurious_summary <- data.frame(
  Gene = rownames(spurious_abund),
  Sparsity = sparsity,
  MaxCount = max_count,
  TimeBinsWithSupport = support_counts
)

# ---------------------------
# Plot distributions
# ---------------------------
# Histogram of sparsity
ggplot(spurious_summary, aes(x = Sparsity)) +
  geom_histogram(bins = 30, fill = "tomato") +
  labs(title = "Sparsity of Spurious Genes", x = "Proportion of 0 Counts", y = "Number of Genes") +
  theme_minimal()

# Histogram of time bin support
ggplot(spurious_summary, aes(x = TimeBinsWithSupport)) +
  geom_histogram(binwidth = 1, fill = "steelblue") +
  labs(title = "Temporal Support of Spurious Genes", x = "# Time Bins with ≥2 Non-zero", y = "Number of Genes") +
  theme_minimal()

# ---------------------------
# Heatmap for inspection (top 50 sparse genes)
# ---------------------------
top_sparse <- head(order(sparsity, decreasing = TRUE), 50)
pheatmap(spurious_abund[top_sparse, ], scale = "row", show_rownames = FALSE,
         main = "Spurious Genes - Top Sparse Profiles")



# plot trajectory for those reliable genes
#selected_gene <- rownames(sig.model.res)[!rownames(sig.model.res) %in% flagged_genes]
selected_gene <- rownames(sig.model.res)

# Subset design matrix and model coefficients for prediction
linear.model.design <- model.matrix(~ Dx.Status * onset_timeline_numeric + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,metadata.clean)

trajectory_plot_list <- list()


for (i in selected_gene){
  
   # Extract observed abundance vector for gene i
  gene_abundance <- orf.abundance.clean[i, ]

  # Create metadata + model prediction + observed abundance
  predicted_df <- metadata.clean %>%
    mutate(predicted_abundance = as.numeric(linear.model.design %*% linear.model.fit$coefficients[i, ]),
           observed_abundance = as.numeric(gene_abundance))

  # Count non-zero samples and total abundance per group and time
  count_df <- predicted_df %>%
    group_by(onset_timeline_numeric, Dx.Status) %>%
    summarise(
      non_zero_n = sum(observed_abundance > 0, na.rm = TRUE),
      total_reads = sum(observed_abundance, na.rm = TRUE),
      .groups = "drop"
    )

  # Get mean predicted values per group and time
plot_df_pred <- predicted_df %>%
  left_join(count_df, by = c("onset_timeline_numeric", "Dx.Status")) %>%
  group_by(onset_timeline_numeric, Dx.Status) %>%
  summarise(
    mean_pred = mean(predicted_abundance, na.rm = TRUE),
    non_zero_n = first(non_zero_n),      # from count_df
    total_reads = first(total_reads),    # from count_df
    .groups = "drop"
  ) %>%
  mutate(mean_pred = ifelse(non_zero_n == 0 & total_reads == 0, NA, mean_pred))

  # Label showing both counts
  plot_df_pred <- plot_df_pred %>%
    mutate(label_text = paste0("n=", non_zero_n, "\nreads=", round(total_reads)))

  # Plot with annotations for sample count and total reads
  p <- ggplot(plot_df_pred, aes(x = onset_timeline_numeric, y = mean_pred, color = Dx.Status)) +
    geom_line(size = 1.2) +
    geom_point(size = 2) +
    geom_text(aes(label = label_text), vjust = -0.5, size = 3) +
    labs(title = i,
         x = "Months before onset", y = "Predicted Abundance (logCPM)") +
    theme(legend.position = "none")

  # Store in list
  trajectory_plot_list[[i]] <- p
}

dev.off()
trajectory_plot_list[1]


# Pick 10 plots
plot_subset <- trajectory_plot_list[1:231]  # or use names: trajectory_plot_list[c("gene1", "gene2", ...)]
# Combine into grid: 2 rows × 5 columns
grid_plot <- wrap_plots(plot_subset)
ggsave(grid_plot,file=paste0("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/Italy/Italy_significant_trajectory_clear.pdf"),dpi = 600,width = 49,height=49)



# hist(sig.model.res$adj.P.Val, breaks = 50) # the shape looks valid
# hist(model.res$adj.P.Val, breaks = 50, col = "gray", main = "All Adjusted P-Values") # the shape looks valid as well

###########################################################################################################################

model.res <- topTable(linear.model.fit,coef="onset_timeline_numeric",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="onset_timeline_numeric",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 4

#################################################################################################

model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="Dx.StatusCONTROL",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0


#################################################################################################

model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="SexMale",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0
model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearFormula",number=Inf) %>% filter(adj.P.Val < 0.05)
# 1 6
model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf)
sig.model.res <- topTable(linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(sig.model.res)
# 0 6


```



Model 2: treat onset_timeline as a categorical variable: modifying onset_timeline by combining the to-42M to t0-72M as one names "t0-over42"
~ Dx.Status * onset_timeline_combined + RunNumber + Country + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode, block = patientID
```{r}

# prepare correct variable format
Italy.metadata.clean$feeding_first_year <- factor(Italy.metadata.clean$feeding_first_year,levels = c("Breast_fed","Formula","Breastmilk_and_formula"))
# Breast_fed      Formula   Breastmilk_and_formula 
#    120             58              129 
Italy.metadata.clean$HLA.Category <- factor(Italy.metadata.clean$HLA.Category,levels = c("Standard Risk","High Risk","Low/No Risk"))
# Standard Risk     High Risk   Low/No Risk 
#      169            94            44
Italy.metadata.clean$Country <- factor(Italy.metadata.clean$Country,levels = c("ITALY","USA"))
# ITALY   USA 
#   110   197 
Italy.metadata.clean$Sex <- factor(Italy.metadata.clean$Sex,levels = c("Female","Male"))
# Female  Male 
#   238   69
Italy.metadata.clean$Delivery.Mode <- factor(Italy.metadata.clean$Delivery.Mode,levels = c("Vaginal","C-Section"))
# Vaginal C-Section 
# 217        90
Italy.metadata.clean$Dx.Status <- factor(Italy.metadata.clean$Dx.Status,levels = c("CELIAC","CONTROL"))
# CONTROL  CELIAC 
#    162     145 
Italy.metadata.clean$onset_timeline_combined <- factor(Italy.metadata.clean$onset_timeline_combined,levels = c("t0","t0-6","t0-12","t0-18","t0-24","t0-30","t0-36","t0-over42"))
 # t0      t0-6     t0-12     t0-18     t0-24     t0-30     t0-36 t0-over42 
 # 64        30        46        27        32        29        33        46 
Italy.metadata.clean$Age.at.Gluten.Introduction..months. <- as.numeric(Italy.metadata.clean$Age.at.Gluten.Introduction..months.)
# 4  5  6  7  8  9 10 11 12 15 36 
# 5 11 57 91 40 33 33 10  2 16  9 


# after combine the late timepoints of onset_timeline, the distribution is like below:
table(Italy.metadata.clean$Dx.Status, Italy.metadata.clean$onset_timeline_combined) %>% t(.)
  #         CELIAC CONTROL
  # t0            16      16
  # t0-6           4       4
  # t0-12         14      14
  # t0-18          7       7
  # t0-24         12      13
  # t0-30         11      11
  # t0-36         13      13
  # t0-over42     21      21

# since the number of parameters changed (less levels in onset_timeline_combined variable), so we need to re-evaluate the linearity of Age.at.Gluten.Introduction..months. variable

# treat Age.at.Gluten.Introduction..months. as linear
Italy.linear.model.design <- model.matrix(~ Dx.Status * onset_timeline_combined + RunNumber + Sex + Age.at.Gluten.Introduction..months. + HLA.Category + feeding_first_year + Delivery.Mode,Italy.metadata.clean)
Italy.linear.model.fit <- voomLmFit(Italy.orf.abundance.clean,Italy.linear.model.design,block= Italy.metadata.clean$patientID,plot=FALSE)
Italy.linear.model.fit <- eBayes(Italy.linear.model.fit)

########################################################################################################################################
colnames(Italy.linear.model.fit)
#  [1] "(Intercept)"                                       "Dx.StatusCONTROL"                                 
#  [3] "onset_timeline_combinedt0-6"                       "onset_timeline_combinedt0-12"                     
#  [5] "onset_timeline_combinedt0-18"                      "onset_timeline_combinedt0-24"                     
#  [7] "onset_timeline_combinedt0-30"                      "onset_timeline_combinedt0-36"                     
#  [9] "onset_timeline_combinedt0-over42"                  "RunNumberN978"                                    
# [11] "RunNumberN979"                                     "RunNumberN980"                                    
# [13] "RunNumberN981"                                     "RunNumberN983"                                    
# [15] "SexMale"                                           "Age.at.Gluten.Introduction..months."              
# [17] "HLA.CategoryHigh Risk"                             "HLA.CategoryLow/No Risk"                          
# [19] "feeding_first_yearFormula"                         "feeding_first_yearBreastmilk_and_formula"         
# [21] "Delivery.ModeC-Section"                            "Dx.StatusCONTROL:onset_timeline_combinedt0-6"     
# [23] "Dx.StatusCONTROL:onset_timeline_combinedt0-12"     "Dx.StatusCONTROL:onset_timeline_combinedt0-18"    
# [25] "Dx.StatusCONTROL:onset_timeline_combinedt0-24"     "Dx.StatusCONTROL:onset_timeline_combinedt0-30"    
# [27] "Dx.StatusCONTROL:onset_timeline_combinedt0-36"     "Dx.StatusCONTROL:onset_timeline_combinedt0-over42"        

Italy.model.res <- topTable(Italy.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-6",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-6",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(US.sig.model.res)
# 0
Italy.model.res <- topTable(Italy.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-12",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-12",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(Italy.sig.model.res)
# 0
Italy.model.res <- topTable(Italy.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-18",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-18",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(Italy.sig.model.res)
# 0
Italy.model.res <- topTable(Italy.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-24",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-24",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(Italy.sig.model.res)
# 2034
Italy.model.res <- topTable(Italy.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-30",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-30",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(Italy.sig.model.res)
# 541
Italy.model.res <- topTable(Italy.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-36",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-36",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(Italy.sig.model.res)
# 0
Italy.model.res <- topTable(Italy.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-over42",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="Dx.StatusCONTROL:onset_timeline_combinedt0-over42",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(Italy.sig.model.res)
# 0


###########################################################################################################################


Italy.model.res <- topTable(Italy.linear.model.fit,coef="onset_timeline_combinedt0-6",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="onset_timeline_combinedt0-6",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(Italy.sig.model.res)
# 0
Italy.model.res <- topTable(Italy.linear.model.fit,coef="onset_timeline_combinedt0-12",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="onset_timeline_combinedt0-12",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(Italy.sig.model.res)
# 0
Italy.model.res <- topTable(Italy.linear.model.fit,coef="onset_timeline_combinedt0-18",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="onset_timeline_combinedt0-18",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(Italy.sig.model.res)
# 0
Italy.model.res <- topTable(Italy.linear.model.fit,coef="onset_timeline_combinedt0-24",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="onset_timeline_combinedt0-24",number=Inf) %>% filter(adj.P.Val < 0.01)
dim(Italy.sig.model.res)
# 2507
Italy.model.res <- topTable(Italy.linear.model.fit,coef="onset_timeline_combinedt0-30",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="onset_timeline_combinedt0-30",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(Italy.sig.model.res)
# 0
Italy.model.res <- topTable(Italy.linear.model.fit,coef="onset_timeline_combinedt0-36",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="onset_timeline_combinedt0-36",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(Italy.sig.model.res)
# 0
Italy.model.res <- topTable(Italy.linear.model.fit,coef="onset_timeline_combinedt0-over42",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="onset_timeline_combinedt0-over42",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(Italy.sig.model.res)
# 0

#################################################################################################

Italy.model.res <- topTable(Italy.linear.model.fit,coef="Dx.StatusCONTROL",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="Dx.StatusCONTROL",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(Italy.sig.model.res)
# 0

#################################################################################################

Italy.model.res <- topTable(Italy.linear.model.fit,coef="SexMale",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="SexMale",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(Italy.sig.model.res)
# 0
Italy.model.res <- topTable(Italy.linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="HLA.CategoryHigh Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(Italy.sig.model.res)
# 0
Italy.model.res <- topTable(Italy.linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="HLA.CategoryLow/No Risk",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(Italy.sig.model.res)
# 0
Italy.model.res <- topTable(Italy.linear.model.fit,coef="feeding_first_yearFormula",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="feeding_first_yearFormula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(Italy.sig.model.res)
# 0
Italy.model.res <- topTable(Italy.linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf)
Italy.sig.model.res <- topTable(Italy.linear.model.fit,coef="feeding_first_yearBreastmilk_and_formula",number=Inf) %>% filter(adj.P.Val < 0.05)
dim(Italy.sig.model.res)
# 0

```




Volcano plot
```{r}



significant_gene_function_table <- read_delim("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/total/phold_per_cds_predictions.tsv") %>%
          select(`cds_id`,`phrog`,`function`,`product`) %>%
          column_to_rownames("cds_id") %>%
          merge(model.res,by = 0)


# make volcano plots for the significant genes

# Add significance categories
significant_gene_function_table$significant <- significant_gene_function_table$adj.P.Val < 0.05
significant_gene_function_table$highly_significant <- significant_gene_function_table$adj.P.Val < 0.001
significant_gene_function_table$neg_log10_padj <- -log10(significant_gene_function_table$adj.P.Val)


# FLIP THE SIGN of logFC to switch axis orientation
significant_gene_function_table$logFC_flipped <- -significant_gene_function_table$logFC


# Create significance labels
significant_gene_function_table$significance_label <- "Not Significant"
significant_gene_function_table$significance_label[significant_gene_function_table$significant] <- "Significant (adj.p < 0.05)"
significant_gene_function_table$significance_label[significant_gene_function_table$highly_significant] <- "Highly Significant (adj.p < 0.001)"



significant_gene_function_table$significance_label <- factor(significant_gene_function_table$significance_label,
                                          levels = c("Not Significant",
                                                    "Significant (adj.p < 0.05)",
                                                    "Highly Significant (adj.p < 0.001)"))

# Define colors
colors <- c("Not Significant" = "grey70",
           "Significant (adj.p < 0.05)" = "#E31A1C",
           "Highly Significant (adj.p < 0.001)" = "#B2182B")

# Create volcano plot
total_dataset_volcano_plot <- ggplot(significant_gene_function_table, aes(x = logFC_flipped, y = neg_log10_padj)) +
  geom_point(aes(color = significance_label), size = 0.8, alpha = 0.7) +
  scale_color_manual(values = colors, name = "Significance") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "red", alpha = 0.7) +
  geom_hline(yintercept = -log10(0.001), linetype = "dashed", color = "darkred", alpha = 0.7) +
  labs(
    title = "Viral ORF Differential Abundance: CONTROL vs CELIAC",
    x = "Log2 Fold Change (CONTROL vs CELIAC)",
    y = "-Log10(Adjusted P-value)"
  ) +
  theme_minimal() +
  theme(
    plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
    legend.position = "bottom"
  )

# Save plot
ggsave(total_dataset_volcano_plot, file="~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/Italy/compositonal_analysis/total_cohort_volcano_plot.pdf", width = 8, height = 8, dpi = 300)


######################### color the points based on gene functions ##############################

# Clean up function names and create simplified categories
significant_gene_function_table$`function`[is.na(significant_gene_function_table$`function`)] <- "unknown function"
significant_gene_function_table$`function`[significant_gene_function_table$`function` == ""] <- "unknown function"


# Create simplified functional categories for better visualization
significant_gene_function_table$func_category <- significant_gene_function_table$`function`
significant_gene_function_table$func_category[grepl("DNA|RNA|nucleotide|replication",
significant_gene_function_table$`function`, ignore.case = TRUE)] <- "DNA/RNA metabolism"
significant_gene_function_table$func_category[grepl("head|packaging|capsid",
significant_gene_function_table$`function`, ignore.case = TRUE)] <- "Head & packaging"
significant_gene_function_table$func_category[grepl("tail|fiber", significant_gene_function_table$`function`,ignore.case = TRUE)] <- "Tail"
significant_gene_function_table$func_category[grepl("lysis|holin", significant_gene_function_table$`function`,ignore.case = TRUE)] <- "Lysis"
significant_gene_function_table$func_category[grepl("transcription|regulation",
significant_gene_function_table$`function`, ignore.case = TRUE)] <- "Transcription"
significant_gene_function_table$func_category[grepl("integration|excision|recombination",
significant_gene_function_table$`function`, ignore.case = TRUE)] <- "Integration/excision"
significant_gene_function_table$func_category[grepl("connector", significant_gene_function_table$`function`,ignore.case = TRUE)] <- "Connector"
significant_gene_function_table$func_category[grepl("unknown|hypothetical",significant_gene_function_table$`function`, ignore.case = TRUE)] <- "Unknown function"
significant_gene_function_table$func_category[grepl("other", significant_gene_function_table$`function`,ignore.case = TRUE)] <- "Other"

# Count functions and keep only top categories, group rare ones as 
"Other"
func_counts <- table(significant_gene_function_table$func_category)
top_functions <- names(sort(func_counts, decreasing = TRUE))[1:8]  # Keep top 8
significant_gene_function_table$func_category[!significant_gene_function_table$func_category %in% top_functions] <- "Other/Rare"

# Create color palette for functions
func_colors <- c(
"DNA/RNA metabolism" = "#1f77b4",
"Head & packaging" = "#ff7f0e",
"Tail" = "#2ca02c",
"Unknown function" = "#d62728",
"Lysis" = "#9467bd",
"Transcription" = "#8c564b",
"Integration/excision" = "#e377c2",
"Connector" = "#7f7f7f",
"Other" = "#bcbd22",
"Other/Rare" = "#17becf"
)



# Create volcano plot colored by function
total_dataset_volcano_plot_color_by_function <- ggplot(significant_gene_function_table, aes(x = logFC_flipped, y = neg_log10_padj)) +
                              geom_point(data = significant_gene_function_table %>% filter(adj.P.Val < 0.05), aes(color = func_category), size = 0.8, alpha = 0.7) +
                              geom_point(data = significant_gene_function_table %>% filter(adj.P.Val >= 0.05),color = "gray",size = 0.8, alpha = 0.7)+ 
                              scale_color_manual(values = func_colors, name = "Gene Function") +
                              geom_hline(yintercept = -log10(0.05), linetype = "dashed", color =
                              "black", alpha = 0.5) +
                              geom_hline(yintercept = -log10(0.001), linetype = "dashed", color =
                              "black", alpha = 0.7) +
                              labs(
                                title = "Viral ORF Differential Abundance by Gene Function",
                                subtitle = paste("Total:", nrow(significant_gene_function_table), "ORFs | Significant:",
                              sum(significant_gene_function_table$significant), "ORFs (adj.p < 0.05)"),
                                x = "Log2 Fold Change (CONTROL vs CELIAC)",
                                y = "-Log10(Adjusted P-value)",
                                caption = "Negative logFC = Higher in CONTROL, Lower in CELIAC"
                              ) +
                              theme_minimal() +
                              theme(
                                plot.title = element_text(size = 14, face = "bold", hjust = 0.5),
                                plot.subtitle = element_text(size = 11, hjust = 0.5),
                                legend.position = "right",
                                legend.title = element_text(size = 11, face = "bold"),
                                panel.grid.minor = element_blank()
                              )

ggsave(total_dataset_volcano_plot_color_by_function,file="~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/Italy/compositonal_analysis/total_cohort_volcano_plot_color_by_function.pdf", width = 8, height = 8, dpi = 300)

function.table <- significant_gene_function_table %>% filter(adj.P.Val < 0.05) %>% select(c("Row.names","phrog","function","product"))
write.csv(function.table,"~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/data_correct/Italy/compositonal_analysis/function_table.csv",quote = FALSE,row.names = FALSE)




```



















detailed analysis on significant genes
```{r}


# Step 1: Categorize genes
library(limma)

# Extract adjusted p-values for main and interaction terms
tt_main <- topTable(model.fit, coef = "Dx.StatusCELIAC", number = Inf)
tt_int1 <- topTable(model.fit, coef = "Dx.StatusCELIAC:ns(month, df = 3)1", number = Inf)

# Merge by gene names
tt_combined <- merge(tt_main[, c("adj.P.Val", "logFC")],
                     tt_int1[, c("adj.P.Val", "logFC")],
                     by = "row.names", suffixes = c("_main", "_int1"))
colnames(tt_combined)[1] <- "Gene"


# Step 2: Categorize genes

tt_combined$category <- "Not Significant"
tt_combined$category[tt_combined$adj.P.Val_main < 0.05 & tt_combined$adj.P.Val_int1 >= 0.05] <- "Main Only"
tt_combined$category[tt_combined$adj.P.Val_main >= 0.05 & tt_combined$adj.P.Val_int1 < 0.05] <- "Interaction Only"
tt_combined$category[tt_combined$adj.P.Val_main < 0.05 & tt_combined$adj.P.Val_int1 < 0.05] <- "Both"

table(tt_combined$category)
# Both     Interaction Only       Main Only    Not Significant 
# 1253             1299              189              336 



```


volcano plot on Main Only genes (189 genes)
```{r}

# Step 1: Identify main-only genes
sig_genes <- main_only_genes$Gene

# Step 2: Add cluster for coloring (only for main-only genes)
tt_combined$cluster <- sub("(_\\d+)$", "", tt_combined$Gene)

# Step 3: Define color_group
tt_combined$color_group <- ifelse(tt_combined$Gene %in% sig_genes,
                                   tt_combined$cluster,
                                   "Not significant")


padj.check.hist <- hist(tt_combined$adj.P.Val_main, breaks = 50, col = "gray", main = "Distribution of Adjusted P-values")


# Unique clusters among main-only genes only (exclude "Not significant")
clusters <- unique(tt_combined$color_group[tt_combined$color_group != "Not significant"])
# Assign distinct colors to clusters using viridis
cluster_colors <- setNames(viridis::viridis(length(clusters)), clusters)
# Add gray for background genes
final_colors <- c(cluster_colors, "Not significant" = "gray85")

# Step 4: Separate foreground (main-only) and background genes
tt_bg <- tt_combined[tt_combined$color_group == "Not significant", ]
tt_fg <- tt_combined[tt_combined$color_group != "Not significant", ]


p.vol <- ggplot() +
  # Plot gray background first
  geom_point(data = tt_bg, aes(x = logFC_main, y = -log10(adj.P.Val_main)),
             color = "gray85", size = 1.0, alpha = 0.6) +
  
  # Plot colored main-only genes on top
  geom_point(data = tt_fg, aes(x = logFC_main, y = -log10(adj.P.Val_main), color = color_group),
             size = 1.8, alpha = 0.9) +

  # Threshold lines
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "gray60") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "gray60") +

  # Colors
  scale_color_manual(values = final_colors) +

  # Labels and theme
  labs(title = "Main-Disease-Effect-Only Genes Highlighted by Contigs (189 Orfs clustered in 82 Contigs)",
       subtitle = "These Orfs are consistently abundant in control over all timepoints",
       x = "log2 Fold Change (Control vs Celiac)",
       y = "-log10 Adjusted P-value",
       color = "Cluster") +
  theme_minimal(base_size = 13) +
  theme(legend.position = "none")






# tt_combined: merged topTable with adj.P.Val and logFC
main_only_genes <- tt_combined[tt_combined$category == "Main Only", ]


p.consistent <- EnhancedVolcano(main_only_genes,
                lab = main_only_genes$Gene,
                selectLab = NA,
                x = 'logFC_main',
                y = 'adj.P.Val_main',
                xlim = c(-4, 4),
                pCutoff = 0.05,
                FCcutoff = 1,
                title = 'Main Effect Only Genes',
                subtitle = 'Celiac vs Control (time-adjusted)',
                caption = 'logFC > 1 and adj.P < 0.05',
                pointSize = 2.5,
                labSize = 3.5)


main_only_genes$cluster <- sub("(_\\d+)$", "", main_only_genes$Gene)

library(ggplot2)

p.volcano <- ggplot(main_only_genes, aes(x = logFC_main, y = -log10(adj.P.Val_main), color = cluster)) +
  geom_point(alpha = 0.8, size = 2.5) +
  theme_minimal() +
  labs(title = "Volcano Plot of Main-Only Genes",
       x = "log2 Fold Change (Celiac vs Control)",
       y = "-log10 Adjusted P-value") +
  geom_vline(xintercept = c(-1, 1), linetype = "dashed", color = "grey50") +
  geom_hline(yintercept = -log10(0.05), linetype = "dashed", color = "grey50") +
  theme(legend.position = "none")







# Step 3: Plot predicted trajectories

library(splines)
library(ggplot2)

# Example: choose top 1 gene from each category
selected_genes <- c(
  head(tt_combined$Gene[tt_combined$category == "Main Only"], 1),
  head(tt_combined$Gene[tt_combined$category == "Interaction Only"], 1),
  head(tt_combined$Gene[tt_combined$category == "Both"], 1)
)

# Create model matrix
model.design <- model.matrix(~ Dx.Status * ns(month, df = 3) +
                             Country + Sex +
                             ns(as.numeric(Age.at.Gluten.Introduction..months.), df = 3) +
                             HLA.Category + feeding_first_year + Delivery.Mode,
                             metadata.clean)


# Predict values
coefs_sub <- t(model.fit$coefficients[selected_genes, , drop = FALSE])  # Now [p x g]
predicted <- model.design %*% coefs_sub  # [n x p] %*% [p x g] = [n x g]

# Combine with metadata
plot_data <- cbind(metadata.clean, as.data.frame(predicted))
plot_data_long <- reshape2::melt(plot_data, id.vars = c("month", "Dx.Status"))

# Plot
ggplot(plot_data_long, aes(x = month, y = value, color = Dx.Status)) +
  geom_smooth(method = "loess", se = FALSE) +
  facet_wrap(~ variable, scales = "free_y") +
  labs(title = "Predicted Abundance Trajectories", y = "Predicted logCPM")


#Step 4: Optional — Heatmap of interaction effect

library(pheatmap)

# Subset interaction term coefficients
int_coef <- model.fit$coefficients[, grep("Dx.StatusCELIAC:ns\\(month", colnames(model.fit$coefficients))]

# Keep top 100 genes with lowest p in interaction
top_int <- rownames(tt_int1)[order(tt_int1$adj.P.Val)][1:100]

pheatmap(int_coef[top_int, ], cluster_rows = TRUE, cluster_cols = FALSE,
         main = "Time-Varying Disease Effect (Interaction Coefficients)")

```


trajectory plots for the 189 genes
```{r}

# Define gene of interest
selected_gene <- sig_genes

# Subset design matrix and model coefficients for prediction
model.design <- model.matrix(~ Dx.Status * ns(month, df = 3) +
                             Country + Sex +
                             ns(as.numeric(Age.at.Gluten.Introduction..months.), df = 3) +
                             HLA.Category + feeding_first_year + Delivery.Mode,
                             data = metadata.clean)

for (i in selected_gene){
  
  
  # Get predicted values from model
predicted_vals <- model.design %*% model.fit$coefficients[i, ]

# Add to metadata
predicted_df <- cbind(metadata.clean, predicted_abundance = predicted_vals)

# Summarize by Dx.Status and month
plot_df_pred <- predicted_df %>%
  group_by(month, Dx.Status) %>%
  summarise(mean_pred = mean(predicted_abundance, na.rm = TRUE)) %>%
  ungroup()

# Plot predicted trajectory
p <- ggplot(plot_df_pred, aes(x = month, y = mean_pred, color = Dx.Status)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  labs(title = paste("Model-Predicted Abundance for", i),
       x = "Month", y = "Predicted Abundance (logCPM)") +
  theme_minimal()

ggsave(p,file=paste0("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/plots/main-only/",i,"_trajectory.pdf"),dpi = 600,width = 8,height=6)
  
  
}


######## combine plots into one ############

library(magick)

# Step 1: Define your image directory and files
plot_dir <- "~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/plots/main-only/"  # <<-- change this
img_files <- list.files(plot_dir, pattern = "\\.pdf$", full.names = TRUE)
img_files <- sort(img_files)

# Step 2: Safely read all images
img_list <- lapply(img_files, function(f) {
  tryCatch({
    image_read(f)
  }, error = function(e) {
    message("Error reading file: ", f)
    NULL
  })
})

# Step 3: Filter out bad images
img_list <- Filter(function(x) inherits(x, "magick-image"), img_list)

# Step 4: Resize all to same dimensions (required)
img_list <- lapply(img_list, function(img) image_resize(img, "400x400"))

# Step 5: Group into rows of 10
n_col <- 10
img_rows <- split(img_list, ceiling(seq_along(img_list) / n_col))

# Step 6: Append each row horizontally
row_imgs <- lapply(img_rows, function(row) {
  # Ensure each row has exactly n_col images by padding with blank
  if (length(row) < n_col) {
    blanks_needed <- n_col - length(row)
    blank_img <- image_blank(width = 400, height = 400, color = "white")
    row <- c(row, rep(list(blank_img), blanks_needed))
  }
  image_append(image_join(row))
})

# Step 7: Stack all rows vertically
final_grid <- image_append(image_join(row_imgs), stack = TRUE)

# Step 8: Save and display
image_write(final_grid, "~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/plots/main-only/combined_grid_plot.pdf")
print(final_grid)
```



plots on Interaction Only genes (1299)
```{r}

library(limma)
library(dplyr)
library(tidyr)
library(ggplot2)
library(pheatmap)
library(splines)

# Step 1: Extract design matrix and metadata
metadata <- metadata.clean
model_design <- model.matrix(~ Dx.Status * ns(month, df = 3) +
                               Country + Sex +
                               ns(as.numeric(Age.at.Gluten.Introduction..months.), df = 3) +
                               HLA.Category + feeding_first_year + Delivery.Mode,
                             data = metadata)

# Step 2: Pick interaction-only genes
interaction_only_genes <- tt_combined %>%
  filter(category == "Interaction Only") %>%
  pull(Gene)

# Safety check
interaction_only_genes <- intersect(interaction_only_genes, rownames(model.fit$coefficients))
if (length(interaction_only_genes) == 0) stop("No interaction-only genes found in model coefficients.")

# Step 3: Predict expression values
predicted_expr <- model_design %*% t(model.fit$coefficients[interaction_only_genes, , drop = FALSE])
predicted_expr <- as.data.frame(predicted_expr)
predicted_expr$SampleID <- rownames(model_design)

# Step 4: Merge with metadata
metadata$SampleID <- rownames(metadata)
merged <- left_join(predicted_expr, metadata, by = "SampleID")

# Step 5: Reshape to long format
expr_long <- merged %>%
  pivot_longer(cols = all_of(interaction_only_genes), names_to = "Gene", values_to = "Predicted")

# Step 6: Compute group-wise mean per month
group_means <- expr_long %>%
  group_by(Gene, month, Dx.Status) %>%
  summarise(mean_pred = mean(Predicted, na.rm = TRUE), .groups = "drop")

# Step 7: Compute group difference: CELIAC - CONTROL
group_diff <- group_means %>%
  pivot_wider(names_from = Dx.Status, values_from = mean_pred) %>%
  mutate(diff = CELIAC - CONTROL)

# Step 8: Create heatmap matrix (genes × month)
heatmap_df <- group_diff %>%
  select(Gene, month, diff) %>%
  pivot_wider(names_from = month, values_from = diff) %>%
  column_to_rownames("Gene")

# Optional: scale rows (genes)
heatmap_matrix <- as.matrix(heatmap_df)
heatmap_matrix_scaled <- t(scale(t(heatmap_matrix)))  # z-score by gene

# Step 9: Plot heatmap
p.heatmap <- pheatmap(heatmap_matrix_scaled,
         cluster_rows = TRUE,
         cluster_cols = FALSE,
         color = colorRampPalette(c("blue", "white", "red"))(100),
         fontsize_row = 6,
         main = "Predicted Abundance Difference (CELIAC - CONTROL)")

ggsave(p.heatmap,file="~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/plots/main-only/interaction-only.heamtap.pdf",dpi=600,width=15,height = 49)
```



trajectory plots for the both significant genes (1253 genes)
```{r}

sig_genes <- tt_combined %>% filter(category == "Both") %>% pull(Gene)
# Define gene of interest
selected_gene <- sig_genes

# Subset design matrix and model coefficients for prediction
model.design <- model.matrix(~ Dx.Status * ns(month, df = 3) +
                             Country + Sex +
                             ns(as.numeric(Age.at.Gluten.Introduction..months.), df = 3) +
                             HLA.Category + feeding_first_year + Delivery.Mode,
                             data = metadata.clean)

for (i in selected_gene){
  
  
  # Get predicted values from model
predicted_vals <- model.design %*% model.fit$coefficients[i, ]

# Add to metadata
predicted_df <- cbind(metadata.clean, predicted_abundance = predicted_vals)

# Summarize by Dx.Status and month
plot_df_pred <- predicted_df %>%
  group_by(month, Dx.Status) %>%
  summarise(mean_pred = mean(predicted_abundance, na.rm = TRUE)) %>%
  ungroup()

# Plot predicted trajectory
p <- ggplot(plot_df_pred, aes(x = month, y = mean_pred, color = Dx.Status)) +
  geom_line(size = 1.2) +
  geom_point(size = 2) +
  labs(title = paste("Model-Predicted Abundance for", i),
       x = "Month", y = "Predicted Abundance (logCPM)") +
  theme_minimal()

ggsave(p,file=paste0("~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/plots/both/",i,"_trajectory.pdf"),dpi = 600,width = 8,height=6)
  
  
}


######## combine plots into one ############

library(magick)

# Step 1: Define your image directory and files
plot_dir <- "~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/plots/both/"  # <<-- change this
img_files <- list.files(plot_dir, pattern = "\\.pdf$", full.names = TRUE)
img_files <- sort(img_files)

# Step 2: Safely read all images
img_list <- lapply(img_files, function(f) {
  tryCatch({
    image_read(f)
  }, error = function(e) {
    message("Error reading file: ", f)
    NULL
  })
})

# Step 3: Filter out bad images
img_list <- Filter(function(x) inherits(x, "magick-image"), img_list)

# Step 4: Resize all to same dimensions (required)
img_list <- lapply(img_list, function(img) image_resize(img, "400x400"))

# Step 5: Group into rows of 10
n_col <- 10
img_rows <- split(img_list, ceiling(seq_along(img_list) / n_col))

# Step 6: Append each row horizontally
row_imgs <- lapply(img_rows, function(row) {
  # Ensure each row has exactly n_col images by padding with blank
  if (length(row) < n_col) {
    blanks_needed <- n_col - length(row)
    blank_img <- image_blank(width = 400, height = 400, color = "white")
    row <- c(row, rep(list(blank_img), blanks_needed))
  }
  image_append(image_join(row))
})

# Step 7: Stack all rows vertically
final_grid <- image_append(image_join(row_imgs), stack = TRUE)

# Step 8: Save and display
image_write(final_grid, "~/Handley Lab Dropbox/16S/Celiac/Phage/phage_detection_pipeline_new_assembly/Orf/plots/both/combined_grid_plot.pdf")
print(final_grid)


```


prepare tables for making plots
```{r}

# Get all coefficient names except the intercept
coef_names <- colnames(model.fit$coefficients)
coef_names <- coef_names[coef_names != "(Intercept)"]

# Initialize list to store topTable results
tt_list <- list()

# Loop through all coefficients and get topTable
for (coef in coef_names) {
  tt <- topTable(model.fit, coef = coef, number = Inf, sort.by = "none")
  tt_list[[coef]] <- tt
}

# Optional: also store significant gene names (FDR < 0.05)
sig_genes_list <- lapply(tt_list, function(tt) {
  rownames(tt[tt$adj.P.Val < 0.05, ])
})


# Reconstruct tt_list using topTable()
tt_list <- list()

for (coef in coef_names) {
  tt_list[[coef]] <- topTable(model.fit, coef = coef, number = Inf, sort.by = "none")
}

```


make upset plots
```{r}

library(UpSetR)




upset(fromList(sig_genes_list),
      sets = names(sig_genes_list),
      order.by = "freq",
      main.bar.color = "steelblue")


```


make volcano plots
```{r}


library(EnhancedVolcano)

p_cutoff <- 0.05
fc_cutoff <- 1

# Extract the data
tt <- tt_list[["Dx.StatusCELIAC"]]

# Count how many genes pass both thresholds
n_sig <- sum(tt$adj.P.Val < p_cutoff & abs(tt$logFC) > fc_cutoff)

maxY <- max(-log10(tt_list[["Dx.StatusCELIAC"]]$adj.P.Val), na.rm = TRUE)

# Plot the volcano
p.volcano <- EnhancedVolcano(tt,
  lab = rownames(tt),
  selectLab = NA,
  x = 'logFC',
  y = 'adj.P.Val',
  pCutoff = p_cutoff,
  FCcutoff = fc_cutoff,
  ylim = c(0, ceiling(maxY) + 0.5),  # set to slightly above max
  title = "Disease Main Effect",
  subtitle = paste("Significant genes:", n_sig)
)



tt <- tt_list[["Dx.StatusCELIAC:ns(month, df = 3)1"]]
# Count how many genes pass both thresholds
n_sig <- sum(tt$adj.P.Val < p_cutoff & abs(tt$logFC) > fc_cutoff)

maxY <- max(-log10(tt$adj.P.Val), na.rm = TRUE)

# Plot the volcano
p.volcano <- EnhancedVolcano(tt,
  lab = rownames(tt),
  selectLab = NA,
  x = 'logFC',
  y = 'adj.P.Val',
  pCutoff = p_cutoff,
  FCcutoff = fc_cutoff,
  ylim = c(0, ceiling(maxY) + 0.5),  # set to slightly above max
  title = "Disease Main Effect",
  subtitle = paste("Significant genes:", n_sig)
)


```


make splines plots
```{r}

library(splines)
library(ggplot2)

# Step 1: Select a single representative age for gluten intro
mean_gluten <- mean(as.numeric(metadata.clean$Age.at.Gluten.Introduction..months.), na.rm = TRUE)

# Step 2: Compute spline basis from training data
spline_basis <- ns(as.numeric(metadata.clean$Age.at.Gluten.Introduction..months.), df = 3)
gluten_ns_basis <- ns(mean_gluten, df = 3, knots = attr(spline_basis, "knots"),
                      Boundary.knots = attr(spline_basis, "Boundary.knots"))

# Step 3: Build prediction grid
month_seq <- seq(min(metadata.clean$month), max(metadata.clean$month), length.out = 100)

newdata <- expand.grid(
  Dx.Status = c("CONTROL", "CELIAC"),
  month = month_seq
)

# Fill in other covariates
newdata$Country <- get_mode(metadata.clean$Country)
newdata$Sex <- get_mode(metadata.clean$Sex)
newdata$HLA.Category <- get_mode(metadata.clean$HLA.Category)
newdata$feeding_first_year <- get_mode(metadata.clean$feeding_first_year)
newdata$Delivery.Mode <- get_mode(metadata.clean$Delivery.Mode)

# Add spline basis columns manually
newdata$ns_age1 <- gluten_ns_basis[1]
newdata$ns_age2 <- gluten_ns_basis[2]
newdata$ns_age3 <- gluten_ns_basis[3]

# Also re-compute spline basis for month
spline_month_basis <- ns(metadata.clean$month, df = 3)
month_ns_basis <- ns(newdata$month, df = 3, knots = attr(spline_month_basis, "knots"),
                     Boundary.knots = attr(spline_month_basis, "Boundary.knots"))
newdata$ns_month1 <- month_ns_basis[, 1]
newdata$ns_month2 <- month_ns_basis[, 2]
newdata$ns_month3 <- month_ns_basis[, 3]

# Step 4: Build model matrix manually using fixed covariates and spline columns
design.new <- model.matrix(~ Dx.Status * (ns_month1 + ns_month2 + ns_month3) +
                           Country + Sex +
                           ns_age1 + ns_age2 + ns_age3 +
                           HLA.Category + feeding_first_year + Delivery.Mode,
                           data = newdata)

# Step 5: Predict for a gene
gene_index <- "virus_comp_733_cycle_1_45"  # change as needed
coefs <- model.fit$coefficients[gene_index, ]
newdata$predicted <- as.vector(design.new %*% coefs)

# Step 6: Plot
ggplot(newdata, aes(x = month, y = predicted, color = Dx.Status)) +
  geom_line(size = 1.2) +
  labs(title = paste("Predicted ORF Abundance Over Time (Gene", gene_index, ")"),
       x = "Month", y = "Predicted logCPM") +
  scale_color_manual(values = c("CONTROL" = "gray30", "CELIAC" = "firebrick")) +
  theme_minimal()
```




                                            


